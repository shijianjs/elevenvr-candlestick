// ==UserScript==
// @name         elevenvr-candlestick
// @namespace    npm/vite-plugin-monkey
// @version      0.2.0
// @author       shijianjs
// @description  Eleven table tennis vr 的elo页面添加K线图功能。源码：https://github.com/shijianjs/elevenvr-candlestick
// @icon         https://vitejs.dev/logo.svg
// @match        https://elevenvr.net/eleven/*
// @require      https://cdn.jsdelivr.net/npm/react@18.2.0/umd/react.production.min.js
// @require      https://cdn.jsdelivr.net/npm/react-dom@18.2.0/umd/react-dom.production.min.js
// @require      https://cdn.jsdelivr.net/npm/echarts@5.4.2/dist/echarts.min.js
// ==/UserScript==

(function (React, ReactDOM__default, echarts) {
  'use strict';

  function _interopNamespaceDefault(e) {
    const n = Object.create(null, { [Symbol.toStringTag]: { value: 'Module' } });
    if (e) {
      for (const k in e) {
        if (k !== 'default') {
          const d = Object.getOwnPropertyDescriptor(e, k);
          Object.defineProperty(n, k, d.get ? d : {
            enumerable: true,
            get: () => e[k]
          });
        }
      }
    }
    n.default = e;
    return Object.freeze(n);
  }

  const React__namespace = /*#__PURE__*/_interopNamespaceDefault(React);
  const ReactDOM__default__namespace = /*#__PURE__*/_interopNamespaceDefault(ReactDOM__default);
  const echarts__namespace = /*#__PURE__*/_interopNamespaceDefault(echarts);

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
  function getDefaultExportFromCjs(x2) {
    return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
  }
  var jsxRuntime = { exports: {} };
  var reactJsxRuntime_production_min = {};
  /**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var f$1 = React, k$1 = Symbol.for("react.element"), l$1 = Symbol.for("react.fragment"), m$2 = Object.prototype.hasOwnProperty, n$1 = f$1.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$1 = { key: true, ref: true, __self: true, __source: true };
  function q$1(c2, a, g2) {
    var b2, d2 = {}, e2 = null, h2 = null;
    void 0 !== g2 && (e2 = "" + g2);
    void 0 !== a.key && (e2 = "" + a.key);
    void 0 !== a.ref && (h2 = a.ref);
    for (b2 in a)
      m$2.call(a, b2) && !p$1.hasOwnProperty(b2) && (d2[b2] = a[b2]);
    if (c2 && c2.defaultProps)
      for (b2 in a = c2.defaultProps, a)
        void 0 === d2[b2] && (d2[b2] = a[b2]);
    return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$1.current };
  }
  reactJsxRuntime_production_min.Fragment = l$1;
  reactJsxRuntime_production_min.jsx = q$1;
  reactJsxRuntime_production_min.jsxs = q$1;
  {
    jsxRuntime.exports = reactJsxRuntime_production_min;
  }
  var jsxRuntimeExports = jsxRuntime.exports;
  var client = {};
  var m$1 = ReactDOM__default;
  {
    client.createRoot = m$1.createRoot;
    client.hydrateRoot = m$1.hydrateRoot;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _typeof(obj) {
    "@babel/helpers - typeof";
    return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
      return typeof obj2;
    } : function(obj2) {
      return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    }, _typeof(obj);
  }
  function _toPrimitive$1(input, hint) {
    if (_typeof(input) !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (_typeof(res) !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey$1(arg) {
    var key = _toPrimitive$1(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
  }
  function _defineProperties$1(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
    }
  }
  function _createClass$1(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties$1(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties$1(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _setPrototypeOf$2(o, p2) {
    _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf$2(o, p2);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    Object.defineProperty(subClass, "prototype", {
      writable: false
    });
    if (superClass)
      _setPrototypeOf$2(subClass, superClass);
  }
  function _getPrototypeOf$1(o) {
    _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf$1(o);
  }
  function _isNativeReflectConstruct$1() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _assertThisInitialized$1(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _possibleConstructorReturn(self2, call2) {
    if (call2 && (_typeof(call2) === "object" || typeof call2 === "function")) {
      return call2;
    } else if (call2 !== void 0) {
      throw new TypeError("Derived constructors may only return object or undefined");
    }
    return _assertThisInitialized$1(self2);
  }
  function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
    return function _createSuperInternal() {
      var Super = _getPrototypeOf$1(Derived), result;
      if (hasNativeReflectConstruct) {
        var NewTarget = _getPrototypeOf$1(this).constructor;
        result = Reflect.construct(Super, arguments, NewTarget);
      } else {
        result = Super.apply(this, arguments);
      }
      return _possibleConstructorReturn(this, result);
    };
  }
  var classnames = { exports: {} };
  /*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  */
  (function(module) {
    (function() {
      var hasOwn = {}.hasOwnProperty;
      function classNames2() {
        var classes = [];
        for (var i = 0; i < arguments.length; i++) {
          var arg = arguments[i];
          if (!arg)
            continue;
          var argType = typeof arg;
          if (argType === "string" || argType === "number") {
            classes.push(arg);
          } else if (Array.isArray(arg)) {
            if (arg.length) {
              var inner = classNames2.apply(null, arg);
              if (inner) {
                classes.push(inner);
              }
            }
          } else if (argType === "object") {
            if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
              classes.push(arg.toString());
              continue;
            }
            for (var key in arg) {
              if (hasOwn.call(arg, key) && arg[key]) {
                classes.push(key);
              }
            }
          }
        }
        return classes.join(" ");
      }
      if (module.exports) {
        classNames2.default = classNames2;
        module.exports = classNames2;
      } else {
        window.classNames = classNames2;
      }
    })();
  })(classnames);
  var classnamesExports = classnames.exports;
  const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
  function _extends$2() {
    _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$2.apply(this, arguments);
  }
  var reactIs = { exports: {} };
  var reactIs_production_min = {};
  /** @license React v16.13.1
   * react-is.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  var b = "function" === typeof Symbol && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
  function z(a) {
    if ("object" === typeof a && null !== a) {
      var u = a.$$typeof;
      switch (u) {
        case c:
          switch (a = a.type, a) {
            case l:
            case m:
            case e:
            case g:
            case f:
            case p:
              return a;
            default:
              switch (a = a && a.$$typeof, a) {
                case k:
                case n:
                case t:
                case r:
                case h:
                  return a;
                default:
                  return u;
              }
          }
        case d:
          return u;
      }
    }
  }
  function A(a) {
    return z(a) === m;
  }
  reactIs_production_min.AsyncMode = l;
  reactIs_production_min.ConcurrentMode = m;
  reactIs_production_min.ContextConsumer = k;
  reactIs_production_min.ContextProvider = h;
  reactIs_production_min.Element = c;
  reactIs_production_min.ForwardRef = n;
  reactIs_production_min.Fragment = e;
  reactIs_production_min.Lazy = t;
  reactIs_production_min.Memo = r;
  reactIs_production_min.Portal = d;
  reactIs_production_min.Profiler = g;
  reactIs_production_min.StrictMode = f;
  reactIs_production_min.Suspense = p;
  reactIs_production_min.isAsyncMode = function(a) {
    return A(a) || z(a) === l;
  };
  reactIs_production_min.isConcurrentMode = A;
  reactIs_production_min.isContextConsumer = function(a) {
    return z(a) === k;
  };
  reactIs_production_min.isContextProvider = function(a) {
    return z(a) === h;
  };
  reactIs_production_min.isElement = function(a) {
    return "object" === typeof a && null !== a && a.$$typeof === c;
  };
  reactIs_production_min.isForwardRef = function(a) {
    return z(a) === n;
  };
  reactIs_production_min.isFragment = function(a) {
    return z(a) === e;
  };
  reactIs_production_min.isLazy = function(a) {
    return z(a) === t;
  };
  reactIs_production_min.isMemo = function(a) {
    return z(a) === r;
  };
  reactIs_production_min.isPortal = function(a) {
    return z(a) === d;
  };
  reactIs_production_min.isProfiler = function(a) {
    return z(a) === g;
  };
  reactIs_production_min.isStrictMode = function(a) {
    return z(a) === f;
  };
  reactIs_production_min.isSuspense = function(a) {
    return z(a) === p;
  };
  reactIs_production_min.isValidElementType = function(a) {
    return "string" === typeof a || "function" === typeof a || a === e || a === m || a === g || a === f || a === p || a === q || "object" === typeof a && null !== a && (a.$$typeof === t || a.$$typeof === r || a.$$typeof === h || a.$$typeof === k || a.$$typeof === n || a.$$typeof === w || a.$$typeof === x || a.$$typeof === y || a.$$typeof === v);
  };
  reactIs_production_min.typeOf = z;
  {
    reactIs.exports = reactIs_production_min;
  }
  var reactIsExports = reactIs.exports;
  function toArray$3(children) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var ret = [];
    React.Children.forEach(children, function(child) {
      if ((child === void 0 || child === null) && !option.keepEmpty) {
        return;
      }
      if (Array.isArray(child)) {
        ret = ret.concat(toArray$3(child));
      } else if (reactIsExports.isFragment(child) && child.props) {
        ret = ret.concat(toArray$3(child.props.children, option));
      } else {
        ret.push(child);
      }
    });
    return ret;
  }
  var warned = {};
  var preMessage = function preMessage2(fn) {
  };
  function warning$2(valid, message) {
  }
  function note(valid, message) {
  }
  function resetWarned() {
    warned = {};
  }
  function call(method4, valid, message) {
    if (!valid && !warned[message]) {
      method4(false, message);
      warned[message] = true;
    }
  }
  function warningOnce(valid, message) {
    call(warning$2, valid, message);
  }
  function noteOnce(valid, message) {
    call(note, valid, message);
  }
  warningOnce.preMessage = preMessage;
  warningOnce.resetWarned = resetWarned;
  warningOnce.noteOnce = noteOnce;
  function _defineProperty(obj, key, value) {
    key = _toPropertyKey$1(key);
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function ownKeys$1(object5, enumerableOnly) {
    var keys2 = Object.keys(object5);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object5);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object5, sym).enumerable;
      })), keys2.push.apply(keys2, symbols);
    }
    return keys2;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function useMemo(getValue2, condition, shouldUpdate) {
    var cacheRef = React__namespace.useRef({});
    if (!("value" in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
      cacheRef.current.value = getValue2();
      cacheRef.current.condition = condition;
    }
    return cacheRef.current.value;
  }
  function fillRef(ref, node2) {
    if (typeof ref === "function") {
      ref(node2);
    } else if (_typeof(ref) === "object" && ref && "current" in ref) {
      ref.current = node2;
    }
  }
  function composeRef() {
    for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
      refs[_key] = arguments[_key];
    }
    var refList = refs.filter(function(ref) {
      return ref;
    });
    if (refList.length <= 1) {
      return refList[0];
    }
    return function(node2) {
      refs.forEach(function(ref) {
        fillRef(ref, node2);
      });
    };
  }
  function useComposeRef() {
    for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      refs[_key2] = arguments[_key2];
    }
    return useMemo(function() {
      return composeRef.apply(void 0, refs);
    }, refs, function(prev2, next2) {
      return prev2.length === next2.length && prev2.every(function(ref, i) {
        return ref === next2[i];
      });
    });
  }
  function supportRef(nodeOrComponent) {
    var _type$prototype, _nodeOrComponent$prot;
    var type4 = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;
    if (typeof type4 === "function" && !((_type$prototype = type4.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render)) {
      return false;
    }
    if (typeof nodeOrComponent === "function" && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render)) {
      return false;
    }
    return true;
  }
  function isDOM(node2) {
    return node2 instanceof HTMLElement || node2 instanceof SVGElement;
  }
  function findDOMNode(node2) {
    if (isDOM(node2)) {
      return node2;
    }
    if (node2 instanceof React.Component) {
      return ReactDOM__default.findDOMNode(node2);
    }
    return null;
  }
  var MapShim = function() {
    if (typeof Map !== "undefined") {
      return Map;
    }
    function getIndex(arr, key) {
      var result = -1;
      arr.some(function(entry, index2) {
        if (entry[0] === key) {
          result = index2;
          return true;
        }
        return false;
      });
      return result;
    }
    return (
      /** @class */
      function() {
        function class_1() {
          this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
          /**
           * @returns {boolean}
           */
          get: function() {
            return this.__entries__.length;
          },
          enumerable: true,
          configurable: true
        });
        class_1.prototype.get = function(key) {
          var index2 = getIndex(this.__entries__, key);
          var entry = this.__entries__[index2];
          return entry && entry[1];
        };
        class_1.prototype.set = function(key, value) {
          var index2 = getIndex(this.__entries__, key);
          if (~index2) {
            this.__entries__[index2][1] = value;
          } else {
            this.__entries__.push([key, value]);
          }
        };
        class_1.prototype.delete = function(key) {
          var entries = this.__entries__;
          var index2 = getIndex(entries, key);
          if (~index2) {
            entries.splice(index2, 1);
          }
        };
        class_1.prototype.has = function(key) {
          return !!~getIndex(this.__entries__, key);
        };
        class_1.prototype.clear = function() {
          this.__entries__.splice(0);
        };
        class_1.prototype.forEach = function(callback, ctx) {
          if (ctx === void 0) {
            ctx = null;
          }
          for (var _i = 0, _a2 = this.__entries__; _i < _a2.length; _i++) {
            var entry = _a2[_i];
            callback.call(ctx, entry[1], entry[0]);
          }
        };
        return class_1;
      }()
    );
  }();
  var isBrowser = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
  var global$1 = function() {
    if (typeof global !== "undefined" && global.Math === Math) {
      return global;
    }
    if (typeof self !== "undefined" && self.Math === Math) {
      return self;
    }
    if (typeof window !== "undefined" && window.Math === Math) {
      return window;
    }
    return Function("return this")();
  }();
  var requestAnimationFrame$1 = function() {
    if (typeof requestAnimationFrame === "function") {
      return requestAnimationFrame.bind(global$1);
    }
    return function(callback) {
      return setTimeout(function() {
        return callback(Date.now());
      }, 1e3 / 60);
    };
  }();
  var trailingTimeout = 2;
  function throttle(callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    function resolvePending() {
      if (leadingCall) {
        leadingCall = false;
        callback();
      }
      if (trailingCall) {
        proxy();
      }
    }
    function timeoutCallback() {
      requestAnimationFrame$1(resolvePending);
    }
    function proxy() {
      var timeStamp = Date.now();
      if (leadingCall) {
        if (timeStamp - lastCallTime < trailingTimeout) {
          return;
        }
        trailingCall = true;
      } else {
        leadingCall = true;
        trailingCall = false;
        setTimeout(timeoutCallback, delay);
      }
      lastCallTime = timeStamp;
    }
    return proxy;
  }
  var REFRESH_DELAY = 20;
  var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
  var mutationObserverSupported = typeof MutationObserver !== "undefined";
  var ResizeObserverController = (
    /** @class */
    function() {
      function ResizeObserverController2() {
        this.connected_ = false;
        this.mutationEventsAdded_ = false;
        this.mutationsObserver_ = null;
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
      }
      ResizeObserverController2.prototype.addObserver = function(observer2) {
        if (!~this.observers_.indexOf(observer2)) {
          this.observers_.push(observer2);
        }
        if (!this.connected_) {
          this.connect_();
        }
      };
      ResizeObserverController2.prototype.removeObserver = function(observer2) {
        var observers2 = this.observers_;
        var index2 = observers2.indexOf(observer2);
        if (~index2) {
          observers2.splice(index2, 1);
        }
        if (!observers2.length && this.connected_) {
          this.disconnect_();
        }
      };
      ResizeObserverController2.prototype.refresh = function() {
        var changesDetected = this.updateObservers_();
        if (changesDetected) {
          this.refresh();
        }
      };
      ResizeObserverController2.prototype.updateObservers_ = function() {
        var activeObservers = this.observers_.filter(function(observer2) {
          return observer2.gatherActive(), observer2.hasActive();
        });
        activeObservers.forEach(function(observer2) {
          return observer2.broadcastActive();
        });
        return activeObservers.length > 0;
      };
      ResizeObserverController2.prototype.connect_ = function() {
        if (!isBrowser || this.connected_) {
          return;
        }
        document.addEventListener("transitionend", this.onTransitionEnd_);
        window.addEventListener("resize", this.refresh);
        if (mutationObserverSupported) {
          this.mutationsObserver_ = new MutationObserver(this.refresh);
          this.mutationsObserver_.observe(document, {
            attributes: true,
            childList: true,
            characterData: true,
            subtree: true
          });
        } else {
          document.addEventListener("DOMSubtreeModified", this.refresh);
          this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
      };
      ResizeObserverController2.prototype.disconnect_ = function() {
        if (!isBrowser || !this.connected_) {
          return;
        }
        document.removeEventListener("transitionend", this.onTransitionEnd_);
        window.removeEventListener("resize", this.refresh);
        if (this.mutationsObserver_) {
          this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
          document.removeEventListener("DOMSubtreeModified", this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
      };
      ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
        var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
        var isReflowProperty = transitionKeys.some(function(key) {
          return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
          this.refresh();
        }
      };
      ResizeObserverController2.getInstance = function() {
        if (!this.instance_) {
          this.instance_ = new ResizeObserverController2();
        }
        return this.instance_;
      };
      ResizeObserverController2.instance_ = null;
      return ResizeObserverController2;
    }()
  );
  var defineConfigurable = function(target, props) {
    for (var _i = 0, _a2 = Object.keys(props); _i < _a2.length; _i++) {
      var key = _a2[_i];
      Object.defineProperty(target, key, {
        value: props[key],
        enumerable: false,
        writable: false,
        configurable: true
      });
    }
    return target;
  };
  var getWindowOf = function(target) {
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    return ownerGlobal || global$1;
  };
  var emptyRect = createRectInit(0, 0, 0, 0);
  function toFloat(value) {
    return parseFloat(value) || 0;
  }
  function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function(size, position2) {
      var value = styles["border-" + position2 + "-width"];
      return size + toFloat(value);
    }, 0);
  }
  function getPaddings(styles) {
    var positions = ["top", "right", "bottom", "left"];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
      var position2 = positions_1[_i];
      var value = styles["padding-" + position2];
      paddings[position2] = toFloat(value);
    }
    return paddings;
  }
  function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
  }
  function getHTMLElementContentRect(target) {
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    if (!clientWidth && !clientHeight) {
      return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    var width = toFloat(styles.width), height = toFloat(styles.height);
    if (styles.boxSizing === "border-box") {
      if (Math.round(width + horizPad) !== clientWidth) {
        width -= getBordersSize(styles, "left", "right") + horizPad;
      }
      if (Math.round(height + vertPad) !== clientHeight) {
        height -= getBordersSize(styles, "top", "bottom") + vertPad;
      }
    }
    if (!isDocumentElement(target)) {
      var vertScrollbar = Math.round(width + horizPad) - clientWidth;
      var horizScrollbar = Math.round(height + vertPad) - clientHeight;
      if (Math.abs(vertScrollbar) !== 1) {
        width -= vertScrollbar;
      }
      if (Math.abs(horizScrollbar) !== 1) {
        height -= horizScrollbar;
      }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
  }
  var isSVGGraphicsElement = function() {
    if (typeof SVGGraphicsElement !== "undefined") {
      return function(target) {
        return target instanceof getWindowOf(target).SVGGraphicsElement;
      };
    }
    return function(target) {
      return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
    };
  }();
  function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
  }
  function getContentRect(target) {
    if (!isBrowser) {
      return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
      return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
  }
  function createReadOnlyRect(_a2) {
    var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
    var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    defineConfigurable(rect, {
      x: x2,
      y: y2,
      width,
      height,
      top: y2,
      right: x2 + width,
      bottom: height + y2,
      left: x2
    });
    return rect;
  }
  function createRectInit(x2, y2, width, height) {
    return { x: x2, y: y2, width, height };
  }
  var ResizeObservation = (
    /** @class */
    function() {
      function ResizeObservation2(target) {
        this.broadcastWidth = 0;
        this.broadcastHeight = 0;
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
      }
      ResizeObservation2.prototype.isActive = function() {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
      };
      ResizeObservation2.prototype.broadcastRect = function() {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
      };
      return ResizeObservation2;
    }()
  );
  var ResizeObserverEntry = (
    /** @class */
    function() {
      function ResizeObserverEntry2(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        defineConfigurable(this, { target, contentRect });
      }
      return ResizeObserverEntry2;
    }()
  );
  var ResizeObserverSPI = (
    /** @class */
    function() {
      function ResizeObserverSPI2(callback, controller, callbackCtx) {
        this.activeObservations_ = [];
        this.observations_ = new MapShim();
        if (typeof callback !== "function") {
          throw new TypeError("The callback provided as parameter 1 is not a function.");
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
      }
      ResizeObserverSPI2.prototype.observe = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (observations.has(target)) {
          return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        this.controller_.refresh();
      };
      ResizeObserverSPI2.prototype.unobserve = function(target) {
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        if (typeof Element === "undefined" || !(Element instanceof Object)) {
          return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
          throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        if (!observations.has(target)) {
          return;
        }
        observations.delete(target);
        if (!observations.size) {
          this.controller_.removeObserver(this);
        }
      };
      ResizeObserverSPI2.prototype.disconnect = function() {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
      };
      ResizeObserverSPI2.prototype.gatherActive = function() {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function(observation) {
          if (observation.isActive()) {
            _this.activeObservations_.push(observation);
          }
        });
      };
      ResizeObserverSPI2.prototype.broadcastActive = function() {
        if (!this.hasActive()) {
          return;
        }
        var ctx = this.callbackCtx_;
        var entries = this.activeObservations_.map(function(observation) {
          return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
      };
      ResizeObserverSPI2.prototype.clearActive = function() {
        this.activeObservations_.splice(0);
      };
      ResizeObserverSPI2.prototype.hasActive = function() {
        return this.activeObservations_.length > 0;
      };
      return ResizeObserverSPI2;
    }()
  );
  var observers = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
  var ResizeObserver$2 = (
    /** @class */
    function() {
      function ResizeObserver2(callback) {
        if (!(this instanceof ResizeObserver2)) {
          throw new TypeError("Cannot call a class as a function.");
        }
        if (!arguments.length) {
          throw new TypeError("1 argument required, but only 0 present.");
        }
        var controller = ResizeObserverController.getInstance();
        var observer2 = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer2);
      }
      return ResizeObserver2;
    }()
  );
  [
    "observe",
    "unobserve",
    "disconnect"
  ].forEach(function(method4) {
    ResizeObserver$2.prototype[method4] = function() {
      var _a2;
      return (_a2 = observers.get(this))[method4].apply(_a2, arguments);
    };
  });
  var index = function() {
    if (typeof global$1.ResizeObserver !== "undefined") {
      return global$1.ResizeObserver;
    }
    return ResizeObserver$2;
  }();
  var elementListeners = /* @__PURE__ */ new Map();
  function onResize(entities) {
    entities.forEach(function(entity) {
      var _elementListeners$get;
      var target = entity.target;
      (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function(listener) {
        return listener(target);
      });
    });
  }
  var resizeObserver$1 = new index(onResize);
  function observe(element, callback) {
    if (!elementListeners.has(element)) {
      elementListeners.set(element, /* @__PURE__ */ new Set());
      resizeObserver$1.observe(element);
    }
    elementListeners.get(element).add(callback);
  }
  function unobserve(element, callback) {
    if (elementListeners.has(element)) {
      elementListeners.get(element).delete(callback);
      if (!elementListeners.get(element).size) {
        resizeObserver$1.unobserve(element);
        elementListeners.delete(element);
      }
    }
  }
  var DomWrapper$1 = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper2, _React$Component);
    var _super = _createSuper(DomWrapper2);
    function DomWrapper2() {
      _classCallCheck(this, DomWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass$1(DomWrapper2, [{
      key: "render",
      value: function render2() {
        return this.props.children;
      }
    }]);
    return DomWrapper2;
  }(React__namespace.Component);
  var CollectionContext = /* @__PURE__ */ React__namespace.createContext(null);
  function Collection(_ref) {
    var children = _ref.children, onBatchResize = _ref.onBatchResize;
    var resizeIdRef = React__namespace.useRef(0);
    var resizeInfosRef = React__namespace.useRef([]);
    var onCollectionResize = React__namespace.useContext(CollectionContext);
    var onResize2 = React__namespace.useCallback(function(size, element, data) {
      resizeIdRef.current += 1;
      var currentId = resizeIdRef.current;
      resizeInfosRef.current.push({
        size,
        element,
        data
      });
      Promise.resolve().then(function() {
        if (currentId === resizeIdRef.current) {
          onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
          resizeInfosRef.current = [];
        }
      });
      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
    }, [onBatchResize, onCollectionResize]);
    return /* @__PURE__ */ React__namespace.createElement(CollectionContext.Provider, {
      value: onResize2
    }, children);
  }
  function SingleObserver(props, ref) {
    var children = props.children, disabled = props.disabled;
    var elementRef = React__namespace.useRef(null);
    var wrapperRef = React__namespace.useRef(null);
    var onCollectionResize = React__namespace.useContext(CollectionContext);
    var isRenderProps = typeof children === "function";
    var mergedChildren = isRenderProps ? children(elementRef) : children;
    var sizeRef = React__namespace.useRef({
      width: -1,
      height: -1,
      offsetWidth: -1,
      offsetHeight: -1
    });
    var canRef = !isRenderProps && /* @__PURE__ */ React__namespace.isValidElement(mergedChildren) && supportRef(mergedChildren);
    var originRef = canRef ? mergedChildren.ref : null;
    var mergedRef = React__namespace.useMemo(function() {
      return composeRef(originRef, elementRef);
    }, [originRef, elementRef]);
    var getDom = function getDom2() {
      return findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);
    };
    React__namespace.useImperativeHandle(ref, function() {
      return getDom();
    });
    var propsRef = React__namespace.useRef(props);
    propsRef.current = props;
    var onInternalResize = React__namespace.useCallback(function(target) {
      var _propsRef$current = propsRef.current, onResize2 = _propsRef$current.onResize, data = _propsRef$current.data;
      var _target$getBoundingCl = target.getBoundingClientRect(), width = _target$getBoundingCl.width, height = _target$getBoundingCl.height;
      var offsetWidth = target.offsetWidth, offsetHeight = target.offsetHeight;
      var fixedWidth = Math.floor(width);
      var fixedHeight = Math.floor(height);
      if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
        var size = {
          width: fixedWidth,
          height: fixedHeight,
          offsetWidth,
          offsetHeight
        };
        sizeRef.current = size;
        var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
        var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
        var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
          offsetWidth: mergedOffsetWidth,
          offsetHeight: mergedOffsetHeight
        });
        onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);
        if (onResize2) {
          Promise.resolve().then(function() {
            onResize2(sizeInfo, target);
          });
        }
      }
    }, []);
    React__namespace.useEffect(function() {
      var currentElement = getDom();
      if (currentElement && !disabled) {
        observe(currentElement, onInternalResize);
      }
      return function() {
        return unobserve(currentElement, onInternalResize);
      };
    }, [elementRef.current, disabled]);
    return /* @__PURE__ */ React__namespace.createElement(DomWrapper$1, {
      ref: wrapperRef
    }, canRef ? /* @__PURE__ */ React__namespace.cloneElement(mergedChildren, {
      ref: mergedRef
    }) : mergedChildren);
  }
  var RefSingleObserver = /* @__PURE__ */ React__namespace.forwardRef(SingleObserver);
  var INTERNAL_PREFIX_KEY = "rc-observer-key";
  function ResizeObserver$1(props, ref) {
    var children = props.children;
    var childNodes = typeof children === "function" ? [children] : toArray$3(children);
    return childNodes.map(function(child, index2) {
      var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index2);
      return /* @__PURE__ */ React__namespace.createElement(RefSingleObserver, _extends$2({}, props, {
        key,
        ref: index2 === 0 ? ref : void 0
      }), child);
    });
  }
  var RefResizeObserver = /* @__PURE__ */ React__namespace.forwardRef(ResizeObserver$1);
  RefResizeObserver.Collection = Collection;
  function omit(obj, fields) {
    var clone = _objectSpread2({}, obj);
    if (Array.isArray(fields)) {
      fields.forEach(function(key) {
        delete clone[key];
      });
    }
    return clone;
  }
  function _arrayLikeToArray$1(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr))
      return _arrayLikeToArray$1(arr);
  }
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
      return Array.from(iter);
  }
  function _unsupportedIterableToArray$1(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray$1(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray$1(o, minLen);
  }
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread();
  }
  var raf = function raf2(callback) {
    return +setTimeout(callback, 16);
  };
  var caf = function caf2(num) {
    return clearTimeout(num);
  };
  if (typeof window !== "undefined" && "requestAnimationFrame" in window) {
    raf = function raf3(callback) {
      return window.requestAnimationFrame(callback);
    };
    caf = function caf3(handle) {
      return window.cancelAnimationFrame(handle);
    };
  }
  var rafUUID = 0;
  var rafIds = /* @__PURE__ */ new Map();
  function cleanup(id2) {
    rafIds.delete(id2);
  }
  var wrapperRaf = function wrapperRaf2(callback) {
    var times = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    rafUUID += 1;
    var id2 = rafUUID;
    function callRef(leftTimes) {
      if (leftTimes === 0) {
        cleanup(id2);
        callback();
      } else {
        var realId = raf(function() {
          callRef(leftTimes - 1);
        });
        rafIds.set(id2, realId);
      }
    }
    callRef(times);
    return id2;
  };
  wrapperRaf.cancel = function(id2) {
    var realId = rafIds.get(id2);
    cleanup(realId);
    return caf(realId);
  };
  function throttleByAnimationFrame(fn) {
    let requestId;
    const later = (args) => () => {
      requestId = null;
      fn.apply(void 0, _toConsumableArray(args));
    };
    const throttled = function() {
      if (requestId == null) {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        requestId = wrapperRaf(later(args));
      }
    };
    throttled.cancel = () => {
      wrapperRaf.cancel(requestId);
      requestId = null;
    };
    return throttled;
  }
  function murmur2(str) {
    var h2 = 0;
    var k2, i = 0, len = str.length;
    for (; len >= 4; ++i, len -= 4) {
      k2 = str.charCodeAt(i) & 255 | (str.charCodeAt(++i) & 255) << 8 | (str.charCodeAt(++i) & 255) << 16 | (str.charCodeAt(++i) & 255) << 24;
      k2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16);
      k2 ^= /* k >>> r: */
      k2 >>> 24;
      h2 = /* Math.imul(k, m): */
      (k2 & 65535) * 1540483477 + ((k2 >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
      (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    switch (len) {
      case 3:
        h2 ^= (str.charCodeAt(i + 2) & 255) << 16;
      case 2:
        h2 ^= (str.charCodeAt(i + 1) & 255) << 8;
      case 1:
        h2 ^= str.charCodeAt(i) & 255;
        h2 = /* Math.imul(h, m): */
        (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    }
    h2 ^= h2 >>> 13;
    h2 = /* Math.imul(h, m): */
    (h2 & 65535) * 1540483477 + ((h2 >>> 16) * 59797 << 16);
    return ((h2 ^ h2 >>> 15) >>> 0).toString(36);
  }
  function _objectWithoutPropertiesLoose(source, excluded) {
    if (source == null)
      return {};
    var target = {};
    var sourceKeys = Object.keys(source);
    var key, i;
    for (i = 0; i < sourceKeys.length; i++) {
      key = sourceKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      target[key] = source[key];
    }
    return target;
  }
  function _objectWithoutProperties(source, excluded) {
    if (source == null)
      return {};
    var target = _objectWithoutPropertiesLoose(source, excluded);
    var key, i;
    if (Object.getOwnPropertySymbols) {
      var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
      for (i = 0; i < sourceSymbolKeys.length; i++) {
        key = sourceSymbolKeys[i];
        if (excluded.indexOf(key) >= 0)
          continue;
        if (!Object.prototype.propertyIsEnumerable.call(source, key))
          continue;
        target[key] = source[key];
      }
    }
    return target;
  }
  function isEqual$1(obj1, obj2) {
    var shallow = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var refSet = /* @__PURE__ */ new Set();
    function deepEqual2(a, b2) {
      var level = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      var circular = refSet.has(a);
      warningOnce(!circular, "Warning: There may be circular references");
      if (circular) {
        return false;
      }
      if (a === b2) {
        return true;
      }
      if (shallow && level > 1) {
        return false;
      }
      refSet.add(a);
      var newLevel = level + 1;
      if (Array.isArray(a)) {
        if (!Array.isArray(b2) || a.length !== b2.length) {
          return false;
        }
        for (var i = 0; i < a.length; i++) {
          if (!deepEqual2(a[i], b2[i], newLevel)) {
            return false;
          }
        }
        return true;
      }
      if (a && b2 && _typeof(a) === "object" && _typeof(b2) === "object") {
        var keys2 = Object.keys(a);
        if (keys2.length !== Object.keys(b2).length) {
          return false;
        }
        return keys2.every(function(key) {
          return deepEqual2(a[key], b2[key], newLevel);
        });
      }
      return false;
    }
    return deepEqual2(obj1, obj2);
  }
  var Entity = /* @__PURE__ */ function() {
    function Entity2(instanceId) {
      _classCallCheck(this, Entity2);
      _defineProperty(this, "instanceId", void 0);
      _defineProperty(this, "cache", /* @__PURE__ */ new Map());
      this.instanceId = instanceId;
    }
    _createClass$1(Entity2, [{
      key: "get",
      value: function get4(keys2) {
        return this.cache.get(keys2.join("%")) || null;
      }
    }, {
      key: "update",
      value: function update(keys2, valueFn) {
        var path2 = keys2.join("%");
        var prevValue = this.cache.get(path2);
        var nextValue = valueFn(prevValue);
        if (nextValue === null) {
          this.cache.delete(path2);
        } else {
          this.cache.set(path2, nextValue);
        }
      }
    }]);
    return Entity2;
  }();
  var ATTR_TOKEN = "data-token-hash";
  var ATTR_MARK = "data-css-hash";
  var CSS_IN_JS_INSTANCE = "__cssinjs_instance__";
  function createCache() {
    var cssinjsInstanceId = Math.random().toString(12).slice(2);
    if (typeof document !== "undefined" && document.head && document.body) {
      var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
      var firstChild = document.head.firstChild;
      Array.from(styles).forEach(function(style2) {
        style2[CSS_IN_JS_INSTANCE] = style2[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;
        if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
          document.head.insertBefore(style2, firstChild);
        }
      });
      var styleHash = {};
      Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function(style2) {
        var hash = style2.getAttribute(ATTR_MARK);
        if (styleHash[hash]) {
          if (style2[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            var _style$parentNode;
            (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
          }
        } else {
          styleHash[hash] = true;
        }
      });
    }
    return new Entity(cssinjsInstanceId);
  }
  var StyleContext = /* @__PURE__ */ React__namespace.createContext({
    hashPriority: "low",
    cache: createCache(),
    defaultCache: true
  });
  const StyleContext$1 = StyleContext;
  function canUseDom() {
    return !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
  function contains(root, n2) {
    if (!root) {
      return false;
    }
    if (root.contains) {
      return root.contains(n2);
    }
    var node2 = n2;
    while (node2) {
      if (node2 === root) {
        return true;
      }
      node2 = node2.parentNode;
    }
    return false;
  }
  var APPEND_ORDER = "data-rc-order";
  var MARK_KEY = "rc-util-key";
  var containerCache = /* @__PURE__ */ new Map();
  function getMark() {
    var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, mark = _ref.mark;
    if (mark) {
      return mark.startsWith("data-") ? mark : "data-".concat(mark);
    }
    return MARK_KEY;
  }
  function getContainer(option) {
    if (option.attachTo) {
      return option.attachTo;
    }
    var head = document.querySelector("head");
    return head || document.body;
  }
  function getOrder(prepend) {
    if (prepend === "queue") {
      return "prependQueue";
    }
    return prepend ? "prepend" : "append";
  }
  function findStyles(container) {
    return Array.from((containerCache.get(container) || container).children).filter(function(node2) {
      return node2.tagName === "STYLE";
    });
  }
  function injectCSS(css) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!canUseDom()) {
      return null;
    }
    var csp = option.csp, prepend = option.prepend;
    var styleNode = document.createElement("style");
    styleNode.setAttribute(APPEND_ORDER, getOrder(prepend));
    if (csp !== null && csp !== void 0 && csp.nonce) {
      styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
    }
    styleNode.innerHTML = css;
    var container = getContainer(option);
    var firstChild = container.firstChild;
    if (prepend) {
      if (prepend === "queue") {
        var existStyle = findStyles(container).filter(function(node2) {
          return ["prepend", "prependQueue"].includes(node2.getAttribute(APPEND_ORDER));
        });
        if (existStyle.length) {
          container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
          return styleNode;
        }
      }
      container.insertBefore(styleNode, firstChild);
    } else {
      container.appendChild(styleNode);
    }
    return styleNode;
  }
  function findExistNode(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var container = getContainer(option);
    return findStyles(container).find(function(node2) {
      return node2.getAttribute(getMark(option)) === key;
    });
  }
  function removeCSS(key) {
    var option = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var existNode = findExistNode(key, option);
    if (existNode) {
      var container = getContainer(option);
      container.removeChild(existNode);
    }
  }
  function syncRealContainer(container, option) {
    var cachedRealContainer = containerCache.get(container);
    if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
      var placeholderStyle = injectCSS("", option);
      var parentNode = placeholderStyle.parentNode;
      containerCache.set(container, parentNode);
      container.removeChild(placeholderStyle);
    }
  }
  function updateCSS(css, key) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var container = getContainer(option);
    syncRealContainer(container, option);
    var existNode = findExistNode(key, option);
    if (existNode) {
      var _option$csp, _option$csp2;
      if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
        var _option$csp3;
        existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
      }
      if (existNode.innerHTML !== css) {
        existNode.innerHTML = css;
      }
      return existNode;
    }
    var newNode = injectCSS(css, option);
    newNode.setAttribute(getMark(option), key);
    return newNode;
  }
  function flattenToken(token2) {
    var str = "";
    Object.keys(token2).forEach(function(key) {
      var value = token2[key];
      str += key;
      if (value && _typeof(value) === "object") {
        str += flattenToken(value);
      } else {
        str += value;
      }
    });
    return str;
  }
  function token2key(token2, salt) {
    return murmur2("".concat(salt, "_").concat(flattenToken(token2)));
  }
  var layerKey = "layer-".concat(Date.now(), "-").concat(Math.random()).replace(/\./g, "");
  var layerWidth = "903px";
  function supportSelector(styleStr, handleElement) {
    if (canUseDom()) {
      var _ele$parentNode;
      updateCSS(styleStr, layerKey);
      var _ele = document.createElement("div");
      _ele.style.position = "fixed";
      _ele.style.left = "0";
      _ele.style.top = "0";
      handleElement === null || handleElement === void 0 ? void 0 : handleElement(_ele);
      document.body.appendChild(_ele);
      var support = getComputedStyle(_ele).width === layerWidth;
      (_ele$parentNode = _ele.parentNode) === null || _ele$parentNode === void 0 ? void 0 : _ele$parentNode.removeChild(_ele);
      removeCSS(layerKey);
      return support;
    }
    return false;
  }
  var canLayer = void 0;
  function supportLayer() {
    if (canLayer === void 0) {
      canLayer = supportSelector("@layer ".concat(layerKey, " { .").concat(layerKey, " { width: ").concat(layerWidth, "!important; } }"), function(ele) {
        ele.className = layerKey;
      });
    }
    return canLayer;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _iterableToArrayLimit(arr, i) {
    var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
    if (null != _i) {
      var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
      try {
        if (_x = (_i = _i.call(arr)).next, 0 === i) {
          if (Object(_i) !== _i)
            return;
          _n = false;
        } else
          for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
            ;
      } catch (err) {
        _d = true, _e = err;
      } finally {
        try {
          if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
            return;
        } finally {
          if (_d)
            throw _e;
        }
      }
      return _arr;
    }
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray$1(arr, i) || _nonIterableRest();
  }
  function useClientCache(prefix, keyPath, cacheFn, onCacheRemove) {
    var _React$useContext = React__namespace.useContext(StyleContext$1), globalCache = _React$useContext.cache;
    var fullPath = [prefix].concat(_toConsumableArray(keyPath));
    React__namespace.useMemo(
      function() {
        globalCache.update(fullPath, function(prevCache) {
          var _ref = prevCache || [], _ref2 = _slicedToArray(_ref, 2), _ref2$ = _ref2[0], times = _ref2$ === void 0 ? 0 : _ref2$, cache = _ref2[1];
          var tmpCache = cache;
          var mergedCache = tmpCache || cacheFn();
          return [times + 1, mergedCache];
        });
      },
      /* eslint-disable react-hooks/exhaustive-deps */
      [fullPath.join("_")]
      /* eslint-enable */
    );
    React__namespace.useEffect(function() {
      return function() {
        globalCache.update(fullPath, function(prevCache) {
          var _ref3 = prevCache || [], _ref4 = _slicedToArray(_ref3, 2), _ref4$ = _ref4[0], times = _ref4$ === void 0 ? 0 : _ref4$, cache = _ref4[1];
          var nextCount = times - 1;
          if (nextCount === 0) {
            onCacheRemove === null || onCacheRemove === void 0 ? void 0 : onCacheRemove(cache, false);
            return null;
          }
          return [times - 1, cache];
        });
      };
    }, fullPath);
    return globalCache.get(fullPath)[1];
  }
  var EMPTY_OVERRIDE = {};
  var hashPrefix = "css";
  var tokenKeys = /* @__PURE__ */ new Map();
  function recordCleanToken(tokenKey) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
  }
  function removeStyleTags(key, instanceId) {
    if (typeof document !== "undefined") {
      var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, '="').concat(key, '"]'));
      styles.forEach(function(style2) {
        if (style2[CSS_IN_JS_INSTANCE] === instanceId) {
          var _style$parentNode;
          (_style$parentNode = style2.parentNode) === null || _style$parentNode === void 0 ? void 0 : _style$parentNode.removeChild(style2);
        }
      });
    }
  }
  function cleanTokenStyle(tokenKey, instanceId) {
    tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
    var tokenKeyList = Array.from(tokenKeys.keys());
    var cleanableKeyList = tokenKeyList.filter(function(key) {
      var count = tokenKeys.get(key) || 0;
      return count <= 0;
    });
    if (cleanableKeyList.length < tokenKeyList.length) {
      cleanableKeyList.forEach(function(key) {
        removeStyleTags(key, instanceId);
        tokenKeys.delete(key);
      });
    }
  }
  var getComputedToken = function getComputedToken2(originToken, overrideToken, theme2, format2) {
    var derivativeToken = theme2.getDerivativeToken(originToken);
    var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);
    if (format2) {
      mergedDerivativeToken = format2(mergedDerivativeToken);
    }
    return mergedDerivativeToken;
  };
  function useCacheToken(theme2, tokens) {
    var option = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var _useContext = React.useContext(StyleContext$1), instanceId = _useContext.cache.instanceId;
    var _option$salt = option.salt, salt = _option$salt === void 0 ? "" : _option$salt, _option$override = option.override, override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override, formatToken2 = option.formatToken;
    var mergedToken = React__namespace.useMemo(function() {
      return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
    }, [tokens]);
    var tokenStr = React__namespace.useMemo(function() {
      return flattenToken(mergedToken);
    }, [mergedToken]);
    var overrideTokenStr = React__namespace.useMemo(function() {
      return flattenToken(override);
    }, [override]);
    var cachedToken = useClientCache("token", [salt, theme2.id, tokenStr, overrideTokenStr], function() {
      var mergedDerivativeToken = getComputedToken(mergedToken, override, theme2, formatToken2);
      var tokenKey = token2key(mergedDerivativeToken, salt);
      mergedDerivativeToken._tokenKey = tokenKey;
      recordCleanToken(tokenKey);
      var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
      mergedDerivativeToken._hashId = hashId;
      return [mergedDerivativeToken, hashId];
    }, function(cache) {
      cleanTokenStyle(cache[0]._tokenKey, instanceId);
    });
    return cachedToken;
  }
  var unitlessKeys = {
    animationIterationCount: 1,
    borderImageOutset: 1,
    borderImageSlice: 1,
    borderImageWidth: 1,
    boxFlex: 1,
    boxFlexGroup: 1,
    boxOrdinalGroup: 1,
    columnCount: 1,
    columns: 1,
    flex: 1,
    flexGrow: 1,
    flexPositive: 1,
    flexShrink: 1,
    flexNegative: 1,
    flexOrder: 1,
    gridRow: 1,
    gridRowEnd: 1,
    gridRowSpan: 1,
    gridRowStart: 1,
    gridColumn: 1,
    gridColumnEnd: 1,
    gridColumnSpan: 1,
    gridColumnStart: 1,
    msGridRow: 1,
    msGridRowSpan: 1,
    msGridColumn: 1,
    msGridColumnSpan: 1,
    fontWeight: 1,
    lineHeight: 1,
    opacity: 1,
    order: 1,
    orphans: 1,
    tabSize: 1,
    widows: 1,
    zIndex: 1,
    zoom: 1,
    WebkitLineClamp: 1,
    // SVG-related properties
    fillOpacity: 1,
    floodOpacity: 1,
    stopOpacity: 1,
    strokeDasharray: 1,
    strokeDashoffset: 1,
    strokeMiterlimit: 1,
    strokeOpacity: 1,
    strokeWidth: 1
  };
  var COMMENT = "comm";
  var RULESET = "rule";
  var DECLARATION = "decl";
  var IMPORT = "@import";
  var KEYFRAMES = "@keyframes";
  var LAYER = "@layer";
  var abs = Math.abs;
  var from = String.fromCharCode;
  function trim$1(value) {
    return value.trim();
  }
  function replace(value, pattern4, replacement) {
    return value.replace(pattern4, replacement);
  }
  function indexof(value, search) {
    return value.indexOf(search);
  }
  function charat(value, index2) {
    return value.charCodeAt(index2) | 0;
  }
  function substr(value, begin, end) {
    return value.slice(begin, end);
  }
  function strlen(value) {
    return value.length;
  }
  function sizeof(value) {
    return value.length;
  }
  function append(value, array5) {
    return array5.push(value), value;
  }
  var line = 1;
  var column = 1;
  var length = 0;
  var position = 0;
  var character = 0;
  var characters = "";
  function node(value, root, parent, type4, props, children, length2, siblings) {
    return { value, root, parent, type: type4, props, children, line, column, length: length2, return: "", siblings };
  }
  function char() {
    return character;
  }
  function prev() {
    character = position > 0 ? charat(characters, --position) : 0;
    if (column--, character === 10)
      column = 1, line--;
    return character;
  }
  function next() {
    character = position < length ? charat(characters, position++) : 0;
    if (column++, character === 10)
      column = 1, line++;
    return character;
  }
  function peek() {
    return charat(characters, position);
  }
  function caret() {
    return position;
  }
  function slice(begin, end) {
    return substr(characters, begin, end);
  }
  function token(type4) {
    switch (type4) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  function alloc(value) {
    return line = column = 1, length = strlen(characters = value), position = 0, [];
  }
  function dealloc(value) {
    return characters = "", value;
  }
  function delimit(type4) {
    return trim$1(slice(position - 1, delimiter(type4 === 91 ? type4 + 2 : type4 === 40 ? type4 + 1 : type4)));
  }
  function whitespace$1(type4) {
    while (character = peek())
      if (character < 33)
        next();
      else
        break;
    return token(type4) > 2 || token(character) > 3 ? "" : " ";
  }
  function escaping(index2, count) {
    while (--count && next())
      if (character < 48 || character > 102 || character > 57 && character < 65 || character > 70 && character < 97)
        break;
    return slice(index2, caret() + (count < 6 && peek() == 32 && next() == 32));
  }
  function delimiter(type4) {
    while (next())
      switch (character) {
        case type4:
          return position;
        case 34:
        case 39:
          if (type4 !== 34 && type4 !== 39)
            delimiter(character);
          break;
        case 40:
          if (type4 === 41)
            delimiter(type4);
          break;
        case 92:
          next();
          break;
      }
    return position;
  }
  function commenter(type4, index2) {
    while (next())
      if (type4 + character === 47 + 10)
        break;
      else if (type4 + character === 42 + 42 && peek() === 47)
        break;
    return "/*" + slice(index2, position - 1) + "*" + from(type4 === 47 ? type4 : next());
  }
  function identifier(index2) {
    while (!token(peek()))
      next();
    return slice(index2, position);
  }
  function compile(value) {
    return dealloc(parse("", null, null, null, [""], value = alloc(value), 0, [0], value));
  }
  function parse(value, root, parent, rule, rules2, rulesets, pseudo, points, declarations) {
    var index2 = 0;
    var offset2 = 0;
    var length2 = pseudo;
    var atrule = 0;
    var property = 0;
    var previous = 0;
    var variable = 1;
    var scanning = 1;
    var ampersand = 1;
    var character2 = 0;
    var type4 = "";
    var props = rules2;
    var children = rulesets;
    var reference = rule;
    var characters2 = type4;
    while (scanning)
      switch (previous = character2, character2 = next()) {
        case 40:
          if (previous != 108 && charat(characters2, length2 - 1) == 58) {
            if (indexof(characters2 += replace(delimit(character2), "&", "&\f"), "&\f") != -1)
              ampersand = -1;
            break;
          }
        case 34:
        case 39:
        case 91:
          characters2 += delimit(character2);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          characters2 += whitespace$1(previous);
          break;
        case 92:
          characters2 += escaping(caret() - 1, 7);
          continue;
        case 47:
          switch (peek()) {
            case 42:
            case 47:
              append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
              break;
            default:
              characters2 += "/";
          }
          break;
        case 123 * variable:
          points[index2++] = strlen(characters2) * ampersand;
        case 125 * variable:
        case 59:
        case 0:
          switch (character2) {
            case 0:
            case 125:
              scanning = 0;
            case 59 + offset2:
              if (ampersand == -1)
                characters2 = replace(characters2, /\f/g, "");
              if (property > 0 && strlen(characters2) - length2)
                append(property > 32 ? declaration(characters2 + ";", rule, parent, length2 - 1, declarations) : declaration(replace(characters2, " ", "") + ";", rule, parent, length2 - 2, declarations), declarations);
              break;
            case 59:
              characters2 += ";";
            default:
              append(reference = ruleset(characters2, root, parent, index2, offset2, rules2, points, type4, props = [], children = [], length2, rulesets), rulesets);
              if (character2 === 123)
                if (offset2 === 0)
                  parse(characters2, root, reference, reference, props, rulesets, length2, points, children);
                else
                  switch (atrule === 99 && charat(characters2, 3) === 110 ? 100 : atrule) {
                    case 100:
                    case 108:
                    case 109:
                    case 115:
                      parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules2, points, type4, rules2, props = [], length2, children), children), rules2, children, length2, points, rule ? props : children);
                      break;
                    default:
                      parse(characters2, reference, reference, reference, [""], children, 0, points, children);
                  }
          }
          index2 = offset2 = property = 0, variable = ampersand = 1, type4 = characters2 = "", length2 = pseudo;
          break;
        case 58:
          length2 = 1 + strlen(characters2), property = previous;
        default:
          if (variable < 1) {
            if (character2 == 123)
              --variable;
            else if (character2 == 125 && variable++ == 0 && prev() == 125)
              continue;
          }
          switch (characters2 += from(character2), character2 * variable) {
            case 38:
              ampersand = offset2 > 0 ? 1 : (characters2 += "\f", -1);
              break;
            case 44:
              points[index2++] = (strlen(characters2) - 1) * ampersand, ampersand = 1;
              break;
            case 64:
              if (peek() === 45)
                characters2 += delimit(next());
              atrule = peek(), offset2 = length2 = strlen(type4 = characters2 += identifier(caret())), character2++;
              break;
            case 45:
              if (previous === 45 && strlen(characters2) == 2)
                variable = 0;
          }
      }
    return rulesets;
  }
  function ruleset(value, root, parent, index2, offset2, rules2, points, type4, props, children, length2, siblings) {
    var post = offset2 - 1;
    var rule = offset2 === 0 ? rules2 : [""];
    var size = sizeof(rule);
    for (var i = 0, j = 0, k2 = 0; i < index2; ++i)
      for (var x2 = 0, y2 = substr(value, post + 1, post = abs(j = points[i])), z2 = value; x2 < size; ++x2)
        if (z2 = trim$1(j > 0 ? rule[x2] + " " + y2 : replace(y2, /&\f/g, rule[x2])))
          props[k2++] = z2;
    return node(value, root, parent, offset2 === 0 ? RULESET : type4, props, children, length2, siblings);
  }
  function comment(value, root, parent, siblings) {
    return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings);
  }
  function declaration(value, root, parent, length2, siblings) {
    return node(value, root, parent, DECLARATION, substr(value, 0, length2), substr(value, length2 + 1, -1), length2, siblings);
  }
  function serialize(children, callback) {
    var output = "";
    for (var i = 0; i < children.length; i++)
      output += callback(children[i], i, children, callback) || "";
    return output;
  }
  function stringify$1(element, index2, children, callback) {
    switch (element.type) {
      case LAYER:
        if (element.children.length)
          break;
      case IMPORT:
      case DECLARATION:
        return element.return = element.return || element.value;
      case COMMENT:
        return "";
      case KEYFRAMES:
        return element.return = element.value + "{" + serialize(element.children, callback) + "}";
      case RULESET:
        if (!strlen(element.value = element.props.join(",")))
          return "";
    }
    return strlen(children = serialize(element.children, callback)) ? element.return = element.value + "{" + children + "}" : "";
  }
  var isClientSide = canUseDom();
  var SKIP_CHECK = "_skip_check_";
  var MULTI_VALUE = "_multi_value_";
  function normalizeStyle(styleStr) {
    var serialized = serialize(compile(styleStr), stringify$1);
    return serialized.replace(/\{%%%\:[^;];}/g, ";");
  }
  function isCompoundCSSProperty(value) {
    return _typeof(value) === "object" && value && (SKIP_CHECK in value || MULTI_VALUE in value);
  }
  function injectSelectorHash(key, hashId, hashPriority) {
    if (!hashId) {
      return key;
    }
    var hashClassName = ".".concat(hashId);
    var hashSelector = hashPriority === "low" ? ":where(".concat(hashClassName, ")") : hashClassName;
    var keys2 = key.split(",").map(function(k2) {
      var _firstPath$match;
      var fullPath = k2.trim().split(/\s+/);
      var firstPath = fullPath[0] || "";
      var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || "";
      firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
      return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(" ");
    });
    return keys2.join(",");
  }
  var parseStyle = function parseStyle2(interpolation) {
    var config = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      root: true,
      parentSelectors: []
    }, root = _ref.root, injectHash = _ref.injectHash, parentSelectors = _ref.parentSelectors;
    var hashId = config.hashId, layer = config.layer;
    config.path;
    var hashPriority = config.hashPriority, _config$transformers = config.transformers, transformers = _config$transformers === void 0 ? [] : _config$transformers;
    config.linters;
    var styleStr = "";
    var effectStyle = {};
    function parseKeyframes(keyframes) {
      var animationName = keyframes.getName(hashId);
      if (!effectStyle[animationName]) {
        var _parseStyle = parseStyle2(keyframes.style, config, {
          root: false,
          parentSelectors
        }), _parseStyle2 = _slicedToArray(_parseStyle, 1), _parsedStr = _parseStyle2[0];
        effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
      }
    }
    function flattenList(list) {
      var fullList = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      list.forEach(function(item) {
        if (Array.isArray(item)) {
          flattenList(item, fullList);
        } else if (item) {
          fullList.push(item);
        }
      });
      return fullList;
    }
    var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
    flattenStyleList.forEach(function(originStyle) {
      var style2 = typeof originStyle === "string" && !root ? {} : originStyle;
      if (typeof style2 === "string") {
        styleStr += "".concat(style2, "\n");
      } else if (style2._keyframe) {
        parseKeyframes(style2);
      } else {
        var mergedStyle = transformers.reduce(function(prev2, trans) {
          var _trans$visit;
          return (trans === null || trans === void 0 ? void 0 : (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev2)) || prev2;
        }, style2);
        Object.keys(mergedStyle).forEach(function(key) {
          var value = mergedStyle[key];
          if (_typeof(value) === "object" && value && (key !== "animationName" || !value._keyframe) && !isCompoundCSSProperty(value)) {
            var subInjectHash = false;
            var mergedKey = key.trim();
            var nextRoot = false;
            if ((root || injectHash) && hashId) {
              if (mergedKey.startsWith("@")) {
                subInjectHash = true;
              } else {
                mergedKey = injectSelectorHash(key, hashId, hashPriority);
              }
            } else if (root && !hashId && (mergedKey === "&" || mergedKey === "")) {
              mergedKey = "";
              nextRoot = true;
            }
            var _parseStyle3 = parseStyle2(value, config, {
              root: nextRoot,
              injectHash: subInjectHash,
              parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
            }), _parseStyle4 = _slicedToArray(_parseStyle3, 2), _parsedStr2 = _parseStyle4[0], childEffectStyle = _parseStyle4[1];
            effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
            styleStr += "".concat(mergedKey).concat(_parsedStr2);
          } else {
            let appendStyle = function(cssKey, cssValue) {
              var styleName = cssKey.replace(/[A-Z]/g, function(match2) {
                return "-".concat(match2.toLowerCase());
              });
              var formatValue = cssValue;
              if (!unitlessKeys[cssKey] && typeof formatValue === "number" && formatValue !== 0) {
                formatValue = "".concat(formatValue, "px");
              }
              if (cssKey === "animationName" && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                parseKeyframes(cssValue);
                formatValue = cssValue.getName(hashId);
              }
              styleStr += "".concat(styleName, ":").concat(formatValue, ";");
            };
            var _value;
            var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
            if (_typeof(value) === "object" && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
              actualValue.forEach(function(item) {
                appendStyle(key, item);
              });
            } else {
              appendStyle(key, actualValue);
            }
          }
        });
      }
    });
    if (!root) {
      styleStr = "{".concat(styleStr, "}");
    } else if (layer && supportLayer()) {
      var layerCells = layer.split(",");
      var layerName = layerCells[layerCells.length - 1].trim();
      styleStr = "@layer ".concat(layerName, " {").concat(styleStr, "}");
      if (layerCells.length > 1) {
        styleStr = "@layer ".concat(layer, "{%%%:%}").concat(styleStr);
      }
    }
    return [styleStr, effectStyle];
  };
  function uniqueHash(path2, styleStr) {
    return murmur2("".concat(path2.join("%")).concat(styleStr));
  }
  function Empty$3() {
    return null;
  }
  function useStyleRegister(info, styleFn) {
    var token2 = info.token, path2 = info.path, hashId = info.hashId, layer = info.layer, nonce = info.nonce;
    var _React$useContext = React__namespace.useContext(StyleContext$1), autoClear = _React$useContext.autoClear;
    _React$useContext.mock;
    var defaultCache = _React$useContext.defaultCache, hashPriority = _React$useContext.hashPriority, container = _React$useContext.container, ssrInline = _React$useContext.ssrInline, transformers = _React$useContext.transformers, linters = _React$useContext.linters, cache = _React$useContext.cache;
    var tokenKey = token2._tokenKey;
    var fullPath = [tokenKey].concat(_toConsumableArray(path2));
    var isMergedClientSide = isClientSide;
    var _useGlobalCache = useClientCache(
      "style",
      fullPath,
      // Create cache if needed
      function() {
        var styleObj = styleFn();
        var _parseStyle5 = parseStyle(styleObj, {
          hashId,
          hashPriority,
          layer,
          path: path2.join("-"),
          transformers,
          linters
        }), _parseStyle6 = _slicedToArray(_parseStyle5, 2), parsedStyle = _parseStyle6[0], effectStyle = _parseStyle6[1];
        var styleStr = normalizeStyle(parsedStyle);
        var styleId = uniqueHash(fullPath, styleStr);
        if (isMergedClientSide) {
          var mergedCSSConfig = {
            mark: ATTR_MARK,
            prepend: "queue",
            attachTo: container
          };
          var nonceStr = typeof nonce === "function" ? nonce() : nonce;
          if (nonceStr) {
            mergedCSSConfig.csp = {
              nonce: nonceStr
            };
          }
          var style2 = updateCSS(styleStr, styleId, mergedCSSConfig);
          style2[CSS_IN_JS_INSTANCE] = cache.instanceId;
          style2.setAttribute(ATTR_TOKEN, tokenKey);
          Object.keys(effectStyle).forEach(function(effectKey) {
            updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
          });
        }
        return [styleStr, tokenKey, styleId];
      },
      // Remove cache if no need
      function(_ref2, fromHMR) {
        var _ref3 = _slicedToArray(_ref2, 3), styleId = _ref3[2];
        if ((fromHMR || autoClear) && isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      }
    ), _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3), cachedStyleStr = _useGlobalCache2[0], cachedTokenKey = _useGlobalCache2[1], cachedStyleId = _useGlobalCache2[2];
    return function(node2) {
      var styleNode;
      if (!ssrInline || isMergedClientSide || !defaultCache) {
        styleNode = /* @__PURE__ */ React__namespace.createElement(Empty$3, null);
      } else {
        var _ref4;
        styleNode = /* @__PURE__ */ React__namespace.createElement("style", _extends$2({}, (_ref4 = {}, _defineProperty(_ref4, ATTR_TOKEN, cachedTokenKey), _defineProperty(_ref4, ATTR_MARK, cachedStyleId), _ref4), {
          dangerouslySetInnerHTML: {
            __html: cachedStyleStr
          }
        }));
      }
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, styleNode, node2);
    };
  }
  var Keyframe = /* @__PURE__ */ function() {
    function Keyframe2(name, style2) {
      _classCallCheck(this, Keyframe2);
      _defineProperty(this, "name", void 0);
      _defineProperty(this, "style", void 0);
      _defineProperty(this, "_keyframe", true);
      this.name = name;
      this.style = style2;
    }
    _createClass$1(Keyframe2, [{
      key: "getName",
      value: function getName() {
        var hashId = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
        return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
      }
    }]);
    return Keyframe2;
  }();
  function sameDerivativeOption(left, right) {
    if (left.length !== right.length) {
      return false;
    }
    for (var i = 0; i < left.length; i++) {
      if (left[i] !== right[i]) {
        return false;
      }
    }
    return true;
  }
  var ThemeCache = /* @__PURE__ */ function() {
    function ThemeCache2() {
      _classCallCheck(this, ThemeCache2);
      _defineProperty(this, "cache", void 0);
      _defineProperty(this, "keys", void 0);
      _defineProperty(this, "cacheCallTimes", void 0);
      this.cache = /* @__PURE__ */ new Map();
      this.keys = [];
      this.cacheCallTimes = 0;
    }
    _createClass$1(ThemeCache2, [{
      key: "size",
      value: function size() {
        return this.keys.length;
      }
    }, {
      key: "internalGet",
      value: function internalGet(derivativeOption) {
        var _cache2, _cache3;
        var updateCallTimes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
        var cache = {
          map: this.cache
        };
        derivativeOption.forEach(function(derivative2) {
          if (!cache) {
            cache = void 0;
          } else {
            var _cache, _cache$map;
            cache = (_cache = cache) === null || _cache === void 0 ? void 0 : (_cache$map = _cache.map) === null || _cache$map === void 0 ? void 0 : _cache$map.get(derivative2);
          }
        });
        if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
          cache.value[1] = this.cacheCallTimes++;
        }
        return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
      }
    }, {
      key: "get",
      value: function get4(derivativeOption) {
        var _this$internalGet;
        return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
      }
    }, {
      key: "has",
      value: function has2(derivativeOption) {
        return !!this.internalGet(derivativeOption);
      }
    }, {
      key: "set",
      value: function set5(derivativeOption, value) {
        var _this = this;
        if (!this.has(derivativeOption)) {
          if (this.size() + 1 > ThemeCache2.MAX_CACHE_SIZE + ThemeCache2.MAX_CACHE_OFFSET) {
            var _this$keys$reduce = this.keys.reduce(function(result, key) {
              var _result = _slicedToArray(result, 2), callTimes = _result[1];
              if (_this.internalGet(key)[1] < callTimes) {
                return [key, _this.internalGet(key)[1]];
              }
              return result;
            }, [this.keys[0], this.cacheCallTimes]), _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1), targetKey = _this$keys$reduce2[0];
            this.delete(targetKey);
          }
          this.keys.push(derivativeOption);
        }
        var cache = this.cache;
        derivativeOption.forEach(function(derivative2, index2) {
          if (index2 === derivativeOption.length - 1) {
            cache.set(derivative2, {
              value: [value, _this.cacheCallTimes++]
            });
          } else {
            var cacheValue = cache.get(derivative2);
            if (!cacheValue) {
              cache.set(derivative2, {
                map: /* @__PURE__ */ new Map()
              });
            } else if (!cacheValue.map) {
              cacheValue.map = /* @__PURE__ */ new Map();
            }
            cache = cache.get(derivative2).map;
          }
        });
      }
    }, {
      key: "deleteByPath",
      value: function deleteByPath(currentCache, derivatives) {
        var cache = currentCache.get(derivatives[0]);
        if (derivatives.length === 1) {
          var _cache$value;
          if (!cache.map) {
            currentCache.delete(derivatives[0]);
          } else {
            currentCache.set(derivatives[0], {
              map: cache.map
            });
          }
          return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
        }
        var result = this.deleteByPath(cache.map, derivatives.slice(1));
        if ((!cache.map || cache.map.size === 0) && !cache.value) {
          currentCache.delete(derivatives[0]);
        }
        return result;
      }
    }, {
      key: "delete",
      value: function _delete(derivativeOption) {
        if (this.has(derivativeOption)) {
          this.keys = this.keys.filter(function(item) {
            return !sameDerivativeOption(item, derivativeOption);
          });
          return this.deleteByPath(this.cache, derivativeOption);
        }
        return void 0;
      }
    }]);
    return ThemeCache2;
  }();
  _defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
  _defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);
  var uuid$3 = 0;
  var Theme = /* @__PURE__ */ function() {
    function Theme2(derivatives) {
      _classCallCheck(this, Theme2);
      _defineProperty(this, "derivatives", void 0);
      _defineProperty(this, "id", void 0);
      this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
      this.id = uuid$3;
      if (derivatives.length === 0) {
        warning$2(derivatives.length > 0);
      }
      uuid$3 += 1;
    }
    _createClass$1(Theme2, [{
      key: "getDerivativeToken",
      value: function getDerivativeToken(token2) {
        return this.derivatives.reduce(function(result, derivative2) {
          return derivative2(token2, result);
        }, void 0);
      }
    }]);
    return Theme2;
  }();
  var cacheThemes = new ThemeCache();
  function createTheme(derivatives) {
    var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
    if (!cacheThemes.has(derivativeArr)) {
      cacheThemes.set(derivativeArr, new Theme(derivativeArr));
    }
    return cacheThemes.get(derivativeArr);
  }
  function noSplit(list) {
    list.notSplit = true;
    return list;
  }
  ({
    // Inset
    inset: ["top", "right", "bottom", "left"],
    insetBlock: ["top", "bottom"],
    insetBlockStart: ["top"],
    insetBlockEnd: ["bottom"],
    insetInline: ["left", "right"],
    insetInlineStart: ["left"],
    insetInlineEnd: ["right"],
    // Margin
    marginBlock: ["marginTop", "marginBottom"],
    marginBlockStart: ["marginTop"],
    marginBlockEnd: ["marginBottom"],
    marginInline: ["marginLeft", "marginRight"],
    marginInlineStart: ["marginLeft"],
    marginInlineEnd: ["marginRight"],
    // Padding
    paddingBlock: ["paddingTop", "paddingBottom"],
    paddingBlockStart: ["paddingTop"],
    paddingBlockEnd: ["paddingBottom"],
    paddingInline: ["paddingLeft", "paddingRight"],
    paddingInlineStart: ["paddingLeft"],
    paddingInlineEnd: ["paddingRight"],
    // Border
    borderBlock: noSplit(["borderTop", "borderBottom"]),
    borderBlockStart: noSplit(["borderTop"]),
    borderBlockEnd: noSplit(["borderBottom"]),
    borderInline: noSplit(["borderLeft", "borderRight"]),
    borderInlineStart: noSplit(["borderLeft"]),
    borderInlineEnd: noSplit(["borderRight"]),
    // Border width
    borderBlockWidth: ["borderTopWidth", "borderBottomWidth"],
    borderBlockStartWidth: ["borderTopWidth"],
    borderBlockEndWidth: ["borderBottomWidth"],
    borderInlineWidth: ["borderLeftWidth", "borderRightWidth"],
    borderInlineStartWidth: ["borderLeftWidth"],
    borderInlineEndWidth: ["borderRightWidth"],
    // Border style
    borderBlockStyle: ["borderTopStyle", "borderBottomStyle"],
    borderBlockStartStyle: ["borderTopStyle"],
    borderBlockEndStyle: ["borderBottomStyle"],
    borderInlineStyle: ["borderLeftStyle", "borderRightStyle"],
    borderInlineStartStyle: ["borderLeftStyle"],
    borderInlineEndStyle: ["borderRightStyle"],
    // Border color
    borderBlockColor: ["borderTopColor", "borderBottomColor"],
    borderBlockStartColor: ["borderTopColor"],
    borderBlockEndColor: ["borderBottomColor"],
    borderInlineColor: ["borderLeftColor", "borderRightColor"],
    borderInlineStartColor: ["borderLeftColor"],
    borderInlineEndColor: ["borderRightColor"],
    // Border radius
    borderStartStartRadius: ["borderTopLeftRadius"],
    borderStartEndRadius: ["borderTopRightRadius"],
    borderEndStartRadius: ["borderBottomLeftRadius"],
    borderEndEndRadius: ["borderBottomRightRadius"]
  });
  var IconContext = /* @__PURE__ */ React.createContext({});
  const Context$2 = IconContext;
  function _toArray(arr) {
    return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableRest();
  }
  function get(entity, path2) {
    var current = entity;
    for (var i = 0; i < path2.length; i += 1) {
      if (current === null || current === void 0) {
        return void 0;
      }
      current = current[path2[i]];
    }
    return current;
  }
  function internalSet(entity, paths, value, removeIfUndefined) {
    if (!paths.length) {
      return value;
    }
    var _paths = _toArray(paths), path2 = _paths[0], restPath = _paths.slice(1);
    var clone;
    if (!entity && typeof path2 === "number") {
      clone = [];
    } else if (Array.isArray(entity)) {
      clone = _toConsumableArray(entity);
    } else {
      clone = _objectSpread2({}, entity);
    }
    if (removeIfUndefined && value === void 0 && restPath.length === 1) {
      delete clone[path2][restPath[0]];
    } else {
      clone[path2] = internalSet(clone[path2], restPath, value, removeIfUndefined);
    }
    return clone;
  }
  function set(entity, paths, value) {
    var removeIfUndefined = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
    if (paths.length && removeIfUndefined && value === void 0 && !get(entity, paths.slice(0, -1))) {
      return entity;
    }
    return internalSet(entity, paths, value, removeIfUndefined);
  }
  function isObject$2(obj) {
    return _typeof(obj) === "object" && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
  }
  function createEmpty(source) {
    return Array.isArray(source) ? [] : {};
  }
  var keys = typeof Reflect === "undefined" ? Object.keys : Reflect.ownKeys;
  function merge$2() {
    for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
      sources[_key] = arguments[_key];
    }
    var clone = createEmpty(sources[0]);
    sources.forEach(function(src) {
      function internalMerge(path2, parentLoopSet) {
        var loopSet = new Set(parentLoopSet);
        var value = get(src, path2);
        var isArr = Array.isArray(value);
        if (isArr || isObject$2(value)) {
          if (!loopSet.has(value)) {
            loopSet.add(value);
            var originValue = get(clone, path2);
            if (isArr) {
              clone = set(clone, path2, []);
            } else if (!originValue || _typeof(originValue) !== "object") {
              clone = set(clone, path2, createEmpty(value));
            }
            keys(value).forEach(function(key) {
              internalMerge([].concat(_toConsumableArray(path2), [key]), loopSet);
            });
          }
        } else {
          clone = set(clone, path2, value);
        }
      }
      internalMerge([]);
    });
    return clone;
  }
  const ValidateMessagesContext = /* @__PURE__ */ React.createContext(void 0);
  const enUS$1 = {
    // Options.jsx
    items_per_page: "/ page",
    jump_to: "Go to",
    jump_to_confirm: "confirm",
    page: "Page",
    // Pagination.jsx
    prev_page: "Previous Page",
    next_page: "Next Page",
    prev_5: "Previous 5 Pages",
    next_5: "Next 5 Pages",
    prev_3: "Previous 3 Pages",
    next_3: "Next 3 Pages",
    page_size: "Page Size"
  };
  var locale$2 = {
    locale: "en_US",
    today: "Today",
    now: "Now",
    backToToday: "Back to today",
    ok: "OK",
    clear: "Clear",
    month: "Month",
    year: "Year",
    timeSelect: "select time",
    dateSelect: "select date",
    weekSelect: "Choose a week",
    monthSelect: "Choose a month",
    yearSelect: "Choose a year",
    decadeSelect: "Choose a decade",
    yearFormat: "YYYY",
    dateFormat: "M/D/YYYY",
    dayFormat: "D",
    dateTimeFormat: "M/D/YYYY HH:mm:ss",
    monthBeforeYear: true,
    previousMonth: "Previous month (PageUp)",
    nextMonth: "Next month (PageDown)",
    previousYear: "Last year (Control + left)",
    nextYear: "Next year (Control + right)",
    previousDecade: "Last decade",
    nextDecade: "Next decade",
    previousCentury: "Last century",
    nextCentury: "Next century"
  };
  const locale$1 = {
    placeholder: "Select time",
    rangePlaceholder: ["Start time", "End time"]
  };
  const TimePicker = locale$1;
  const locale = {
    lang: Object.assign({
      placeholder: "Select date",
      yearPlaceholder: "Select year",
      quarterPlaceholder: "Select quarter",
      monthPlaceholder: "Select month",
      weekPlaceholder: "Select week",
      rangePlaceholder: ["Start date", "End date"],
      rangeYearPlaceholder: ["Start year", "End year"],
      rangeQuarterPlaceholder: ["Start quarter", "End quarter"],
      rangeMonthPlaceholder: ["Start month", "End month"],
      rangeWeekPlaceholder: ["Start week", "End week"]
    }, locale$2),
    timePickerLocale: Object.assign({}, TimePicker)
  };
  const enUS = locale;
  const typeTemplate$1 = "${label} is not a valid ${type}";
  const localeValues = {
    locale: "en",
    Pagination: enUS$1,
    DatePicker: enUS,
    TimePicker,
    Calendar: enUS,
    global: {
      placeholder: "Please select"
    },
    Table: {
      filterTitle: "Filter menu",
      filterConfirm: "OK",
      filterReset: "Reset",
      filterEmptyText: "No filters",
      filterCheckall: "Select all items",
      filterSearchPlaceholder: "Search in filters",
      emptyText: "No data",
      selectAll: "Select current page",
      selectInvert: "Invert current page",
      selectNone: "Clear all data",
      selectionAll: "Select all data",
      sortTitle: "Sort",
      expand: "Expand row",
      collapse: "Collapse row",
      triggerDesc: "Click to sort descending",
      triggerAsc: "Click to sort ascending",
      cancelSort: "Click to cancel sorting"
    },
    Tour: {
      Next: "Next",
      Previous: "Previous",
      Finish: "Finish"
    },
    Modal: {
      okText: "OK",
      cancelText: "Cancel",
      justOkText: "OK"
    },
    Popconfirm: {
      okText: "OK",
      cancelText: "Cancel"
    },
    Transfer: {
      titles: ["", ""],
      searchPlaceholder: "Search here",
      itemUnit: "item",
      itemsUnit: "items",
      remove: "Remove",
      selectCurrent: "Select current page",
      removeCurrent: "Remove current page",
      selectAll: "Select all data",
      removeAll: "Remove all data",
      selectInvert: "Invert current page"
    },
    Upload: {
      uploading: "Uploading...",
      removeFile: "Remove file",
      uploadError: "Upload error",
      previewFile: "Preview file",
      downloadFile: "Download file"
    },
    Empty: {
      description: "No data"
    },
    Icon: {
      icon: "icon"
    },
    Text: {
      edit: "Edit",
      copy: "Copy",
      copied: "Copied",
      expand: "Expand"
    },
    PageHeader: {
      back: "Back"
    },
    Form: {
      optional: "(optional)",
      defaultValidateMessages: {
        default: "Field validation error for ${label}",
        required: "Please enter ${label}",
        enum: "${label} must be one of [${enum}]",
        whitespace: "${label} cannot be a blank character",
        date: {
          format: "${label} date format is invalid",
          parse: "${label} cannot be converted to a date",
          invalid: "${label} is an invalid date"
        },
        types: {
          string: typeTemplate$1,
          method: typeTemplate$1,
          array: typeTemplate$1,
          object: typeTemplate$1,
          number: typeTemplate$1,
          date: typeTemplate$1,
          boolean: typeTemplate$1,
          integer: typeTemplate$1,
          float: typeTemplate$1,
          regexp: typeTemplate$1,
          email: typeTemplate$1,
          url: typeTemplate$1,
          hex: typeTemplate$1
        },
        string: {
          len: "${label} must be ${len} characters",
          min: "${label} must be at least ${min} characters",
          max: "${label} must be up to ${max} characters",
          range: "${label} must be between ${min}-${max} characters"
        },
        number: {
          len: "${label} must be equal to ${len}",
          min: "${label} must be minimum ${min}",
          max: "${label} must be maximum ${max}",
          range: "${label} must be between ${min}-${max}"
        },
        array: {
          len: "Must be ${len} ${label}",
          min: "At least ${min} ${label}",
          max: "At most ${max} ${label}",
          range: "The amount of ${label} must be between ${min}-${max}"
        },
        pattern: {
          mismatch: "${label} does not match the pattern ${pattern}"
        }
      }
    },
    Image: {
      preview: "Preview"
    },
    QRCode: {
      expired: "QR code expired",
      refresh: "Refresh"
    },
    ColorPicker: {
      presetEmpty: "Empty"
    }
  };
  const defaultLocale = localeValues;
  let runtimeLocale = Object.assign({}, defaultLocale.Modal);
  function changeConfirmLocale(newLocale) {
    if (newLocale) {
      runtimeLocale = Object.assign(Object.assign({}, runtimeLocale), newLocale);
    } else {
      runtimeLocale = Object.assign({}, defaultLocale.Modal);
    }
  }
  function getConfirmLocale() {
    return runtimeLocale;
  }
  const LocaleContext = /* @__PURE__ */ React.createContext(void 0);
  const LocaleContext$1 = LocaleContext;
  const useLocale = (componentName, defaultLocale$1) => {
    const fullLocale = React__namespace.useContext(LocaleContext$1);
    const getLocale = React__namespace.useMemo(() => {
      var _a2;
      const locale2 = defaultLocale$1 || defaultLocale[componentName];
      const localeFromContext = (_a2 = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale[componentName]) !== null && _a2 !== void 0 ? _a2 : {};
      return Object.assign(Object.assign({}, typeof locale2 === "function" ? locale2() : locale2), localeFromContext || {});
    }, [componentName, defaultLocale$1, fullLocale]);
    const getLocaleCode = React__namespace.useMemo(() => {
      const localeCode = fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.locale;
      if ((fullLocale === null || fullLocale === void 0 ? void 0 : fullLocale.exist) && !localeCode) {
        return defaultLocale.locale;
      }
      return localeCode;
    }, [fullLocale]);
    return [getLocale, getLocaleCode];
  };
  const useLocale$1 = useLocale;
  const ANT_MARK = "internalMark";
  const LocaleProvider = (props) => {
    const {
      locale: locale2 = {},
      children,
      _ANT_MARK__
    } = props;
    React__namespace.useEffect(() => {
      changeConfirmLocale(locale2 && locale2.Modal);
      return () => {
        changeConfirmLocale();
      };
    }, [locale2]);
    const getMemoizedContextValue = React__namespace.useMemo(() => Object.assign(Object.assign({}, locale2), {
      exist: true
    }), [locale2]);
    return /* @__PURE__ */ React__namespace.createElement(LocaleContext$1.Provider, {
      value: getMemoizedContextValue
    }, children);
  };
  const LocaleProvider$1 = LocaleProvider;
  const version$1 = "5.6.3";
  const PresetColors = ["blue", "purple", "cyan", "green", "magenta", "pink", "red", "orange", "yellow", "volcano", "geekblue", "lime", "gold"];
  function bound01(n2, max) {
    if (isOnePointZero(n2)) {
      n2 = "100%";
    }
    var isPercent = isPercentage(n2);
    n2 = max === 360 ? n2 : Math.min(max, Math.max(0, parseFloat(n2)));
    if (isPercent) {
      n2 = parseInt(String(n2 * max), 10) / 100;
    }
    if (Math.abs(n2 - max) < 1e-6) {
      return 1;
    }
    if (max === 360) {
      n2 = (n2 < 0 ? n2 % max + max : n2 % max) / parseFloat(String(max));
    } else {
      n2 = n2 % max / parseFloat(String(max));
    }
    return n2;
  }
  function clamp01(val) {
    return Math.min(1, Math.max(0, val));
  }
  function isOnePointZero(n2) {
    return typeof n2 === "string" && n2.indexOf(".") !== -1 && parseFloat(n2) === 1;
  }
  function isPercentage(n2) {
    return typeof n2 === "string" && n2.indexOf("%") !== -1;
  }
  function boundAlpha(a) {
    a = parseFloat(a);
    if (isNaN(a) || a < 0 || a > 1) {
      a = 1;
    }
    return a;
  }
  function convertToPercentage(n2) {
    if (n2 <= 1) {
      return "".concat(Number(n2) * 100, "%");
    }
    return n2;
  }
  function pad2(c2) {
    return c2.length === 1 ? "0" + c2 : String(c2);
  }
  function rgbToRgb(r2, g2, b2) {
    return {
      r: bound01(r2, 255) * 255,
      g: bound01(g2, 255) * 255,
      b: bound01(b2, 255) * 255
    };
  }
  function rgbToHsl(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var h2 = 0;
    var s = 0;
    var l2 = (max + min) / 2;
    if (max === min) {
      s = 0;
      h2 = 0;
    } else {
      var d2 = max - min;
      s = l2 > 0.5 ? d2 / (2 - max - min) : d2 / (max + min);
      switch (max) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s, l: l2 };
  }
  function hue2rgb(p2, q2, t2) {
    if (t2 < 0) {
      t2 += 1;
    }
    if (t2 > 1) {
      t2 -= 1;
    }
    if (t2 < 1 / 6) {
      return p2 + (q2 - p2) * (6 * t2);
    }
    if (t2 < 1 / 2) {
      return q2;
    }
    if (t2 < 2 / 3) {
      return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
    }
    return p2;
  }
  function hslToRgb(h2, s, l2) {
    var r2;
    var g2;
    var b2;
    h2 = bound01(h2, 360);
    s = bound01(s, 100);
    l2 = bound01(l2, 100);
    if (s === 0) {
      g2 = l2;
      b2 = l2;
      r2 = l2;
    } else {
      var q2 = l2 < 0.5 ? l2 * (1 + s) : l2 + s - l2 * s;
      var p2 = 2 * l2 - q2;
      r2 = hue2rgb(p2, q2, h2 + 1 / 3);
      g2 = hue2rgb(p2, q2, h2);
      b2 = hue2rgb(p2, q2, h2 - 1 / 3);
    }
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHsv(r2, g2, b2) {
    r2 = bound01(r2, 255);
    g2 = bound01(g2, 255);
    b2 = bound01(b2, 255);
    var max = Math.max(r2, g2, b2);
    var min = Math.min(r2, g2, b2);
    var h2 = 0;
    var v2 = max;
    var d2 = max - min;
    var s = max === 0 ? 0 : d2 / max;
    if (max === min) {
      h2 = 0;
    } else {
      switch (max) {
        case r2:
          h2 = (g2 - b2) / d2 + (g2 < b2 ? 6 : 0);
          break;
        case g2:
          h2 = (b2 - r2) / d2 + 2;
          break;
        case b2:
          h2 = (r2 - g2) / d2 + 4;
          break;
      }
      h2 /= 6;
    }
    return { h: h2, s, v: v2 };
  }
  function hsvToRgb(h2, s, v2) {
    h2 = bound01(h2, 360) * 6;
    s = bound01(s, 100);
    v2 = bound01(v2, 100);
    var i = Math.floor(h2);
    var f2 = h2 - i;
    var p2 = v2 * (1 - s);
    var q2 = v2 * (1 - f2 * s);
    var t2 = v2 * (1 - (1 - f2) * s);
    var mod = i % 6;
    var r2 = [v2, q2, p2, p2, t2, v2][mod];
    var g2 = [t2, v2, v2, q2, p2, p2][mod];
    var b2 = [p2, p2, t2, v2, v2, q2][mod];
    return { r: r2 * 255, g: g2 * 255, b: b2 * 255 };
  }
  function rgbToHex(r2, g2, b2, allow3Char) {
    var hex2 = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16))
    ];
    if (allow3Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0);
    }
    return hex2.join("");
  }
  function rgbaToHex(r2, g2, b2, a, allow4Char) {
    var hex2 = [
      pad2(Math.round(r2).toString(16)),
      pad2(Math.round(g2).toString(16)),
      pad2(Math.round(b2).toString(16)),
      pad2(convertDecimalToHex(a))
    ];
    if (allow4Char && hex2[0].startsWith(hex2[0].charAt(1)) && hex2[1].startsWith(hex2[1].charAt(1)) && hex2[2].startsWith(hex2[2].charAt(1)) && hex2[3].startsWith(hex2[3].charAt(1))) {
      return hex2[0].charAt(0) + hex2[1].charAt(0) + hex2[2].charAt(0) + hex2[3].charAt(0);
    }
    return hex2.join("");
  }
  function convertDecimalToHex(d2) {
    return Math.round(parseFloat(d2) * 255).toString(16);
  }
  function convertHexToDecimal(h2) {
    return parseIntFromHex(h2) / 255;
  }
  function parseIntFromHex(val) {
    return parseInt(val, 16);
  }
  function numberInputToObject(color) {
    return {
      r: color >> 16,
      g: (color & 65280) >> 8,
      b: color & 255
    };
  }
  var names = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    goldenrod: "#daa520",
    gold: "#ffd700",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavenderblush: "#fff0f5",
    lavender: "#e6e6fa",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
  function inputToRGB(color) {
    var rgb = { r: 0, g: 0, b: 0 };
    var a = 1;
    var s = null;
    var v2 = null;
    var l2 = null;
    var ok = false;
    var format2 = false;
    if (typeof color === "string") {
      color = stringInputToObject(color);
    }
    if (typeof color === "object") {
      if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
        rgb = rgbToRgb(color.r, color.g, color.b);
        ok = true;
        format2 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
        s = convertToPercentage(color.s);
        v2 = convertToPercentage(color.v);
        rgb = hsvToRgb(color.h, s, v2);
        ok = true;
        format2 = "hsv";
      } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
        s = convertToPercentage(color.s);
        l2 = convertToPercentage(color.l);
        rgb = hslToRgb(color.h, s, l2);
        ok = true;
        format2 = "hsl";
      }
      if (Object.prototype.hasOwnProperty.call(color, "a")) {
        a = color.a;
      }
    }
    a = boundAlpha(a);
    return {
      ok,
      format: color.format || format2,
      r: Math.min(255, Math.max(rgb.r, 0)),
      g: Math.min(255, Math.max(rgb.g, 0)),
      b: Math.min(255, Math.max(rgb.b, 0)),
      a
    };
  }
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:".concat(CSS_NUMBER, ")|(?:").concat(CSS_INTEGER, ")");
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(".concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")[,|\\s]+(").concat(CSS_UNIT, ")\\s*\\)?");
  var matchers = {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
  function stringInputToObject(color) {
    color = color.trim().toLowerCase();
    if (color.length === 0) {
      return false;
    }
    var named = false;
    if (names[color]) {
      color = names[color];
      named = true;
    } else if (color === "transparent") {
      return { r: 0, g: 0, b: 0, a: 0, format: "name" };
    }
    var match2 = matchers.rgb.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3] };
    }
    match2 = matchers.rgba.exec(color);
    if (match2) {
      return { r: match2[1], g: match2[2], b: match2[3], a: match2[4] };
    }
    match2 = matchers.hsl.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3] };
    }
    match2 = matchers.hsla.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], l: match2[3], a: match2[4] };
    }
    match2 = matchers.hsv.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3] };
    }
    match2 = matchers.hsva.exec(color);
    if (match2) {
      return { h: match2[1], s: match2[2], v: match2[3], a: match2[4] };
    }
    match2 = matchers.hex8.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        a: convertHexToDecimal(match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex6.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1]),
        g: parseIntFromHex(match2[2]),
        b: parseIntFromHex(match2[3]),
        format: named ? "name" : "hex"
      };
    }
    match2 = matchers.hex4.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        a: convertHexToDecimal(match2[4] + match2[4]),
        format: named ? "name" : "hex8"
      };
    }
    match2 = matchers.hex3.exec(color);
    if (match2) {
      return {
        r: parseIntFromHex(match2[1] + match2[1]),
        g: parseIntFromHex(match2[2] + match2[2]),
        b: parseIntFromHex(match2[3] + match2[3]),
        format: named ? "name" : "hex"
      };
    }
    return false;
  }
  function isValidCSSUnit(color) {
    return Boolean(matchers.CSS_UNIT.exec(String(color)));
  }
  var TinyColor = (
    /** @class */
    function() {
      function TinyColor2(color, opts) {
        if (color === void 0) {
          color = "";
        }
        if (opts === void 0) {
          opts = {};
        }
        var _a2;
        if (color instanceof TinyColor2) {
          return color;
        }
        if (typeof color === "number") {
          color = numberInputToObject(color);
        }
        this.originalInput = color;
        var rgb = inputToRGB(color);
        this.originalInput = color;
        this.r = rgb.r;
        this.g = rgb.g;
        this.b = rgb.b;
        this.a = rgb.a;
        this.roundA = Math.round(100 * this.a) / 100;
        this.format = (_a2 = opts.format) !== null && _a2 !== void 0 ? _a2 : rgb.format;
        this.gradientType = opts.gradientType;
        if (this.r < 1) {
          this.r = Math.round(this.r);
        }
        if (this.g < 1) {
          this.g = Math.round(this.g);
        }
        if (this.b < 1) {
          this.b = Math.round(this.b);
        }
        this.isValid = rgb.ok;
      }
      TinyColor2.prototype.isDark = function() {
        return this.getBrightness() < 128;
      };
      TinyColor2.prototype.isLight = function() {
        return !this.isDark();
      };
      TinyColor2.prototype.getBrightness = function() {
        var rgb = this.toRgb();
        return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
      };
      TinyColor2.prototype.getLuminance = function() {
        var rgb = this.toRgb();
        var R;
        var G;
        var B;
        var RsRGB = rgb.r / 255;
        var GsRGB = rgb.g / 255;
        var BsRGB = rgb.b / 255;
        if (RsRGB <= 0.03928) {
          R = RsRGB / 12.92;
        } else {
          R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
        }
        if (GsRGB <= 0.03928) {
          G = GsRGB / 12.92;
        } else {
          G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
        }
        if (BsRGB <= 0.03928) {
          B = BsRGB / 12.92;
        } else {
          B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      };
      TinyColor2.prototype.getAlpha = function() {
        return this.a;
      };
      TinyColor2.prototype.setAlpha = function(alpha) {
        this.a = boundAlpha(alpha);
        this.roundA = Math.round(100 * this.a) / 100;
        return this;
      };
      TinyColor2.prototype.isMonochrome = function() {
        var s = this.toHsl().s;
        return s === 0;
      };
      TinyColor2.prototype.toHsv = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this.a };
      };
      TinyColor2.prototype.toHsvString = function() {
        var hsv = rgbToHsv(this.r, this.g, this.b);
        var h2 = Math.round(hsv.h * 360);
        var s = Math.round(hsv.s * 100);
        var v2 = Math.round(hsv.v * 100);
        return this.a === 1 ? "hsv(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%)") : "hsva(".concat(h2, ", ").concat(s, "%, ").concat(v2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHsl = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this.a };
      };
      TinyColor2.prototype.toHslString = function() {
        var hsl = rgbToHsl(this.r, this.g, this.b);
        var h2 = Math.round(hsl.h * 360);
        var s = Math.round(hsl.s * 100);
        var l2 = Math.round(hsl.l * 100);
        return this.a === 1 ? "hsl(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%)") : "hsla(".concat(h2, ", ").concat(s, "%, ").concat(l2, "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toHex = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return rgbToHex(this.r, this.g, this.b, allow3Char);
      };
      TinyColor2.prototype.toHexString = function(allow3Char) {
        if (allow3Char === void 0) {
          allow3Char = false;
        }
        return "#" + this.toHex(allow3Char);
      };
      TinyColor2.prototype.toHex8 = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return rgbaToHex(this.r, this.g, this.b, this.a, allow4Char);
      };
      TinyColor2.prototype.toHex8String = function(allow4Char) {
        if (allow4Char === void 0) {
          allow4Char = false;
        }
        return "#" + this.toHex8(allow4Char);
      };
      TinyColor2.prototype.toHexShortString = function(allowShortChar) {
        if (allowShortChar === void 0) {
          allowShortChar = false;
        }
        return this.a === 1 ? this.toHexString(allowShortChar) : this.toHex8String(allowShortChar);
      };
      TinyColor2.prototype.toRgb = function() {
        return {
          r: Math.round(this.r),
          g: Math.round(this.g),
          b: Math.round(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toRgbString = function() {
        var r2 = Math.round(this.r);
        var g2 = Math.round(this.g);
        var b2 = Math.round(this.b);
        return this.a === 1 ? "rgb(".concat(r2, ", ").concat(g2, ", ").concat(b2, ")") : "rgba(".concat(r2, ", ").concat(g2, ", ").concat(b2, ", ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toPercentageRgb = function() {
        var fmt = function(x2) {
          return "".concat(Math.round(bound01(x2, 255) * 100), "%");
        };
        return {
          r: fmt(this.r),
          g: fmt(this.g),
          b: fmt(this.b),
          a: this.a
        };
      };
      TinyColor2.prototype.toPercentageRgbString = function() {
        var rnd = function(x2) {
          return Math.round(bound01(x2, 255) * 100);
        };
        return this.a === 1 ? "rgb(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%)") : "rgba(".concat(rnd(this.r), "%, ").concat(rnd(this.g), "%, ").concat(rnd(this.b), "%, ").concat(this.roundA, ")");
      };
      TinyColor2.prototype.toName = function() {
        if (this.a === 0) {
          return "transparent";
        }
        if (this.a < 1) {
          return false;
        }
        var hex2 = "#" + rgbToHex(this.r, this.g, this.b, false);
        for (var _i = 0, _a2 = Object.entries(names); _i < _a2.length; _i++) {
          var _b = _a2[_i], key = _b[0], value = _b[1];
          if (hex2 === value) {
            return key;
          }
        }
        return false;
      };
      TinyColor2.prototype.toString = function(format2) {
        var formatSet = Boolean(format2);
        format2 = format2 !== null && format2 !== void 0 ? format2 : this.format;
        var formattedString = false;
        var hasAlpha = this.a < 1 && this.a >= 0;
        var needsAlphaFormat = !formatSet && hasAlpha && (format2.startsWith("hex") || format2 === "name");
        if (needsAlphaFormat) {
          if (format2 === "name" && this.a === 0) {
            return this.toName();
          }
          return this.toRgbString();
        }
        if (format2 === "rgb") {
          formattedString = this.toRgbString();
        }
        if (format2 === "prgb") {
          formattedString = this.toPercentageRgbString();
        }
        if (format2 === "hex" || format2 === "hex6") {
          formattedString = this.toHexString();
        }
        if (format2 === "hex3") {
          formattedString = this.toHexString(true);
        }
        if (format2 === "hex4") {
          formattedString = this.toHex8String(true);
        }
        if (format2 === "hex8") {
          formattedString = this.toHex8String();
        }
        if (format2 === "name") {
          formattedString = this.toName();
        }
        if (format2 === "hsl") {
          formattedString = this.toHslString();
        }
        if (format2 === "hsv") {
          formattedString = this.toHsvString();
        }
        return formattedString || this.toHexString();
      };
      TinyColor2.prototype.toNumber = function() {
        return (Math.round(this.r) << 16) + (Math.round(this.g) << 8) + Math.round(this.b);
      };
      TinyColor2.prototype.clone = function() {
        return new TinyColor2(this.toString());
      };
      TinyColor2.prototype.lighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.brighten = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var rgb = this.toRgb();
        rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
        rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
        rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
        return new TinyColor2(rgb);
      };
      TinyColor2.prototype.darken = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.tint = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("white", amount);
      };
      TinyColor2.prototype.shade = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        return this.mix("black", amount);
      };
      TinyColor2.prototype.desaturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.saturate = function(amount) {
        if (amount === void 0) {
          amount = 10;
        }
        var hsl = this.toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.greyscale = function() {
        return this.desaturate(100);
      };
      TinyColor2.prototype.spin = function(amount) {
        var hsl = this.toHsl();
        var hue = (hsl.h + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.mix = function(color, amount) {
        if (amount === void 0) {
          amount = 50;
        }
        var rgb1 = this.toRgb();
        var rgb2 = new TinyColor2(color).toRgb();
        var p2 = amount / 100;
        var rgba = {
          r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
          g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
          b: (rgb2.b - rgb1.b) * p2 + rgb1.b,
          a: (rgb2.a - rgb1.a) * p2 + rgb1.a
        };
        return new TinyColor2(rgba);
      };
      TinyColor2.prototype.analogous = function(results, slices) {
        if (results === void 0) {
          results = 6;
        }
        if (slices === void 0) {
          slices = 30;
        }
        var hsl = this.toHsl();
        var part = 360 / slices;
        var ret = [this];
        for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
          hsl.h = (hsl.h + part) % 360;
          ret.push(new TinyColor2(hsl));
        }
        return ret;
      };
      TinyColor2.prototype.complement = function() {
        var hsl = this.toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return new TinyColor2(hsl);
      };
      TinyColor2.prototype.monochromatic = function(results) {
        if (results === void 0) {
          results = 6;
        }
        var hsv = this.toHsv();
        var h2 = hsv.h;
        var s = hsv.s;
        var v2 = hsv.v;
        var res = [];
        var modification = 1 / results;
        while (results--) {
          res.push(new TinyColor2({ h: h2, s, v: v2 }));
          v2 = (v2 + modification) % 1;
        }
        return res;
      };
      TinyColor2.prototype.splitcomplement = function() {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        return [
          this,
          new TinyColor2({ h: (h2 + 72) % 360, s: hsl.s, l: hsl.l }),
          new TinyColor2({ h: (h2 + 216) % 360, s: hsl.s, l: hsl.l })
        ];
      };
      TinyColor2.prototype.onBackground = function(background) {
        var fg = this.toRgb();
        var bg = new TinyColor2(background).toRgb();
        var alpha = fg.a + bg.a * (1 - fg.a);
        return new TinyColor2({
          r: (fg.r * fg.a + bg.r * bg.a * (1 - fg.a)) / alpha,
          g: (fg.g * fg.a + bg.g * bg.a * (1 - fg.a)) / alpha,
          b: (fg.b * fg.a + bg.b * bg.a * (1 - fg.a)) / alpha,
          a: alpha
        });
      };
      TinyColor2.prototype.triad = function() {
        return this.polyad(3);
      };
      TinyColor2.prototype.tetrad = function() {
        return this.polyad(4);
      };
      TinyColor2.prototype.polyad = function(n2) {
        var hsl = this.toHsl();
        var h2 = hsl.h;
        var result = [this];
        var increment = 360 / n2;
        for (var i = 1; i < n2; i++) {
          result.push(new TinyColor2({ h: (h2 + i * increment) % 360, s: hsl.s, l: hsl.l }));
        }
        return result;
      };
      TinyColor2.prototype.equals = function(color) {
        return this.toRgbString() === new TinyColor2(color).toRgbString();
      };
      return TinyColor2;
    }()
  );
  var hueStep = 2;
  var saturationStep = 0.16;
  var saturationStep2 = 0.05;
  var brightnessStep1 = 0.05;
  var brightnessStep2 = 0.15;
  var lightColorCount = 5;
  var darkColorCount = 4;
  var darkColorMap = [{
    index: 7,
    opacity: 0.15
  }, {
    index: 6,
    opacity: 0.25
  }, {
    index: 5,
    opacity: 0.3
  }, {
    index: 5,
    opacity: 0.45
  }, {
    index: 5,
    opacity: 0.65
  }, {
    index: 5,
    opacity: 0.85
  }, {
    index: 4,
    opacity: 0.9
  }, {
    index: 3,
    opacity: 0.95
  }, {
    index: 2,
    opacity: 0.97
  }, {
    index: 1,
    opacity: 0.98
  }];
  function toHsv(_ref) {
    var r2 = _ref.r, g2 = _ref.g, b2 = _ref.b;
    var hsv = rgbToHsv(r2, g2, b2);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v
    };
  }
  function toHex(_ref2) {
    var r2 = _ref2.r, g2 = _ref2.g, b2 = _ref2.b;
    return "#".concat(rgbToHex(r2, g2, b2, false));
  }
  function mix(rgb1, rgb2, amount) {
    var p2 = amount / 100;
    var rgb = {
      r: (rgb2.r - rgb1.r) * p2 + rgb1.r,
      g: (rgb2.g - rgb1.g) * p2 + rgb1.g,
      b: (rgb2.b - rgb1.b) * p2 + rgb1.b
    };
    return rgb;
  }
  function getHue(hsv, i, light) {
    var hue;
    if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
      hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
    } else {
      hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
    }
    if (hue < 0) {
      hue += 360;
    } else if (hue >= 360) {
      hue -= 360;
    }
    return hue;
  }
  function getSaturation(hsv, i, light) {
    if (hsv.h === 0 && hsv.s === 0) {
      return hsv.s;
    }
    var saturation;
    if (light) {
      saturation = hsv.s - saturationStep * i;
    } else if (i === darkColorCount) {
      saturation = hsv.s + saturationStep;
    } else {
      saturation = hsv.s + saturationStep2 * i;
    }
    if (saturation > 1) {
      saturation = 1;
    }
    if (light && i === lightColorCount && saturation > 0.1) {
      saturation = 0.1;
    }
    if (saturation < 0.06) {
      saturation = 0.06;
    }
    return Number(saturation.toFixed(2));
  }
  function getValue$1(hsv, i, light) {
    var value;
    if (light) {
      value = hsv.v + brightnessStep1 * i;
    } else {
      value = hsv.v - brightnessStep2 * i;
    }
    if (value > 1) {
      value = 1;
    }
    return Number(value.toFixed(2));
  }
  function generate$1(color) {
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var patterns = [];
    var pColor = inputToRGB(color);
    for (var i = lightColorCount; i > 0; i -= 1) {
      var hsv = toHsv(pColor);
      var colorString = toHex(inputToRGB({
        h: getHue(hsv, i, true),
        s: getSaturation(hsv, i, true),
        v: getValue$1(hsv, i, true)
      }));
      patterns.push(colorString);
    }
    patterns.push(toHex(pColor));
    for (var _i = 1; _i <= darkColorCount; _i += 1) {
      var _hsv = toHsv(pColor);
      var _colorString = toHex(inputToRGB({
        h: getHue(_hsv, _i),
        s: getSaturation(_hsv, _i),
        v: getValue$1(_hsv, _i)
      }));
      patterns.push(_colorString);
    }
    if (opts.theme === "dark") {
      return darkColorMap.map(function(_ref3) {
        var index2 = _ref3.index, opacity = _ref3.opacity;
        var darkColorString = toHex(mix(inputToRGB(opts.backgroundColor || "#141414"), inputToRGB(patterns[index2]), opacity * 100));
        return darkColorString;
      });
    }
    return patterns;
  }
  var presetPrimaryColors = {
    red: "#F5222D",
    volcano: "#FA541C",
    orange: "#FA8C16",
    gold: "#FAAD14",
    yellow: "#FADB14",
    lime: "#A0D911",
    green: "#52C41A",
    cyan: "#13C2C2",
    blue: "#1677FF",
    geekblue: "#2F54EB",
    purple: "#722ED1",
    magenta: "#EB2F96",
    grey: "#666666"
  };
  var presetPalettes = {};
  var presetDarkPalettes = {};
  Object.keys(presetPrimaryColors).forEach(function(key) {
    presetPalettes[key] = generate$1(presetPrimaryColors[key]);
    presetPalettes[key].primary = presetPalettes[key][5];
    presetDarkPalettes[key] = generate$1(presetPrimaryColors[key], {
      theme: "dark",
      backgroundColor: "#141414"
    });
    presetDarkPalettes[key].primary = presetDarkPalettes[key][5];
  });
  var red = presetPalettes.red;
  var green = presetPalettes.green;
  var blue = presetPalettes.blue;
  const genControlHeight = (token2) => {
    const {
      controlHeight
    } = token2;
    return {
      controlHeightSM: controlHeight * 0.75,
      controlHeightXS: controlHeight * 0.5,
      controlHeightLG: controlHeight * 1.25
    };
  };
  const genControlHeight$1 = genControlHeight;
  function genSizeMapToken$1(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    return {
      sizeXXL: sizeUnit * (sizeStep + 8),
      sizeXL: sizeUnit * (sizeStep + 4),
      sizeLG: sizeUnit * (sizeStep + 2),
      sizeMD: sizeUnit * (sizeStep + 1),
      sizeMS: sizeUnit * sizeStep,
      size: sizeUnit * sizeStep,
      sizeSM: sizeUnit * (sizeStep - 1),
      sizeXS: sizeUnit * (sizeStep - 2),
      sizeXXS: sizeUnit * (sizeStep - 3)
      // 4
    };
  }
  const defaultPresetColors = {
    blue: "#1677ff",
    purple: "#722ED1",
    cyan: "#13C2C2",
    green: "#52C41A",
    magenta: "#EB2F96",
    pink: "#eb2f96",
    red: "#F5222D",
    orange: "#FA8C16",
    yellow: "#FADB14",
    volcano: "#FA541C",
    geekblue: "#2F54EB",
    gold: "#FAAD14",
    lime: "#A0D911"
  };
  const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
    // Color
    colorPrimary: "#1677ff",
    colorSuccess: "#52c41a",
    colorWarning: "#faad14",
    colorError: "#ff4d4f",
    colorInfo: "#1677ff",
    colorTextBase: "",
    colorBgBase: "",
    // Font
    fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
    fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
    fontSize: 14,
    // Line
    lineWidth: 1,
    lineType: "solid",
    // Motion
    motionUnit: 0.1,
    motionBase: 0,
    motionEaseOutCirc: "cubic-bezier(0.08, 0.82, 0.17, 1)",
    motionEaseInOutCirc: "cubic-bezier(0.78, 0.14, 0.15, 0.86)",
    motionEaseOut: "cubic-bezier(0.215, 0.61, 0.355, 1)",
    motionEaseInOut: "cubic-bezier(0.645, 0.045, 0.355, 1)",
    motionEaseOutBack: "cubic-bezier(0.12, 0.4, 0.29, 1.46)",
    motionEaseInBack: "cubic-bezier(0.71, -0.46, 0.88, 0.6)",
    motionEaseInQuint: "cubic-bezier(0.755, 0.05, 0.855, 0.06)",
    motionEaseOutQuint: "cubic-bezier(0.23, 1, 0.32, 1)",
    // Radius
    borderRadius: 6,
    // Size
    sizeUnit: 4,
    sizeStep: 4,
    sizePopupArrow: 16,
    // Control Base
    controlHeight: 32,
    // zIndex
    zIndexBase: 0,
    zIndexPopupBase: 1e3,
    // Image
    opacityImage: 1,
    // Wireframe
    wireframe: false,
    // Motion
    motion: true
  });
  const seedToken$1 = seedToken;
  function genColorMapToken(seed, _ref) {
    let {
      generateColorPalettes: generateColorPalettes2,
      generateNeutralColorPalettes: generateNeutralColorPalettes2
    } = _ref;
    const {
      colorSuccess: colorSuccessBase,
      colorWarning: colorWarningBase,
      colorError: colorErrorBase,
      colorInfo: colorInfoBase,
      colorPrimary: colorPrimaryBase,
      colorBgBase,
      colorTextBase
    } = seed;
    const primaryColors = generateColorPalettes2(colorPrimaryBase);
    const successColors = generateColorPalettes2(colorSuccessBase);
    const warningColors = generateColorPalettes2(colorWarningBase);
    const errorColors = generateColorPalettes2(colorErrorBase);
    const infoColors = generateColorPalettes2(colorInfoBase);
    const neutralColors = generateNeutralColorPalettes2(colorBgBase, colorTextBase);
    return Object.assign(Object.assign({}, neutralColors), {
      colorPrimaryBg: primaryColors[1],
      colorPrimaryBgHover: primaryColors[2],
      colorPrimaryBorder: primaryColors[3],
      colorPrimaryBorderHover: primaryColors[4],
      colorPrimaryHover: primaryColors[5],
      colorPrimary: primaryColors[6],
      colorPrimaryActive: primaryColors[7],
      colorPrimaryTextHover: primaryColors[8],
      colorPrimaryText: primaryColors[9],
      colorPrimaryTextActive: primaryColors[10],
      colorSuccessBg: successColors[1],
      colorSuccessBgHover: successColors[2],
      colorSuccessBorder: successColors[3],
      colorSuccessBorderHover: successColors[4],
      colorSuccessHover: successColors[4],
      colorSuccess: successColors[6],
      colorSuccessActive: successColors[7],
      colorSuccessTextHover: successColors[8],
      colorSuccessText: successColors[9],
      colorSuccessTextActive: successColors[10],
      colorErrorBg: errorColors[1],
      colorErrorBgHover: errorColors[2],
      colorErrorBorder: errorColors[3],
      colorErrorBorderHover: errorColors[4],
      colorErrorHover: errorColors[5],
      colorError: errorColors[6],
      colorErrorActive: errorColors[7],
      colorErrorTextHover: errorColors[8],
      colorErrorText: errorColors[9],
      colorErrorTextActive: errorColors[10],
      colorWarningBg: warningColors[1],
      colorWarningBgHover: warningColors[2],
      colorWarningBorder: warningColors[3],
      colorWarningBorderHover: warningColors[4],
      colorWarningHover: warningColors[4],
      colorWarning: warningColors[6],
      colorWarningActive: warningColors[7],
      colorWarningTextHover: warningColors[8],
      colorWarningText: warningColors[9],
      colorWarningTextActive: warningColors[10],
      colorInfoBg: infoColors[1],
      colorInfoBgHover: infoColors[2],
      colorInfoBorder: infoColors[3],
      colorInfoBorderHover: infoColors[4],
      colorInfoHover: infoColors[4],
      colorInfo: infoColors[6],
      colorInfoActive: infoColors[7],
      colorInfoTextHover: infoColors[8],
      colorInfoText: infoColors[9],
      colorInfoTextActive: infoColors[10],
      colorBgMask: new TinyColor("#000").setAlpha(0.45).toRgbString(),
      colorWhite: "#fff"
    });
  }
  const genRadius = (radiusBase) => {
    let radiusLG = radiusBase;
    let radiusSM = radiusBase;
    let radiusXS = radiusBase;
    let radiusOuter = radiusBase;
    if (radiusBase < 6 && radiusBase >= 5) {
      radiusLG = radiusBase + 1;
    } else if (radiusBase < 16 && radiusBase >= 6) {
      radiusLG = radiusBase + 2;
    } else if (radiusBase >= 16) {
      radiusLG = 16;
    }
    if (radiusBase < 7 && radiusBase >= 5) {
      radiusSM = 4;
    } else if (radiusBase < 8 && radiusBase >= 7) {
      radiusSM = 5;
    } else if (radiusBase < 14 && radiusBase >= 8) {
      radiusSM = 6;
    } else if (radiusBase < 16 && radiusBase >= 14) {
      radiusSM = 7;
    } else if (radiusBase >= 16) {
      radiusSM = 8;
    }
    if (radiusBase < 6 && radiusBase >= 2) {
      radiusXS = 1;
    } else if (radiusBase >= 6) {
      radiusXS = 2;
    }
    if (radiusBase > 4 && radiusBase < 8) {
      radiusOuter = 4;
    } else if (radiusBase >= 8) {
      radiusOuter = 6;
    }
    return {
      borderRadius: radiusBase > 16 ? 16 : radiusBase,
      borderRadiusXS: radiusXS,
      borderRadiusSM: radiusSM,
      borderRadiusLG: radiusLG,
      borderRadiusOuter: radiusOuter
    };
  };
  const genRadius$1 = genRadius;
  function genCommonMapToken(token2) {
    const {
      motionUnit,
      motionBase,
      borderRadius,
      lineWidth
    } = token2;
    return Object.assign({
      // motion
      motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
      motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
      motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
      // line
      lineWidthBold: lineWidth + 1
    }, genRadius$1(borderRadius));
  }
  const getAlphaColor$2 = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
  const getSolidColor$1 = (baseColor, brightness) => {
    const instance = new TinyColor(baseColor);
    return instance.darken(brightness).toHexString();
  };
  const generateColorPalettes$1 = (baseColor) => {
    const colors = generate$1(baseColor);
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[4],
      6: colors[5],
      7: colors[6],
      8: colors[4],
      9: colors[5],
      10: colors[6]
      // 8: colors[7],
      // 9: colors[8],
      // 10: colors[9],
    };
  };
  const generateNeutralColorPalettes$1 = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#fff";
    const colorTextBase = textBaseColor || "#000";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor$2(colorTextBase, 0.88),
      colorTextSecondary: getAlphaColor$2(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor$2(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor$2(colorTextBase, 0.25),
      colorFill: getAlphaColor$2(colorTextBase, 0.15),
      colorFillSecondary: getAlphaColor$2(colorTextBase, 0.06),
      colorFillTertiary: getAlphaColor$2(colorTextBase, 0.04),
      colorFillQuaternary: getAlphaColor$2(colorTextBase, 0.02),
      colorBgLayout: getSolidColor$1(colorBgBase, 4),
      colorBgContainer: getSolidColor$1(colorBgBase, 0),
      colorBgElevated: getSolidColor$1(colorBgBase, 0),
      colorBgSpotlight: getAlphaColor$2(colorTextBase, 0.85),
      colorBorder: getSolidColor$1(colorBgBase, 15),
      colorBorderSecondary: getSolidColor$1(colorBgBase, 6)
    };
  };
  function getFontSizes(base) {
    const fontSizes = new Array(10).fill(null).map((_2, index2) => {
      const i = index2 - 1;
      const baseSize = base * Math.pow(2.71828, i / 5);
      const intSize = index2 > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
      return Math.floor(intSize / 2) * 2;
    });
    fontSizes[1] = base;
    return fontSizes.map((size) => {
      const height = size + 8;
      return {
        size,
        lineHeight: height / size
      };
    });
  }
  const genFontMapToken = (fontSize) => {
    const fontSizePairs = getFontSizes(fontSize);
    const fontSizes = fontSizePairs.map((pair) => pair.size);
    const lineHeights = fontSizePairs.map((pair) => pair.lineHeight);
    return {
      fontSizeSM: fontSizes[0],
      fontSize: fontSizes[1],
      fontSizeLG: fontSizes[2],
      fontSizeXL: fontSizes[3],
      fontSizeHeading1: fontSizes[6],
      fontSizeHeading2: fontSizes[5],
      fontSizeHeading3: fontSizes[4],
      fontSizeHeading4: fontSizes[3],
      fontSizeHeading5: fontSizes[2],
      lineHeight: lineHeights[1],
      lineHeightLG: lineHeights[2],
      lineHeightSM: lineHeights[0],
      lineHeightHeading1: lineHeights[6],
      lineHeightHeading2: lineHeights[5],
      lineHeightHeading3: lineHeights[4],
      lineHeightHeading4: lineHeights[3],
      lineHeightHeading5: lineHeights[2]
    };
  };
  const genFontMapToken$1 = genFontMapToken;
  function derivative$2(token2) {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = generate$1(token2[colorKey]);
      return new Array(10).fill(1).reduce((prev2, _2, i) => {
        prev2[`${colorKey}-${i + 1}`] = colors[i];
        prev2[`${colorKey}${i + 1}`] = colors[i];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = Object.assign(Object.assign({}, prev2), cur);
      return prev2;
    }, {});
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token2), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes: generateColorPalettes$1,
      generateNeutralColorPalettes: generateNeutralColorPalettes$1
    })), genFontMapToken$1(token2.fontSize)), genSizeMapToken$1(token2)), genControlHeight$1(token2)), genCommonMapToken(token2));
  }
  function isStableColor(color) {
    return color >= 0 && color <= 255;
  }
  function getAlphaColor$1(frontColor, backgroundColor) {
    const {
      r: fR,
      g: fG,
      b: fB,
      a: originAlpha
    } = new TinyColor(frontColor).toRgb();
    if (originAlpha < 1) {
      return frontColor;
    }
    const {
      r: bR,
      g: bG,
      b: bB
    } = new TinyColor(backgroundColor).toRgb();
    for (let fA = 0.01; fA <= 1; fA += 0.01) {
      const r2 = Math.round((fR - bR * (1 - fA)) / fA);
      const g2 = Math.round((fG - bG * (1 - fA)) / fA);
      const b2 = Math.round((fB - bB * (1 - fA)) / fA);
      if (isStableColor(r2) && isStableColor(g2) && isStableColor(b2)) {
        return new TinyColor({
          r: r2,
          g: g2,
          b: b2,
          a: Math.round(fA * 100) / 100
        }).toRgbString();
      }
    }
    return new TinyColor({
      r: fR,
      g: fG,
      b: fB,
      a: 1
    }).toRgbString();
  }
  var __rest$d = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function formatToken(derivativeToken) {
    const {
      override
    } = derivativeToken, restToken = __rest$d(derivativeToken, ["override"]);
    const overrideTokens = Object.assign({}, override);
    Object.keys(seedToken$1).forEach((token2) => {
      delete overrideTokens[token2];
    });
    const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
    const screenXS = 480;
    const screenSM = 576;
    const screenMD = 768;
    const screenLG = 992;
    const screenXL = 1200;
    const screenXXL = 1600;
    if (mergedToken.motion === false) {
      const fastDuration = "0s";
      mergedToken.motionDurationFast = fastDuration;
      mergedToken.motionDurationMid = fastDuration;
      mergedToken.motionDurationSlow = fastDuration;
    }
    const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
      colorLink: mergedToken.colorInfoText,
      colorLinkHover: mergedToken.colorInfoHover,
      colorLinkActive: mergedToken.colorInfoActive,
      // ============== Background ============== //
      colorFillContent: mergedToken.colorFillSecondary,
      colorFillContentHover: mergedToken.colorFill,
      colorFillAlter: mergedToken.colorFillQuaternary,
      colorBgContainerDisabled: mergedToken.colorFillTertiary,
      // ============== Split ============== //
      colorBorderBg: mergedToken.colorBgContainer,
      colorSplit: getAlphaColor$1(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
      // ============== Text ============== //
      colorTextPlaceholder: mergedToken.colorTextQuaternary,
      colorTextDisabled: mergedToken.colorTextQuaternary,
      colorTextHeading: mergedToken.colorText,
      colorTextLabel: mergedToken.colorTextSecondary,
      colorTextDescription: mergedToken.colorTextTertiary,
      colorTextLightSolid: mergedToken.colorWhite,
      colorHighlight: mergedToken.colorError,
      colorBgTextHover: mergedToken.colorFillSecondary,
      colorBgTextActive: mergedToken.colorFill,
      colorIcon: mergedToken.colorTextTertiary,
      colorIconHover: mergedToken.colorText,
      colorErrorOutline: getAlphaColor$1(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
      colorWarningOutline: getAlphaColor$1(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
      // Font
      fontSizeIcon: mergedToken.fontSizeSM,
      // Line
      lineWidthFocus: mergedToken.lineWidth * 4,
      // Control
      lineWidth: mergedToken.lineWidth,
      controlOutlineWidth: mergedToken.lineWidth * 2,
      // Checkbox size and expand icon size
      controlInteractiveSize: mergedToken.controlHeight / 2,
      controlItemBgHover: mergedToken.colorFillTertiary,
      controlItemBgActive: mergedToken.colorPrimaryBg,
      controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
      controlItemBgActiveDisabled: mergedToken.colorFill,
      controlTmpOutline: mergedToken.colorFillQuaternary,
      controlOutline: getAlphaColor$1(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
      lineType: mergedToken.lineType,
      borderRadius: mergedToken.borderRadius,
      borderRadiusXS: mergedToken.borderRadiusXS,
      borderRadiusSM: mergedToken.borderRadiusSM,
      borderRadiusLG: mergedToken.borderRadiusLG,
      fontWeightStrong: 600,
      opacityLoading: 0.65,
      linkDecoration: "none",
      linkHoverDecoration: "none",
      linkFocusDecoration: "none",
      controlPaddingHorizontal: 12,
      controlPaddingHorizontalSM: 8,
      paddingXXS: mergedToken.sizeXXS,
      paddingXS: mergedToken.sizeXS,
      paddingSM: mergedToken.sizeSM,
      padding: mergedToken.size,
      paddingMD: mergedToken.sizeMD,
      paddingLG: mergedToken.sizeLG,
      paddingXL: mergedToken.sizeXL,
      paddingContentHorizontalLG: mergedToken.sizeLG,
      paddingContentVerticalLG: mergedToken.sizeMS,
      paddingContentHorizontal: mergedToken.sizeMS,
      paddingContentVertical: mergedToken.sizeSM,
      paddingContentHorizontalSM: mergedToken.size,
      paddingContentVerticalSM: mergedToken.sizeXS,
      marginXXS: mergedToken.sizeXXS,
      marginXS: mergedToken.sizeXS,
      marginSM: mergedToken.sizeSM,
      margin: mergedToken.size,
      marginMD: mergedToken.sizeMD,
      marginLG: mergedToken.sizeLG,
      marginXL: mergedToken.sizeXL,
      marginXXL: mergedToken.sizeXXL,
      boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
      screenXS,
      screenXSMin: screenXS,
      screenXSMax: screenSM - 1,
      screenSM,
      screenSMMin: screenSM,
      screenSMMax: screenMD - 1,
      screenMD,
      screenMDMin: screenMD,
      screenMDMax: screenLG - 1,
      screenLG,
      screenLGMin: screenLG,
      screenLGMax: screenXL - 1,
      screenXL,
      screenXLMin: screenXL,
      screenXLMax: screenXXL - 1,
      screenXXL,
      screenXXLMin: screenXXL,
      boxShadowPopoverArrow: "2px 2px 5px rgba(0, 0, 0, 0.05)",
      boxShadowCard: `
      0 1px 2px -2px ${new TinyColor("rgba(0, 0, 0, 0.16)").toRgbString()},
      0 3px 6px 0 ${new TinyColor("rgba(0, 0, 0, 0.12)").toRgbString()},
      0 5px 12px 4px ${new TinyColor("rgba(0, 0, 0, 0.09)").toRgbString()}
    `,
      boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
      boxShadowTabsOverflowLeft: "inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowRight: "inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowTop: "inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)",
      boxShadowTabsOverflowBottom: "inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)"
    }), overrideTokens);
    return aliasToken;
  }
  function useEvent(callback) {
    var fnRef = React__namespace.useRef();
    fnRef.current = callback;
    var memoFn = React__namespace.useCallback(function() {
      var _fnRef$current;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
    }, []);
    return memoFn;
  }
  var useInternalLayoutEffect = canUseDom() ? React__namespace.useLayoutEffect : React__namespace.useEffect;
  var useLayoutEffect = function useLayoutEffect2(callback, deps) {
    var firstMountRef = React__namespace.useRef(true);
    useInternalLayoutEffect(function() {
      return callback(firstMountRef.current);
    }, deps);
    useInternalLayoutEffect(function() {
      firstMountRef.current = false;
      return function() {
        firstMountRef.current = true;
      };
    }, []);
  };
  var useLayoutUpdateEffect = function useLayoutUpdateEffect2(callback, deps) {
    useLayoutEffect(function(firstMount) {
      if (!firstMount) {
        return callback();
      }
    }, deps);
  };
  function useSafeState(defaultValue) {
    var destroyRef = React__namespace.useRef(false);
    var _React$useState = React__namespace.useState(defaultValue), _React$useState2 = _slicedToArray(_React$useState, 2), value = _React$useState2[0], setValue = _React$useState2[1];
    React__namespace.useEffect(function() {
      destroyRef.current = false;
      return function() {
        destroyRef.current = true;
      };
    }, []);
    function safeSetState(updater, ignoreDestroy) {
      if (ignoreDestroy && destroyRef.current) {
        return;
      }
      setValue(updater);
    }
    return [value, safeSetState];
  }
  function hasValue(value) {
    return value !== void 0;
  }
  function useMergedState(defaultStateValue, option) {
    var _ref = option || {}, defaultValue = _ref.defaultValue, value = _ref.value, onChange = _ref.onChange, postState = _ref.postState;
    var _useState = useSafeState(function() {
      if (hasValue(value)) {
        return value;
      } else if (hasValue(defaultValue)) {
        return typeof defaultValue === "function" ? defaultValue() : defaultValue;
      } else {
        return typeof defaultStateValue === "function" ? defaultStateValue() : defaultStateValue;
      }
    }), _useState2 = _slicedToArray(_useState, 2), innerValue = _useState2[0], setInnerValue = _useState2[1];
    var mergedValue = value !== void 0 ? value : innerValue;
    var postMergedValue = postState ? postState(mergedValue) : mergedValue;
    var onChangeFn = useEvent(onChange);
    var _useState3 = useSafeState([mergedValue]), _useState4 = _slicedToArray(_useState3, 2), prevValue = _useState4[0], setPrevValue = _useState4[1];
    useLayoutUpdateEffect(function() {
      var prev2 = prevValue[0];
      if (innerValue !== prev2) {
        onChangeFn(innerValue, prev2);
      }
    }, [prevValue]);
    useLayoutUpdateEffect(function() {
      if (!hasValue(value)) {
        setInnerValue(value);
      }
    }, [value]);
    var triggerChange = useEvent(function(updater, ignoreDestroy) {
      setInnerValue(updater, ignoreDestroy);
      setPrevValue([mergedValue], ignoreDestroy);
    });
    return [postMergedValue, triggerChange];
  }
  const defaultIconPrefixCls = "anticon";
  const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
    if (customizePrefixCls)
      return customizePrefixCls;
    return suffixCls ? `ant-${suffixCls}` : "ant";
  };
  const ConfigContext = /* @__PURE__ */ React__namespace.createContext({
    // We provide a default function for Context without provider
    getPrefixCls: defaultGetPrefixCls,
    iconPrefixCls: defaultIconPrefixCls
  });
  const roundedArrow = (width, innerRadius, outerRadius, bgColor, boxShadow) => {
    const unitWidth = width / 2;
    const ax = 0;
    const ay = unitWidth;
    const bx = outerRadius * 1 / Math.sqrt(2);
    const by = unitWidth - outerRadius * (1 - 1 / Math.sqrt(2));
    const cx = unitWidth - innerRadius * (1 / Math.sqrt(2));
    const cy = outerRadius * (Math.sqrt(2) - 1) + innerRadius * (1 / Math.sqrt(2));
    const dx = 2 * unitWidth - cx;
    const dy = cy;
    const ex = 2 * unitWidth - bx;
    const ey = by;
    const fx = 2 * unitWidth - ax;
    const fy = ay;
    const shadowWidth = unitWidth * Math.sqrt(2) + outerRadius * (Math.sqrt(2) - 2);
    const polygonOffset = outerRadius * (Math.sqrt(2) - 1);
    return {
      pointerEvents: "none",
      width,
      height: width,
      overflow: "hidden",
      "&::before": {
        position: "absolute",
        bottom: 0,
        insetInlineStart: 0,
        width,
        height: width / 2,
        background: bgColor,
        clipPath: {
          _multi_value_: true,
          value: [`polygon(${polygonOffset}px 100%, 50% ${polygonOffset}px, ${2 * unitWidth - polygonOffset}px 100%, ${polygonOffset}px 100%)`, `path('M ${ax} ${ay} A ${outerRadius} ${outerRadius} 0 0 0 ${bx} ${by} L ${cx} ${cy} A ${innerRadius} ${innerRadius} 0 0 1 ${dx} ${dy} L ${ex} ${ey} A ${outerRadius} ${outerRadius} 0 0 0 ${fx} ${fy} Z')`]
        },
        content: '""'
      },
      "&::after": {
        content: '""',
        position: "absolute",
        width: shadowWidth,
        height: shadowWidth,
        bottom: 0,
        insetInline: 0,
        margin: "auto",
        borderRadius: {
          _skip_check_: true,
          value: `0 0 ${innerRadius}px 0`
        },
        transform: "translateY(50%) rotate(-135deg)",
        boxShadow,
        zIndex: 0,
        background: "transparent"
      }
    };
  };
  const resetComponent = (token2) => ({
    boxSizing: "border-box",
    margin: 0,
    padding: 0,
    color: token2.colorText,
    fontSize: token2.fontSize,
    // font-variant: @font-variant-base;
    lineHeight: token2.lineHeight,
    listStyle: "none",
    // font-feature-settings: @font-feature-settings-base;
    fontFamily: token2.fontFamily
  });
  const resetIcon = () => ({
    display: "inline-flex",
    alignItems: "center",
    color: "inherit",
    fontStyle: "normal",
    lineHeight: 0,
    textAlign: "center",
    textTransform: "none",
    // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
    verticalAlign: "-0.125em",
    textRendering: "optimizeLegibility",
    "-webkit-font-smoothing": "antialiased",
    "-moz-osx-font-smoothing": "grayscale",
    "> *": {
      lineHeight: 1
    },
    svg: {
      display: "inline-block"
    }
  });
  const clearFix = () => ({
    // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
    "&::before": {
      display: "table",
      content: '""'
    },
    "&::after": {
      // https://github.com/ant-design/ant-design/issues/21864
      display: "table",
      clear: "both",
      content: '""'
    }
  });
  const genLinkStyle = (token2) => ({
    a: {
      color: token2.colorLink,
      textDecoration: token2.linkDecoration,
      backgroundColor: "transparent",
      outline: "none",
      cursor: "pointer",
      transition: `color ${token2.motionDurationSlow}`,
      "-webkit-text-decoration-skip": "objects",
      "&:hover": {
        color: token2.colorLinkHover
      },
      "&:active": {
        color: token2.colorLinkActive
      },
      [`&:active,
  &:hover`]: {
        textDecoration: token2.linkHoverDecoration,
        outline: 0
      },
      // https://github.com/ant-design/ant-design/issues/22503
      "&:focus": {
        textDecoration: token2.linkFocusDecoration,
        outline: 0
      },
      "&[disabled]": {
        color: token2.colorTextDisabled,
        cursor: "not-allowed"
      }
    }
  });
  const genCommonStyle = (token2, componentPrefixCls) => {
    const {
      fontFamily,
      fontSize
    } = token2;
    const rootPrefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
    return {
      [rootPrefixSelector]: {
        fontFamily,
        fontSize,
        boxSizing: "border-box",
        "&::before, &::after": {
          boxSizing: "border-box"
        },
        [rootPrefixSelector]: {
          boxSizing: "border-box",
          "&::before, &::after": {
            boxSizing: "border-box"
          }
        }
      }
    };
  };
  const genFocusOutline = (token2) => ({
    outline: `${token2.lineWidthFocus}px solid ${token2.colorPrimaryBorder}`,
    outlineOffset: 1,
    transition: "outline-offset 0s, outline 0s"
  });
  const genFocusStyle = (token2) => ({
    "&:focus-visible": Object.assign({}, genFocusOutline(token2))
  });
  function genComponentStyleHook(component, styleFn, getDefaultToken, options) {
    return (prefixCls) => {
      const [theme2, token2, hashId] = useToken$2();
      const {
        getPrefixCls,
        iconPrefixCls,
        csp
      } = React.useContext(ConfigContext);
      const rootPrefixCls = getPrefixCls();
      const sharedConfig = {
        theme: theme2,
        token: token2,
        hashId,
        nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
      };
      useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
        path: ["Shared", rootPrefixCls]
      }), () => [{
        // Link
        "&": genLinkStyle(token2)
      }]);
      return [useStyleRegister(Object.assign(Object.assign({}, sharedConfig), {
        path: [component, prefixCls, iconPrefixCls]
      }), () => {
        const {
          token: proxyToken,
          flush
        } = statisticToken(token2);
        const customComponentToken = Object.assign({}, token2[component]);
        if (options === null || options === void 0 ? void 0 : options.deprecatedTokens) {
          const {
            deprecatedTokens
          } = options;
          deprecatedTokens.forEach((_ref) => {
            let [oldTokenKey, newTokenKey] = _ref;
            var _a2;
            if ((customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey]) || (customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[newTokenKey])) {
              (_a2 = customComponentToken[newTokenKey]) !== null && _a2 !== void 0 ? _a2 : customComponentToken[newTokenKey] = customComponentToken === null || customComponentToken === void 0 ? void 0 : customComponentToken[oldTokenKey];
            }
          });
        }
        const defaultComponentToken = typeof getDefaultToken === "function" ? getDefaultToken(merge$1(proxyToken, customComponentToken !== null && customComponentToken !== void 0 ? customComponentToken : {})) : getDefaultToken;
        const mergedComponentToken = Object.assign(Object.assign({}, defaultComponentToken), customComponentToken);
        const componentCls = `.${prefixCls}`;
        const mergedToken = merge$1(proxyToken, {
          componentCls,
          prefixCls,
          iconCls: `.${iconPrefixCls}`,
          antCls: `.${rootPrefixCls}`
        }, mergedComponentToken);
        const styleInterpolation = styleFn(mergedToken, {
          hashId,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls,
          overrideComponentToken: customComponentToken
        });
        flush(component, mergedComponentToken);
        return [(options === null || options === void 0 ? void 0 : options.resetStyle) === false ? null : genCommonStyle(token2, prefixCls), styleInterpolation];
      }), hashId];
    };
  }
  const enableStatistic = typeof CSSINJS_STATISTIC !== "undefined";
  let recording = true;
  function merge$1() {
    for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
      objs[_key] = arguments[_key];
    }
    if (!enableStatistic) {
      return Object.assign.apply(Object, [{}].concat(objs));
    }
    recording = false;
    const ret = {};
    objs.forEach((obj) => {
      const keys2 = Object.keys(obj);
      keys2.forEach((key) => {
        Object.defineProperty(ret, key, {
          configurable: true,
          enumerable: true,
          get: () => obj[key]
        });
      });
    });
    recording = true;
    return ret;
  }
  function noop$2() {
  }
  function statisticToken(token2) {
    let tokenKeys2;
    let proxy = token2;
    let flush = noop$2;
    if (enableStatistic) {
      tokenKeys2 = /* @__PURE__ */ new Set();
      proxy = new Proxy(token2, {
        get(obj, prop) {
          if (recording) {
            tokenKeys2.add(prop);
          }
          return obj[prop];
        }
      });
      flush = (componentName, componentToken) => {
        ({
          global: Array.from(tokenKeys2),
          component: componentToken
        });
      };
    }
    return {
      token: proxy,
      keys: tokenKeys2,
      flush
    };
  }
  function genPresetColor(token2, genCss) {
    return PresetColors.reduce((prev2, colorKey) => {
      const lightColor = token2[`${colorKey}1`];
      const lightBorderColor = token2[`${colorKey}3`];
      const darkColor = token2[`${colorKey}6`];
      const textColor = token2[`${colorKey}7`];
      return Object.assign(Object.assign({}, prev2), genCss(colorKey, {
        lightColor,
        lightBorderColor,
        darkColor,
        textColor
      }));
    }, {});
  }
  const defaultTheme = createTheme(derivative$2);
  const defaultConfig = {
    token: seedToken$1,
    hashed: true
  };
  const DesignTokenContext = /* @__PURE__ */ React.createContext(defaultConfig);
  function useToken$2() {
    const {
      token: rootDesignToken,
      hashed,
      theme: theme2,
      components
    } = React.useContext(DesignTokenContext);
    const salt = `${version$1}-${hashed || ""}`;
    const mergedTheme = theme2 || defaultTheme;
    const [token2, hashId] = useCacheToken(mergedTheme, [seedToken$1, rootDesignToken], {
      salt,
      override: Object.assign({
        override: rootDesignToken
      }, components),
      formatToken
    });
    return [mergedTheme, token2, hashed ? hashId : ""];
  }
  const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
  function getStyle(globalPrefixCls2, theme2) {
    const variables = {};
    const formatColor = (color, updater) => {
      let clone = color.clone();
      clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
      return clone.toRgbString();
    };
    const fillColor = (colorVal, type4) => {
      const baseColor = new TinyColor(colorVal);
      const colorPalettes = generate$1(baseColor.toRgbString());
      variables[`${type4}-color`] = formatColor(baseColor);
      variables[`${type4}-color-disabled`] = colorPalettes[1];
      variables[`${type4}-color-hover`] = colorPalettes[4];
      variables[`${type4}-color-active`] = colorPalettes[6];
      variables[`${type4}-color-outline`] = baseColor.clone().setAlpha(0.2).toRgbString();
      variables[`${type4}-color-deprecated-bg`] = colorPalettes[0];
      variables[`${type4}-color-deprecated-border`] = colorPalettes[2];
    };
    if (theme2.primaryColor) {
      fillColor(theme2.primaryColor, "primary");
      const primaryColor = new TinyColor(theme2.primaryColor);
      const primaryColors = generate$1(primaryColor.toRgbString());
      primaryColors.forEach((color, index2) => {
        variables[`primary-${index2 + 1}`] = color;
      });
      variables["primary-color-deprecated-l-35"] = formatColor(primaryColor, (c2) => c2.lighten(35));
      variables["primary-color-deprecated-l-20"] = formatColor(primaryColor, (c2) => c2.lighten(20));
      variables["primary-color-deprecated-t-20"] = formatColor(primaryColor, (c2) => c2.tint(20));
      variables["primary-color-deprecated-t-50"] = formatColor(primaryColor, (c2) => c2.tint(50));
      variables["primary-color-deprecated-f-12"] = formatColor(primaryColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.12));
      const primaryActiveColor = new TinyColor(primaryColors[0]);
      variables["primary-color-active-deprecated-f-30"] = formatColor(primaryActiveColor, (c2) => c2.setAlpha(c2.getAlpha() * 0.3));
      variables["primary-color-active-deprecated-d-02"] = formatColor(primaryActiveColor, (c2) => c2.darken(2));
    }
    if (theme2.successColor) {
      fillColor(theme2.successColor, "success");
    }
    if (theme2.warningColor) {
      fillColor(theme2.warningColor, "warning");
    }
    if (theme2.errorColor) {
      fillColor(theme2.errorColor, "error");
    }
    if (theme2.infoColor) {
      fillColor(theme2.infoColor, "info");
    }
    const cssList = Object.keys(variables).map((key) => `--${globalPrefixCls2}-${key}: ${variables[key]};`);
    return `
  :root {
    ${cssList.join("\n")}
  }
  `.trim();
  }
  function registerTheme(globalPrefixCls2, theme2) {
    const style2 = getStyle(globalPrefixCls2, theme2);
    if (canUseDom()) {
      updateCSS(style2, `${dynamicStyleMark}-dynamic-theme`);
    }
  }
  const DisabledContext = /* @__PURE__ */ React__namespace.createContext(false);
  const DisabledContextProvider = (_ref) => {
    let {
      children,
      disabled
    } = _ref;
    const originDisabled = React__namespace.useContext(DisabledContext);
    return /* @__PURE__ */ React__namespace.createElement(DisabledContext.Provider, {
      value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
    }, children);
  };
  const DisabledContext$1 = DisabledContext;
  const useSize = (customSize) => {
    const size = React.useContext(SizeContext$1);
    const mergedSize = React.useMemo(() => {
      if (!customSize) {
        return size;
      }
      if (typeof customSize === "string") {
        return customSize !== null && customSize !== void 0 ? customSize : size;
      }
      if (customSize instanceof Function) {
        return customSize(size);
      }
      return size;
    }, [customSize, size]);
    return mergedSize;
  };
  const useSize$1 = useSize;
  const SizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const SizeContextProvider = (_ref) => {
    let {
      children,
      size
    } = _ref;
    const mergedSize = useSize$1(size);
    return /* @__PURE__ */ React__namespace.createElement(SizeContext.Provider, {
      value: mergedSize
    }, children);
  };
  const SizeContext$1 = SizeContext;
  function useConfig() {
    const componentDisabled = React.useContext(DisabledContext$1);
    const componentSize = React.useContext(SizeContext$1);
    return {
      componentDisabled,
      componentSize
    };
  }
  function useTheme(theme2, parentTheme) {
    const themeConfig = theme2 || {};
    const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? defaultConfig : parentTheme;
    const mergedTheme = useMemo(() => {
      if (!theme2) {
        return parentTheme;
      }
      const mergedComponents = Object.assign({}, parentThemeConfig.components);
      Object.keys(theme2.components || {}).forEach((componentName) => {
        mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme2.components[componentName]);
      });
      return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
        token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
        components: mergedComponents
      });
    }, [themeConfig, parentThemeConfig], (prev2, next2) => prev2.some((prevTheme, index2) => {
      const nextTheme = next2[index2];
      return !isEqual$1(prevTheme, nextTheme, true);
    }));
    return mergedTheme;
  }
  var _excluded$8 = ["children"];
  var Context$1 = /* @__PURE__ */ React__namespace.createContext({});
  function MotionProvider(_ref) {
    var children = _ref.children, props = _objectWithoutProperties(_ref, _excluded$8);
    return /* @__PURE__ */ React__namespace.createElement(Context$1.Provider, {
      value: props
    }, children);
  }
  var DomWrapper = /* @__PURE__ */ function(_React$Component) {
    _inherits(DomWrapper2, _React$Component);
    var _super = _createSuper(DomWrapper2);
    function DomWrapper2() {
      _classCallCheck(this, DomWrapper2);
      return _super.apply(this, arguments);
    }
    _createClass$1(DomWrapper2, [{
      key: "render",
      value: function render2() {
        return this.props.children;
      }
    }]);
    return DomWrapper2;
  }(React__namespace.Component);
  var STATUS_NONE = "none";
  var STATUS_APPEAR = "appear";
  var STATUS_ENTER = "enter";
  var STATUS_LEAVE = "leave";
  var STEP_NONE = "none";
  var STEP_PREPARE = "prepare";
  var STEP_START = "start";
  var STEP_ACTIVE = "active";
  var STEP_ACTIVATED = "end";
  var STEP_PREPARED = "prepared";
  function makePrefixMap(styleProp, eventName) {
    var prefixes = {};
    prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
    prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
    prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
    prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
    prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
    return prefixes;
  }
  function getVendorPrefixes(domSupport, win) {
    var prefixes = {
      animationend: makePrefixMap("Animation", "AnimationEnd"),
      transitionend: makePrefixMap("Transition", "TransitionEnd")
    };
    if (domSupport) {
      if (!("AnimationEvent" in win)) {
        delete prefixes.animationend.animation;
      }
      if (!("TransitionEvent" in win)) {
        delete prefixes.transitionend.transition;
      }
    }
    return prefixes;
  }
  var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== "undefined" ? window : {});
  var style = {};
  if (canUseDom()) {
    var _document$createEleme = document.createElement("div");
    style = _document$createEleme.style;
  }
  var prefixedEventNames = {};
  function getVendorPrefixedEventName(eventName) {
    if (prefixedEventNames[eventName]) {
      return prefixedEventNames[eventName];
    }
    var prefixMap = vendorPrefixes[eventName];
    if (prefixMap) {
      var stylePropList = Object.keys(prefixMap);
      var len = stylePropList.length;
      for (var i = 0; i < len; i += 1) {
        var styleProp = stylePropList[i];
        if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
          prefixedEventNames[eventName] = prefixMap[styleProp];
          return prefixedEventNames[eventName];
        }
      }
    }
    return "";
  }
  var internalAnimationEndName = getVendorPrefixedEventName("animationend");
  var internalTransitionEndName = getVendorPrefixedEventName("transitionend");
  var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
  var animationEndName = internalAnimationEndName || "animationend";
  var transitionEndName = internalTransitionEndName || "transitionend";
  function getTransitionName$1(transitionName, transitionType) {
    if (!transitionName)
      return null;
    if (_typeof(transitionName) === "object") {
      var type4 = transitionType.replace(/-\w/g, function(match2) {
        return match2[1].toUpperCase();
      });
      return transitionName[type4];
    }
    return "".concat(transitionName, "-").concat(transitionType);
  }
  const useDomMotionEvents = function(callback) {
    var cacheElementRef = React.useRef();
    var callbackRef = React.useRef(callback);
    callbackRef.current = callback;
    var onInternalMotionEnd = React__namespace.useCallback(function(event) {
      callbackRef.current(event);
    }, []);
    function removeMotionEvents(element) {
      if (element) {
        element.removeEventListener(transitionEndName, onInternalMotionEnd);
        element.removeEventListener(animationEndName, onInternalMotionEnd);
      }
    }
    function patchMotionEvents(element) {
      if (cacheElementRef.current && cacheElementRef.current !== element) {
        removeMotionEvents(cacheElementRef.current);
      }
      if (element && element !== cacheElementRef.current) {
        element.addEventListener(transitionEndName, onInternalMotionEnd);
        element.addEventListener(animationEndName, onInternalMotionEnd);
        cacheElementRef.current = element;
      }
    }
    React__namespace.useEffect(function() {
      return function() {
        removeMotionEvents(cacheElementRef.current);
      };
    }, []);
    return [patchMotionEvents, removeMotionEvents];
  };
  var useIsomorphicLayoutEffect = canUseDom() ? React.useLayoutEffect : React.useEffect;
  const useNextFrame = function() {
    var nextFrameRef = React__namespace.useRef(null);
    function cancelNextFrame() {
      wrapperRaf.cancel(nextFrameRef.current);
    }
    function nextFrame(callback) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
      cancelNextFrame();
      var nextFrameId = wrapperRaf(function() {
        if (delay <= 1) {
          callback({
            isCanceled: function isCanceled() {
              return nextFrameId !== nextFrameRef.current;
            }
          });
        } else {
          nextFrame(callback, delay - 1);
        }
      });
      nextFrameRef.current = nextFrameId;
    }
    React__namespace.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [nextFrame, cancelNextFrame];
  };
  var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
  var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];
  var SkipStep = false;
  var DoStep = true;
  function isActive(step) {
    return step === STEP_ACTIVE || step === STEP_ACTIVATED;
  }
  const useStepQueue = function(status, prepareOnly, callback) {
    var _useState = useSafeState(STEP_NONE), _useState2 = _slicedToArray(_useState, 2), step = _useState2[0], setStep = _useState2[1];
    var _useNextFrame = useNextFrame(), _useNextFrame2 = _slicedToArray(_useNextFrame, 2), nextFrame = _useNextFrame2[0], cancelNextFrame = _useNextFrame2[1];
    function startQueue() {
      setStep(STEP_PREPARE, true);
    }
    var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
    useIsomorphicLayoutEffect(function() {
      if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
        var index2 = STEP_QUEUE.indexOf(step);
        var nextStep = STEP_QUEUE[index2 + 1];
        var result = callback(step);
        if (result === SkipStep) {
          setStep(nextStep, true);
        } else if (nextStep) {
          nextFrame(function(info) {
            function doNext() {
              if (info.isCanceled())
                return;
              setStep(nextStep, true);
            }
            if (result === true) {
              doNext();
            } else {
              Promise.resolve(result).then(doNext);
            }
          });
        }
      }
    }, [status, step]);
    React__namespace.useEffect(function() {
      return function() {
        cancelNextFrame();
      };
    }, []);
    return [startQueue, step];
  };
  function useStatus(supportMotion, visible, getElement, _ref) {
    var _ref$motionEnter = _ref.motionEnter, motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter, _ref$motionAppear = _ref.motionAppear, motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear, _ref$motionLeave = _ref.motionLeave, motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave, motionDeadline = _ref.motionDeadline, motionLeaveImmediately = _ref.motionLeaveImmediately, onAppearPrepare = _ref.onAppearPrepare, onEnterPrepare = _ref.onEnterPrepare, onLeavePrepare = _ref.onLeavePrepare, onAppearStart = _ref.onAppearStart, onEnterStart = _ref.onEnterStart, onLeaveStart = _ref.onLeaveStart, onAppearActive = _ref.onAppearActive, onEnterActive = _ref.onEnterActive, onLeaveActive = _ref.onLeaveActive, onAppearEnd = _ref.onAppearEnd, onEnterEnd = _ref.onEnterEnd, onLeaveEnd = _ref.onLeaveEnd, onVisibleChanged = _ref.onVisibleChanged;
    var _useState = useSafeState(), _useState2 = _slicedToArray(_useState, 2), asyncVisible = _useState2[0], setAsyncVisible = _useState2[1];
    var _useState3 = useSafeState(STATUS_NONE), _useState4 = _slicedToArray(_useState3, 2), status = _useState4[0], setStatus = _useState4[1];
    var _useState5 = useSafeState(null), _useState6 = _slicedToArray(_useState5, 2), style2 = _useState6[0], setStyle = _useState6[1];
    var mountedRef = React.useRef(false);
    var deadlineRef = React.useRef(null);
    function getDomElement() {
      return getElement();
    }
    var activeRef = React.useRef(false);
    function updateMotionEndStatus() {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
    function onInternalMotionEnd(event) {
      var element = getDomElement();
      if (event && !event.deadline && event.target !== element) {
        return;
      }
      var currentActive = activeRef.current;
      var canEnd;
      if (status === STATUS_APPEAR && currentActive) {
        canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
      } else if (status === STATUS_ENTER && currentActive) {
        canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
      } else if (status === STATUS_LEAVE && currentActive) {
        canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
      }
      if (status !== STATUS_NONE && currentActive && canEnd !== false) {
        updateMotionEndStatus();
      }
    }
    var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd), _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1), patchMotionEvents = _useDomMotionEvents2[0];
    var getEventHandlers = function getEventHandlers2(targetStatus) {
      var _ref2, _ref3, _ref4;
      switch (targetStatus) {
        case STATUS_APPEAR:
          return _ref2 = {}, _defineProperty(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty(_ref2, STEP_START, onAppearStart), _defineProperty(_ref2, STEP_ACTIVE, onAppearActive), _ref2;
        case STATUS_ENTER:
          return _ref3 = {}, _defineProperty(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty(_ref3, STEP_START, onEnterStart), _defineProperty(_ref3, STEP_ACTIVE, onEnterActive), _ref3;
        case STATUS_LEAVE:
          return _ref4 = {}, _defineProperty(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty(_ref4, STEP_START, onLeaveStart), _defineProperty(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;
        default:
          return {};
      }
    };
    var eventHandlers = React__namespace.useMemo(function() {
      return getEventHandlers(status);
    }, [status]);
    var _useStepQueue = useStepQueue(status, !supportMotion, function(newStep) {
      if (newStep === STEP_PREPARE) {
        var onPrepare = eventHandlers[STEP_PREPARE];
        if (!onPrepare) {
          return SkipStep;
        }
        return onPrepare(getDomElement());
      }
      if (step in eventHandlers) {
        var _eventHandlers$step;
        setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
      }
      if (step === STEP_ACTIVE) {
        patchMotionEvents(getDomElement());
        if (motionDeadline > 0) {
          clearTimeout(deadlineRef.current);
          deadlineRef.current = setTimeout(function() {
            onInternalMotionEnd({
              deadline: true
            });
          }, motionDeadline);
        }
      }
      if (step === STEP_PREPARED) {
        updateMotionEndStatus();
      }
      return DoStep;
    }), _useStepQueue2 = _slicedToArray(_useStepQueue, 2), startStep = _useStepQueue2[0], step = _useStepQueue2[1];
    var active = isActive(step);
    activeRef.current = active;
    useIsomorphicLayoutEffect(function() {
      setAsyncVisible(visible);
      var isMounted = mountedRef.current;
      mountedRef.current = true;
      var nextStatus;
      if (!isMounted && visible && motionAppear) {
        nextStatus = STATUS_APPEAR;
      }
      if (isMounted && visible && motionEnter) {
        nextStatus = STATUS_ENTER;
      }
      if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
        nextStatus = STATUS_LEAVE;
      }
      var nextEventHandlers = getEventHandlers(nextStatus);
      if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
        setStatus(nextStatus);
        startStep();
      } else {
        setStatus(STATUS_NONE);
      }
    }, [visible]);
    React.useEffect(function() {
      if (
        // Cancel appear
        status === STATUS_APPEAR && !motionAppear || // Cancel enter
        status === STATUS_ENTER && !motionEnter || // Cancel leave
        status === STATUS_LEAVE && !motionLeave
      ) {
        setStatus(STATUS_NONE);
      }
    }, [motionAppear, motionEnter, motionLeave]);
    React.useEffect(function() {
      return function() {
        mountedRef.current = false;
        clearTimeout(deadlineRef.current);
      };
    }, []);
    var firstMountChangeRef = React__namespace.useRef(false);
    React.useEffect(function() {
      if (asyncVisible) {
        firstMountChangeRef.current = true;
      }
      if (asyncVisible !== void 0 && status === STATUS_NONE) {
        if (firstMountChangeRef.current || asyncVisible) {
          onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
        }
        firstMountChangeRef.current = true;
      }
    }, [asyncVisible, status]);
    var mergedStyle = style2;
    if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
      mergedStyle = _objectSpread2({
        transition: "none"
      }, mergedStyle);
    }
    return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
  }
  function genCSSMotion(config) {
    var transitionSupport = config;
    if (_typeof(config) === "object") {
      transitionSupport = config.transitionSupport;
    }
    function isSupportTransition(props, contextMotion) {
      return !!(props.motionName && transitionSupport && contextMotion !== false);
    }
    var CSSMotion2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
      var _props$visible = props.visible, visible = _props$visible === void 0 ? true : _props$visible, _props$removeOnLeave = props.removeOnLeave, removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave, forceRender = props.forceRender, children = props.children, motionName = props.motionName, leavedClassName = props.leavedClassName, eventProps = props.eventProps;
      var _React$useContext = React__namespace.useContext(Context$1), contextMotion = _React$useContext.motion;
      var supportMotion = isSupportTransition(props, contextMotion);
      var nodeRef = React.useRef();
      var wrapperNodeRef = React.useRef();
      function getDomElement() {
        try {
          return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
        } catch (e2) {
          return null;
        }
      }
      var _useStatus = useStatus(supportMotion, visible, getDomElement, props), _useStatus2 = _slicedToArray(_useStatus, 4), status = _useStatus2[0], statusStep = _useStatus2[1], statusStyle = _useStatus2[2], mergedVisible = _useStatus2[3];
      var renderedRef = React__namespace.useRef(mergedVisible);
      if (mergedVisible) {
        renderedRef.current = true;
      }
      var setNodeRef = React__namespace.useCallback(function(node2) {
        nodeRef.current = node2;
        fillRef(ref, node2);
      }, [ref]);
      var motionChildren;
      var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
        visible
      });
      if (!children) {
        motionChildren = null;
      } else if (status === STATUS_NONE) {
        if (mergedVisible) {
          motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
        } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: leavedClassName
          }), setNodeRef);
        } else if (forceRender || !removeOnLeave && !leavedClassName) {
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            style: {
              display: "none"
            }
          }), setNodeRef);
        } else {
          motionChildren = null;
        }
      } else {
        var _classNames;
        var statusSuffix;
        if (statusStep === STEP_PREPARE) {
          statusSuffix = "prepare";
        } else if (isActive(statusStep)) {
          statusSuffix = "active";
        } else if (statusStep === STEP_START) {
          statusSuffix = "start";
        }
        var motionCls = getTransitionName$1(motionName, "".concat(status, "-").concat(statusSuffix));
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: classNames(getTransitionName$1(motionName, status), (_classNames = {}, _defineProperty(_classNames, motionCls, motionCls && statusSuffix), _defineProperty(_classNames, motionName, typeof motionName === "string"), _classNames)),
          style: statusStyle
        }), setNodeRef);
      }
      if (/* @__PURE__ */ React__namespace.isValidElement(motionChildren) && supportRef(motionChildren)) {
        var _ref = motionChildren, originNodeRef = _ref.ref;
        if (!originNodeRef) {
          motionChildren = /* @__PURE__ */ React__namespace.cloneElement(motionChildren, {
            ref: setNodeRef
          });
        }
      }
      return /* @__PURE__ */ React__namespace.createElement(DomWrapper, {
        ref: wrapperNodeRef
      }, motionChildren);
    });
    CSSMotion2.displayName = "CSSMotion";
    return CSSMotion2;
  }
  const CSSMotion = genCSSMotion(supportTransition);
  var STATUS_ADD = "add";
  var STATUS_KEEP = "keep";
  var STATUS_REMOVE = "remove";
  var STATUS_REMOVED = "removed";
  function wrapKeyToObject(key) {
    var keyObj;
    if (key && _typeof(key) === "object" && "key" in key) {
      keyObj = key;
    } else {
      keyObj = {
        key
      };
    }
    return _objectSpread2(_objectSpread2({}, keyObj), {}, {
      key: String(keyObj.key)
    });
  }
  function parseKeys() {
    var keys2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return keys2.map(wrapKeyToObject);
  }
  function diffKeys() {
    var prevKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var currentKeys = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var list = [];
    var currentIndex = 0;
    var currentLen = currentKeys.length;
    var prevKeyObjects = parseKeys(prevKeys);
    var currentKeyObjects = parseKeys(currentKeys);
    prevKeyObjects.forEach(function(keyObj) {
      var hit = false;
      for (var i = currentIndex; i < currentLen; i += 1) {
        var currentKeyObj = currentKeyObjects[i];
        if (currentKeyObj.key === keyObj.key) {
          if (currentIndex < i) {
            list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function(obj) {
              return _objectSpread2(_objectSpread2({}, obj), {}, {
                status: STATUS_ADD
              });
            }));
            currentIndex = i;
          }
          list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
            status: STATUS_KEEP
          }));
          currentIndex += 1;
          hit = true;
          break;
        }
      }
      if (!hit) {
        list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
          status: STATUS_REMOVE
        }));
      }
    });
    if (currentIndex < currentLen) {
      list = list.concat(currentKeyObjects.slice(currentIndex).map(function(obj) {
        return _objectSpread2(_objectSpread2({}, obj), {}, {
          status: STATUS_ADD
        });
      }));
    }
    var keys2 = {};
    list.forEach(function(_ref) {
      var key = _ref.key;
      keys2[key] = (keys2[key] || 0) + 1;
    });
    var duplicatedKeys = Object.keys(keys2).filter(function(key) {
      return keys2[key] > 1;
    });
    duplicatedKeys.forEach(function(matchKey) {
      list = list.filter(function(_ref2) {
        var key = _ref2.key, status = _ref2.status;
        return key !== matchKey || status !== STATUS_REMOVE;
      });
      list.forEach(function(node2) {
        if (node2.key === matchKey) {
          node2.status = STATUS_KEEP;
        }
      });
    });
    return list;
  }
  var _excluded$7 = ["component", "children", "onVisibleChanged", "onAllRemoved"], _excluded2 = ["status"];
  var MOTION_PROP_NAMES = ["eventProps", "visible", "children", "motionName", "motionAppear", "motionEnter", "motionLeave", "motionLeaveImmediately", "motionDeadline", "removeOnLeave", "leavedClassName", "onAppearStart", "onAppearActive", "onAppearEnd", "onEnterStart", "onEnterActive", "onEnterEnd", "onLeaveStart", "onLeaveActive", "onLeaveEnd"];
  function genCSSMotionList(transitionSupport) {
    var CSSMotion$1 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : CSSMotion;
    var CSSMotionList = /* @__PURE__ */ function(_React$Component) {
      _inherits(CSSMotionList2, _React$Component);
      var _super = _createSuper(CSSMotionList2);
      function CSSMotionList2() {
        var _this;
        _classCallCheck(this, CSSMotionList2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = _super.call.apply(_super, [this].concat(args));
        _defineProperty(_assertThisInitialized$1(_this), "state", {
          keyEntities: []
        });
        _defineProperty(_assertThisInitialized$1(_this), "removeKey", function(removeKey) {
          var keyEntities = _this.state.keyEntities;
          var nextKeyEntities = keyEntities.map(function(entity) {
            if (entity.key !== removeKey)
              return entity;
            return _objectSpread2(_objectSpread2({}, entity), {}, {
              status: STATUS_REMOVED
            });
          });
          _this.setState({
            keyEntities: nextKeyEntities
          });
          return nextKeyEntities.filter(function(_ref) {
            var status = _ref.status;
            return status !== STATUS_REMOVED;
          }).length;
        });
        return _this;
      }
      _createClass$1(CSSMotionList2, [{
        key: "render",
        value: function render2() {
          var _this2 = this;
          var keyEntities = this.state.keyEntities;
          var _this$props = this.props, component = _this$props.component, children = _this$props.children, _onVisibleChanged = _this$props.onVisibleChanged, onAllRemoved = _this$props.onAllRemoved, restProps = _objectWithoutProperties(_this$props, _excluded$7);
          var Component2 = component || React__namespace.Fragment;
          var motionProps = {};
          MOTION_PROP_NAMES.forEach(function(prop) {
            motionProps[prop] = restProps[prop];
            delete restProps[prop];
          });
          delete restProps.keys;
          return /* @__PURE__ */ React__namespace.createElement(Component2, restProps, keyEntities.map(function(_ref2) {
            var status = _ref2.status, eventProps = _objectWithoutProperties(_ref2, _excluded2);
            var visible = status === STATUS_ADD || status === STATUS_KEEP;
            return /* @__PURE__ */ React__namespace.createElement(CSSMotion$1, _extends$2({}, motionProps, {
              key: eventProps.key,
              visible,
              eventProps,
              onVisibleChanged: function onVisibleChanged(changedVisible) {
                _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                  key: eventProps.key
                });
                if (!changedVisible) {
                  var restKeysCount = _this2.removeKey(eventProps.key);
                  if (restKeysCount === 0 && onAllRemoved) {
                    onAllRemoved();
                  }
                }
              }
            }), children);
          }));
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(_ref3, _ref4) {
          var keys2 = _ref3.keys;
          var keyEntities = _ref4.keyEntities;
          var parsedKeyObjects = parseKeys(keys2);
          var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
          return {
            keyEntities: mixedKeyEntities.filter(function(entity) {
              var prevEntity = keyEntities.find(function(_ref5) {
                var key = _ref5.key;
                return entity.key === key;
              });
              if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                return false;
              }
              return true;
            })
          };
        }
        // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
      }]);
      return CSSMotionList2;
    }(React__namespace.Component);
    _defineProperty(CSSMotionList, "defaultProps", {
      component: "div"
    });
    return CSSMotionList;
  }
  genCSSMotionList(supportTransition);
  function MotionWrapper(props) {
    const {
      children
    } = props;
    const [, token2] = useToken$2();
    const {
      motion
    } = token2;
    const needWrapMotionProviderRef = React__namespace.useRef(false);
    needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion === false;
    if (needWrapMotionProviderRef.current) {
      return /* @__PURE__ */ React__namespace.createElement(MotionProvider, {
        motion
      }, children);
    }
    return children;
  }
  const useStyle$8 = (iconPrefixCls, csp) => {
    const [theme2, token2] = useToken$2();
    return useStyleRegister({
      theme: theme2,
      token: token2,
      hashId: "",
      path: ["ant-design-icons", iconPrefixCls],
      nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce
    }, () => [{
      [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
        [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
          display: "block"
        }
      })
    }]);
  };
  const useStyle$9 = useStyle$8;
  var __rest$c = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const PASSED_PROPS = ["getTargetContainer", "getPopupContainer", "renderEmpty", "pageHeader", "input", "pagination", "form", "select", "button"];
  const defaultPrefixCls = "ant";
  let globalPrefixCls;
  let globalIconPrefixCls;
  let globalTheme;
  function getGlobalPrefixCls() {
    return globalPrefixCls || defaultPrefixCls;
  }
  function getGlobalIconPrefixCls() {
    return globalIconPrefixCls || defaultIconPrefixCls;
  }
  function isLegacyTheme(theme2) {
    return Object.keys(theme2).some((key) => key.endsWith("Color"));
  }
  const setGlobalConfig = (_ref) => {
    let {
      prefixCls,
      iconPrefixCls,
      theme: theme2
    } = _ref;
    if (prefixCls !== void 0) {
      globalPrefixCls = prefixCls;
    }
    if (iconPrefixCls !== void 0) {
      globalIconPrefixCls = iconPrefixCls;
    }
    if (theme2) {
      if (isLegacyTheme(theme2)) {
        registerTheme(getGlobalPrefixCls(), theme2);
      } else {
        globalTheme = theme2;
      }
    }
  };
  const globalConfig = () => ({
    getPrefixCls: (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls)
        return customizePrefixCls;
      return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
    },
    getIconPrefixCls: getGlobalIconPrefixCls,
    getRootPrefixCls: () => {
      if (globalPrefixCls) {
        return globalPrefixCls;
      }
      return getGlobalPrefixCls();
    },
    getTheme: () => globalTheme
  });
  const ProviderChildren = (props) => {
    const {
      children,
      csp: customCsp,
      autoInsertSpaceInButton,
      form,
      locale: locale2,
      componentSize,
      direction,
      space,
      virtual,
      dropdownMatchSelectWidth,
      popupMatchSelectWidth,
      popupOverflow,
      legacyLocale,
      parentContext,
      iconPrefixCls: customIconPrefixCls,
      theme: theme2,
      componentDisabled
    } = props;
    const getPrefixCls = React__namespace.useCallback((suffixCls, customizePrefixCls) => {
      const {
        prefixCls
      } = props;
      if (customizePrefixCls)
        return customizePrefixCls;
      const mergedPrefixCls = prefixCls || parentContext.getPrefixCls("");
      return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
    }, [parentContext.getPrefixCls, props.prefixCls]);
    const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
    const shouldWrapSSR = iconPrefixCls !== parentContext.iconPrefixCls;
    const csp = customCsp || parentContext.csp;
    const wrapSSR = useStyle$9(iconPrefixCls, csp);
    const mergedTheme = useTheme(theme2, parentContext.theme);
    const baseConfig = {
      csp,
      autoInsertSpaceInButton,
      locale: locale2 || legacyLocale,
      direction,
      space,
      virtual,
      popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
      popupOverflow,
      getPrefixCls,
      iconPrefixCls,
      theme: mergedTheme
    };
    const config = Object.assign({}, parentContext);
    Object.keys(baseConfig).forEach((key) => {
      if (baseConfig[key] !== void 0) {
        config[key] = baseConfig[key];
      }
    });
    PASSED_PROPS.forEach((propName) => {
      const propValue = props[propName];
      if (propValue) {
        config[propName] = propValue;
      }
    });
    const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
      const prevKeys = Object.keys(prevConfig);
      const currentKeys = Object.keys(currentConfig);
      return prevKeys.length !== currentKeys.length || prevKeys.some((key) => prevConfig[key] !== currentConfig[key]);
    });
    const memoIconContextValue = React__namespace.useMemo(() => ({
      prefixCls: iconPrefixCls,
      csp
    }), [iconPrefixCls, csp]);
    let childNode = shouldWrapSSR ? wrapSSR(children) : children;
    const validateMessages = React__namespace.useMemo(() => {
      var _a2, _b, _c;
      return merge$2(((_a2 = defaultLocale.Form) === null || _a2 === void 0 ? void 0 : _a2.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
    }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
    if (Object.keys(validateMessages).length > 0) {
      childNode = /* @__PURE__ */ React__namespace.createElement(ValidateMessagesContext.Provider, {
        value: validateMessages
      }, children);
    }
    if (locale2) {
      childNode = /* @__PURE__ */ React__namespace.createElement(LocaleProvider$1, {
        locale: locale2,
        _ANT_MARK__: ANT_MARK
      }, childNode);
    }
    if (iconPrefixCls || csp) {
      childNode = /* @__PURE__ */ React__namespace.createElement(Context$2.Provider, {
        value: memoIconContextValue
      }, childNode);
    }
    if (componentSize) {
      childNode = /* @__PURE__ */ React__namespace.createElement(SizeContextProvider, {
        size: componentSize
      }, childNode);
    }
    childNode = /* @__PURE__ */ React__namespace.createElement(MotionWrapper, null, childNode);
    const memoTheme = React__namespace.useMemo(() => {
      const _a2 = mergedTheme || {}, {
        algorithm,
        token: token2
      } = _a2, rest = __rest$c(_a2, ["algorithm", "token"]);
      const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : void 0;
      return Object.assign(Object.assign({}, rest), {
        theme: themeObj,
        token: Object.assign(Object.assign({}, seedToken$1), token2)
      });
    }, [mergedTheme]);
    if (theme2) {
      childNode = /* @__PURE__ */ React__namespace.createElement(DesignTokenContext.Provider, {
        value: memoTheme
      }, childNode);
    }
    if (componentDisabled !== void 0) {
      childNode = /* @__PURE__ */ React__namespace.createElement(DisabledContextProvider, {
        disabled: componentDisabled
      }, childNode);
    }
    return /* @__PURE__ */ React__namespace.createElement(ConfigContext.Provider, {
      value: memoedConfig
    }, childNode);
  };
  const ConfigProvider = (props) => {
    const context = React__namespace.useContext(ConfigContext);
    const antLocale = React__namespace.useContext(LocaleContext$1);
    return /* @__PURE__ */ React__namespace.createElement(ProviderChildren, Object.assign({
      parentContext: context,
      legacyLocale: antLocale
    }, props));
  };
  ConfigProvider.ConfigContext = ConfigContext;
  ConfigProvider.SizeContext = SizeContext$1;
  ConfigProvider.config = setGlobalConfig;
  ConfigProvider.useConfig = useConfig;
  Object.defineProperty(ConfigProvider, "SizeContext", {
    get: () => {
      return SizeContext$1;
    }
  });
  var CheckCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };
  const CheckCircleFilledSvg = CheckCircleFilled$2;
  function getRoot(ele) {
    var _ele$getRootNode;
    return ele === null || ele === void 0 ? void 0 : (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
  }
  function inShadow(ele) {
    return getRoot(ele) !== (ele === null || ele === void 0 ? void 0 : ele.ownerDocument);
  }
  function getShadowRoot(ele) {
    return inShadow(ele) ? getRoot(ele) : null;
  }
  function warning$1(valid, message) {
    warningOnce(valid, "[@ant-design/icons] ".concat(message));
  }
  function isIconDefinition(target) {
    return _typeof(target) === "object" && typeof target.name === "string" && typeof target.theme === "string" && (_typeof(target.icon) === "object" || typeof target.icon === "function");
  }
  function normalizeAttrs() {
    var attrs = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    return Object.keys(attrs).reduce(function(acc, key) {
      var val = attrs[key];
      switch (key) {
        case "class":
          acc.className = val;
          delete acc.class;
          break;
        default:
          acc[key] = val;
      }
      return acc;
    }, {});
  }
  function generate(node2, key, rootProps) {
    if (!rootProps) {
      return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2({
        key
      }, normalizeAttrs(node2.attrs)), (node2.children || []).map(function(child, index2) {
        return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
      }));
    }
    return /* @__PURE__ */ React.createElement(node2.tag, _objectSpread2(_objectSpread2({
      key
    }, normalizeAttrs(node2.attrs)), rootProps), (node2.children || []).map(function(child, index2) {
      return generate(child, "".concat(key, "-").concat(node2.tag, "-").concat(index2));
    }));
  }
  function getSecondaryColor(primaryColor) {
    return generate$1(primaryColor)[0];
  }
  function normalizeTwoToneColors(twoToneColor) {
    if (!twoToneColor) {
      return [];
    }
    return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
  }
  var iconStyles = "\n.anticon {\n  display: inline-block;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
  var useInsertStyles = function useInsertStyles2(eleRef) {
    var _useContext = React.useContext(Context$2), csp = _useContext.csp, prefixCls = _useContext.prefixCls;
    var mergedStyleStr = iconStyles;
    if (prefixCls) {
      mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
    }
    React.useEffect(function() {
      var ele = eleRef.current;
      var shadowRoot = getShadowRoot(ele);
      updateCSS(mergedStyleStr, "@ant-design-icons", {
        prepend: true,
        csp,
        attachTo: shadowRoot
      });
    }, []);
  };
  var _excluded$6 = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
  var twoToneColorPalette = {
    primaryColor: "#333",
    secondaryColor: "#E6E6E6",
    calculated: false
  };
  function setTwoToneColors(_ref) {
    var primaryColor = _ref.primaryColor, secondaryColor = _ref.secondaryColor;
    twoToneColorPalette.primaryColor = primaryColor;
    twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
    twoToneColorPalette.calculated = !!secondaryColor;
  }
  function getTwoToneColors() {
    return _objectSpread2({}, twoToneColorPalette);
  }
  var IconBase = function IconBase2(props) {
    var icon = props.icon, className = props.className, onClick = props.onClick, style2 = props.style, primaryColor = props.primaryColor, secondaryColor = props.secondaryColor, restProps = _objectWithoutProperties(props, _excluded$6);
    var svgRef = React__namespace.useRef();
    var colors = twoToneColorPalette;
    if (primaryColor) {
      colors = {
        primaryColor,
        secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
      };
    }
    useInsertStyles(svgRef);
    warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
    if (!isIconDefinition(icon)) {
      return null;
    }
    var target = icon;
    if (target && typeof target.icon === "function") {
      target = _objectSpread2(_objectSpread2({}, target), {}, {
        icon: target.icon(colors.primaryColor, colors.secondaryColor)
      });
    }
    return generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
      className,
      onClick,
      style: style2,
      "data-icon": target.name,
      width: "1em",
      height: "1em",
      fill: "currentColor",
      "aria-hidden": "true"
    }, restProps), {}, {
      ref: svgRef
    }));
  };
  IconBase.displayName = "IconReact";
  IconBase.getTwoToneColors = getTwoToneColors;
  IconBase.setTwoToneColors = setTwoToneColors;
  const ReactIcon = IconBase;
  function setTwoToneColor(twoToneColor) {
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return ReactIcon.setTwoToneColors({
      primaryColor,
      secondaryColor
    });
  }
  function getTwoToneColor() {
    var colors = ReactIcon.getTwoToneColors();
    if (!colors.calculated) {
      return colors.primaryColor;
    }
    return [colors.primaryColor, colors.secondaryColor];
  }
  var _excluded$5 = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
  setTwoToneColor(blue.primary);
  var Icon = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var _classNames;
    var className = props.className, icon = props.icon, spin = props.spin, rotate = props.rotate, tabIndex = props.tabIndex, onClick = props.onClick, twoToneColor = props.twoToneColor, restProps = _objectWithoutProperties(props, _excluded$5);
    var _React$useContext = React__namespace.useContext(Context$2), _React$useContext$pre = _React$useContext.prefixCls, prefixCls = _React$useContext$pre === void 0 ? "anticon" : _React$useContext$pre, rootClassName = _React$useContext.rootClassName;
    var classString = classNames(rootClassName, prefixCls, (_classNames = {}, _defineProperty(_classNames, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), _defineProperty(_classNames, "".concat(prefixCls, "-spin"), !!spin || icon.name === "loading"), _classNames), className);
    var iconTabIndex = tabIndex;
    if (iconTabIndex === void 0 && onClick) {
      iconTabIndex = -1;
    }
    var svgStyle = rotate ? {
      msTransform: "rotate(".concat(rotate, "deg)"),
      transform: "rotate(".concat(rotate, "deg)")
    } : void 0;
    var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor), _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2), primaryColor = _normalizeTwoToneColo2[0], secondaryColor = _normalizeTwoToneColo2[1];
    return /* @__PURE__ */ React__namespace.createElement("span", _extends$2({
      role: "img",
      "aria-label": icon.name
    }, restProps, {
      ref,
      tabIndex: iconTabIndex,
      onClick,
      className: classString
    }), /* @__PURE__ */ React__namespace.createElement(ReactIcon, {
      icon,
      primaryColor,
      secondaryColor,
      style: svgStyle
    }));
  });
  Icon.displayName = "AntdIcon";
  Icon.getTwoToneColor = getTwoToneColor;
  Icon.setTwoToneColor = setTwoToneColor;
  const AntdIcon = Icon;
  var CheckCircleFilled = function CheckCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: CheckCircleFilledSvg
    }));
  };
  const CheckCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CheckCircleFilled);
  var CloseCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm165.4 618.2l-66-.3L512 563.4l-99.3 118.4-66.1.3c-4.4 0-8-3.5-8-8 0-1.9.7-3.7 1.9-5.2l130.1-155L340.5 359a8.32 8.32 0 01-1.9-5.2c0-4.4 3.6-8 8-8l66.1.3L512 464.6l99.3-118.4 66-.3c4.4 0 8 3.5 8 8 0 1.9-.7 3.7-1.9 5.2L553.5 514l130 155c1.2 1.5 1.9 3.3 1.9 5.2 0 4.4-3.6 8-8 8z" } }] }, "name": "close-circle", "theme": "filled" };
  const CloseCircleFilledSvg = CloseCircleFilled$2;
  var CloseCircleFilled = function CloseCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: CloseCircleFilledSvg
    }));
  };
  const CloseCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseCircleFilled);
  var CloseOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M563.8 512l262.5-312.9c4.4-5.2.7-13.1-6.1-13.1h-79.8c-4.7 0-9.2 2.1-12.3 5.7L511.6 449.8 295.1 191.7c-3-3.6-7.5-5.7-12.3-5.7H203c-6.8 0-10.5 7.9-6.1 13.1L459.4 512 196.9 824.9A7.95 7.95 0 00203 838h79.8c4.7 0 9.2-2.1 12.3-5.7l216.5-258.1 216.5 258.1c3 3.6 7.5 5.7 12.3 5.7h79.8c6.8 0 10.5-7.9 6.1-13.1L563.8 512z" } }] }, "name": "close", "theme": "outlined" };
  const CloseOutlinedSvg = CloseOutlined$2;
  var CloseOutlined = function CloseOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: CloseOutlinedSvg
    }));
  };
  const CloseOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(CloseOutlined);
  var ExclamationCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };
  const ExclamationCircleFilledSvg = ExclamationCircleFilled$2;
  var ExclamationCircleFilled = function ExclamationCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: ExclamationCircleFilledSvg
    }));
  };
  const ExclamationCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(ExclamationCircleFilled);
  var InfoCircleFilled$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };
  const InfoCircleFilledSvg = InfoCircleFilled$2;
  var InfoCircleFilled = function InfoCircleFilled2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: InfoCircleFilledSvg
    }));
  };
  const InfoCircleFilled$1 = /* @__PURE__ */ React__namespace.forwardRef(InfoCircleFilled);
  var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
  var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
  var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
  var ariaPrefix = "aria-";
  var dataPrefix = "data-";
  function match(key, prefix) {
    return key.indexOf(prefix) === 0;
  }
  function pickAttrs(props) {
    var ariaOnly = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    var mergedConfig;
    if (ariaOnly === false) {
      mergedConfig = {
        aria: true,
        data: true,
        attr: true
      };
    } else if (ariaOnly === true) {
      mergedConfig = {
        aria: true
      };
    } else {
      mergedConfig = _objectSpread2({}, ariaOnly);
    }
    var attrs = {};
    Object.keys(props).forEach(function(key) {
      if (
        // Aria
        mergedConfig.aria && (key === "role" || match(key, ariaPrefix)) || // Data
        mergedConfig.data && match(key, dataPrefix) || // Attr
        mergedConfig.attr && propList.includes(key)
      ) {
        attrs[key] = props[key];
      }
    });
    return attrs;
  }
  const {
    isValidElement
  } = React__namespace;
  function isFragment(child) {
    return child && isValidElement(child) && child.type === React__namespace.Fragment;
  }
  function replaceElement(element, replacement, props) {
    if (!isValidElement(element)) {
      return replacement;
    }
    return /* @__PURE__ */ React__namespace.cloneElement(element, typeof props === "function" ? props(element.props || {}) : props);
  }
  function cloneElement(element, props) {
    return replaceElement(element, element, props);
  }
  function isWindow(obj) {
    return obj !== null && obj !== void 0 && obj === obj.window;
  }
  function getScroll$1(target, top) {
    var _a2, _b;
    if (typeof window === "undefined") {
      return 0;
    }
    const method4 = top ? "scrollTop" : "scrollLeft";
    let result = 0;
    if (isWindow(target)) {
      result = target[top ? "pageYOffset" : "pageXOffset"];
    } else if (target instanceof Document) {
      result = target.documentElement[method4];
    } else if (target instanceof HTMLElement) {
      result = target[method4];
    } else if (target) {
      result = target[method4];
    }
    if (target && !isWindow(target) && typeof result !== "number") {
      result = (_b = ((_a2 = target.ownerDocument) !== null && _a2 !== void 0 ? _a2 : target).documentElement) === null || _b === void 0 ? void 0 : _b[method4];
    }
    return result;
  }
  function easeInOutCubic(t2, b2, c2, d2) {
    const cc = c2 - b2;
    t2 /= d2 / 2;
    if (t2 < 1) {
      return cc / 2 * t2 * t2 * t2 + b2;
    }
    return cc / 2 * ((t2 -= 2) * t2 * t2 + 2) + b2;
  }
  function scrollTo(y2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const {
      getContainer: getContainer2 = () => window,
      callback,
      duration = 450
    } = options;
    const container = getContainer2();
    const scrollTop = getScroll$1(container, true);
    const startTime = Date.now();
    const frameFunc = () => {
      const timestamp = Date.now();
      const time = timestamp - startTime;
      const nextScrollTop = easeInOutCubic(time > duration ? duration : time, scrollTop, y2, duration);
      if (isWindow(container)) {
        container.scrollTo(window.pageXOffset, nextScrollTop);
      } else if (container instanceof Document || container.constructor.name === "HTMLDocument") {
        container.documentElement.scrollTop = nextScrollTop;
      } else {
        container.scrollTop = nextScrollTop;
      }
      if (time < duration) {
        wrapperRaf(frameFunc);
      } else if (typeof callback === "function") {
        callback();
      }
    };
    wrapperRaf(frameFunc);
  }
  var KeyCode = {
    /**
     * MAC_ENTER
     */
    MAC_ENTER: 3,
    /**
     * BACKSPACE
     */
    BACKSPACE: 8,
    /**
     * TAB
     */
    TAB: 9,
    /**
     * NUMLOCK on FF/Safari Mac
     */
    NUM_CENTER: 12,
    // NUMLOCK on FF/Safari Mac
    /**
     * ENTER
     */
    ENTER: 13,
    /**
     * SHIFT
     */
    SHIFT: 16,
    /**
     * CTRL
     */
    CTRL: 17,
    /**
     * ALT
     */
    ALT: 18,
    /**
     * PAUSE
     */
    PAUSE: 19,
    /**
     * CAPS_LOCK
     */
    CAPS_LOCK: 20,
    /**
     * ESC
     */
    ESC: 27,
    /**
     * SPACE
     */
    SPACE: 32,
    /**
     * PAGE_UP
     */
    PAGE_UP: 33,
    // also NUM_NORTH_EAST
    /**
     * PAGE_DOWN
     */
    PAGE_DOWN: 34,
    // also NUM_SOUTH_EAST
    /**
     * END
     */
    END: 35,
    // also NUM_SOUTH_WEST
    /**
     * HOME
     */
    HOME: 36,
    // also NUM_NORTH_WEST
    /**
     * LEFT
     */
    LEFT: 37,
    // also NUM_WEST
    /**
     * UP
     */
    UP: 38,
    // also NUM_NORTH
    /**
     * RIGHT
     */
    RIGHT: 39,
    // also NUM_EAST
    /**
     * DOWN
     */
    DOWN: 40,
    // also NUM_SOUTH
    /**
     * PRINT_SCREEN
     */
    PRINT_SCREEN: 44,
    /**
     * INSERT
     */
    INSERT: 45,
    // also NUM_INSERT
    /**
     * DELETE
     */
    DELETE: 46,
    // also NUM_DELETE
    /**
     * ZERO
     */
    ZERO: 48,
    /**
     * ONE
     */
    ONE: 49,
    /**
     * TWO
     */
    TWO: 50,
    /**
     * THREE
     */
    THREE: 51,
    /**
     * FOUR
     */
    FOUR: 52,
    /**
     * FIVE
     */
    FIVE: 53,
    /**
     * SIX
     */
    SIX: 54,
    /**
     * SEVEN
     */
    SEVEN: 55,
    /**
     * EIGHT
     */
    EIGHT: 56,
    /**
     * NINE
     */
    NINE: 57,
    /**
     * QUESTION_MARK
     */
    QUESTION_MARK: 63,
    // needs localization
    /**
     * A
     */
    A: 65,
    /**
     * B
     */
    B: 66,
    /**
     * C
     */
    C: 67,
    /**
     * D
     */
    D: 68,
    /**
     * E
     */
    E: 69,
    /**
     * F
     */
    F: 70,
    /**
     * G
     */
    G: 71,
    /**
     * H
     */
    H: 72,
    /**
     * I
     */
    I: 73,
    /**
     * J
     */
    J: 74,
    /**
     * K
     */
    K: 75,
    /**
     * L
     */
    L: 76,
    /**
     * M
     */
    M: 77,
    /**
     * N
     */
    N: 78,
    /**
     * O
     */
    O: 79,
    /**
     * P
     */
    P: 80,
    /**
     * Q
     */
    Q: 81,
    /**
     * R
     */
    R: 82,
    /**
     * S
     */
    S: 83,
    /**
     * T
     */
    T: 84,
    /**
     * U
     */
    U: 85,
    /**
     * V
     */
    V: 86,
    /**
     * W
     */
    W: 87,
    /**
     * X
     */
    X: 88,
    /**
     * Y
     */
    Y: 89,
    /**
     * Z
     */
    Z: 90,
    /**
     * META
     */
    META: 91,
    // WIN_KEY_LEFT
    /**
     * WIN_KEY_RIGHT
     */
    WIN_KEY_RIGHT: 92,
    /**
     * CONTEXT_MENU
     */
    CONTEXT_MENU: 93,
    /**
     * NUM_ZERO
     */
    NUM_ZERO: 96,
    /**
     * NUM_ONE
     */
    NUM_ONE: 97,
    /**
     * NUM_TWO
     */
    NUM_TWO: 98,
    /**
     * NUM_THREE
     */
    NUM_THREE: 99,
    /**
     * NUM_FOUR
     */
    NUM_FOUR: 100,
    /**
     * NUM_FIVE
     */
    NUM_FIVE: 101,
    /**
     * NUM_SIX
     */
    NUM_SIX: 102,
    /**
     * NUM_SEVEN
     */
    NUM_SEVEN: 103,
    /**
     * NUM_EIGHT
     */
    NUM_EIGHT: 104,
    /**
     * NUM_NINE
     */
    NUM_NINE: 105,
    /**
     * NUM_MULTIPLY
     */
    NUM_MULTIPLY: 106,
    /**
     * NUM_PLUS
     */
    NUM_PLUS: 107,
    /**
     * NUM_MINUS
     */
    NUM_MINUS: 109,
    /**
     * NUM_PERIOD
     */
    NUM_PERIOD: 110,
    /**
     * NUM_DIVISION
     */
    NUM_DIVISION: 111,
    /**
     * F1
     */
    F1: 112,
    /**
     * F2
     */
    F2: 113,
    /**
     * F3
     */
    F3: 114,
    /**
     * F4
     */
    F4: 115,
    /**
     * F5
     */
    F5: 116,
    /**
     * F6
     */
    F6: 117,
    /**
     * F7
     */
    F7: 118,
    /**
     * F8
     */
    F8: 119,
    /**
     * F9
     */
    F9: 120,
    /**
     * F10
     */
    F10: 121,
    /**
     * F11
     */
    F11: 122,
    /**
     * F12
     */
    F12: 123,
    /**
     * NUMLOCK
     */
    NUMLOCK: 144,
    /**
     * SEMICOLON
     */
    SEMICOLON: 186,
    // needs localization
    /**
     * DASH
     */
    DASH: 189,
    // needs localization
    /**
     * EQUALS
     */
    EQUALS: 187,
    // needs localization
    /**
     * COMMA
     */
    COMMA: 188,
    // needs localization
    /**
     * PERIOD
     */
    PERIOD: 190,
    // needs localization
    /**
     * SLASH
     */
    SLASH: 191,
    // needs localization
    /**
     * APOSTROPHE
     */
    APOSTROPHE: 192,
    // needs localization
    /**
     * SINGLE_QUOTE
     */
    SINGLE_QUOTE: 222,
    // needs localization
    /**
     * OPEN_SQUARE_BRACKET
     */
    OPEN_SQUARE_BRACKET: 219,
    // needs localization
    /**
     * BACKSLASH
     */
    BACKSLASH: 220,
    // needs localization
    /**
     * CLOSE_SQUARE_BRACKET
     */
    CLOSE_SQUARE_BRACKET: 221,
    // needs localization
    /**
     * WIN_KEY
     */
    WIN_KEY: 224,
    /**
     * MAC_FF_META
     */
    MAC_FF_META: 224,
    // Firefox (Gecko) fires this for the meta key instead of 91
    /**
     * WIN_IME
     */
    WIN_IME: 229,
    // ======================== Function ========================
    /**
     * whether text and modified key is entered at the same time.
     */
    isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e2) {
      var keyCode = e2.keyCode;
      if (e2.altKey && !e2.ctrlKey || e2.metaKey || // Function keys don't generate text
      keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
        return false;
      }
      switch (keyCode) {
        case KeyCode.ALT:
        case KeyCode.CAPS_LOCK:
        case KeyCode.CONTEXT_MENU:
        case KeyCode.CTRL:
        case KeyCode.DOWN:
        case KeyCode.END:
        case KeyCode.ESC:
        case KeyCode.HOME:
        case KeyCode.INSERT:
        case KeyCode.LEFT:
        case KeyCode.MAC_FF_META:
        case KeyCode.META:
        case KeyCode.NUMLOCK:
        case KeyCode.NUM_CENTER:
        case KeyCode.PAGE_DOWN:
        case KeyCode.PAGE_UP:
        case KeyCode.PAUSE:
        case KeyCode.PRINT_SCREEN:
        case KeyCode.RIGHT:
        case KeyCode.SHIFT:
        case KeyCode.UP:
        case KeyCode.WIN_KEY:
        case KeyCode.WIN_KEY_RIGHT:
          return false;
        default:
          return true;
      }
    },
    /**
     * whether character is entered.
     */
    isCharacterKey: function isCharacterKey(keyCode) {
      if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
        return true;
      }
      if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
        return true;
      }
      if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
        return true;
      }
      if (window.navigator.userAgent.indexOf("WebKit") !== -1 && keyCode === 0) {
        return true;
      }
      switch (keyCode) {
        case KeyCode.SPACE:
        case KeyCode.QUESTION_MARK:
        case KeyCode.NUM_PLUS:
        case KeyCode.NUM_MINUS:
        case KeyCode.NUM_PERIOD:
        case KeyCode.NUM_DIVISION:
        case KeyCode.SEMICOLON:
        case KeyCode.DASH:
        case KeyCode.EQUALS:
        case KeyCode.COMMA:
        case KeyCode.PERIOD:
        case KeyCode.SLASH:
        case KeyCode.APOSTROPHE:
        case KeyCode.SINGLE_QUOTE:
        case KeyCode.OPEN_SQUARE_BRACKET:
        case KeyCode.BACKSLASH:
        case KeyCode.CLOSE_SQUARE_BRACKET:
          return true;
        default:
          return false;
      }
    }
  };
  var LoadingOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };
  const LoadingOutlinedSvg = LoadingOutlined$2;
  var LoadingOutlined = function LoadingOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: LoadingOutlinedSvg
    }));
  };
  const LoadingOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(LoadingOutlined);
  function usePatchElement() {
    const [elements, setElements] = React__namespace.useState([]);
    const patchElement = React__namespace.useCallback((element) => {
      setElements((originElements) => [].concat(_toConsumableArray(originElements), [element]));
      return () => {
        setElements((originElements) => originElements.filter((ele) => ele !== element));
      };
    }, []);
    return [elements, patchElement];
  }
  function _regeneratorRuntime() {
    _regeneratorRuntime = function _regeneratorRuntime2() {
      return exports;
    };
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty3 = Object.defineProperty || function(obj, key, desc) {
      obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
      return Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      }), obj[key];
    }
    try {
      define({}, "");
    } catch (err) {
      define = function define2(obj, key, value) {
        return obj[key] = value;
      };
    }
    function wrap(innerFn, outerFn, self2, tryLocsList) {
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context2(tryLocsList || []);
      return defineProperty3(generator, "_invoke", {
        value: makeInvokeMethod(innerFn, self2, context)
      }), generator;
    }
    function tryCatch(fn, obj, arg) {
      try {
        return {
          type: "normal",
          arg: fn.call(obj, arg)
        };
      } catch (err) {
        return {
          type: "throw",
          arg: err
        };
      }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {
    }
    function GeneratorFunction() {
    }
    function GeneratorFunctionPrototype() {
    }
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
      return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype2) {
      ["next", "throw", "return"].forEach(function(method4) {
        define(prototype2, method4, function(arg) {
          return this._invoke(method4, arg);
        });
      });
    }
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method4, arg, resolve, reject) {
        var record = tryCatch(generator[method4], generator, arg);
        if ("throw" !== record.type) {
          var result = record.arg, value = result.value;
          return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value2) {
            invoke("next", value2, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          }) : PromiseImpl.resolve(value).then(function(unwrapped) {
            result.value = unwrapped, resolve(result);
          }, function(error) {
            return invoke("throw", error, resolve, reject);
          });
        }
        reject(record.arg);
      }
      var previousPromise;
      defineProperty3(this, "_invoke", {
        value: function value(method4, arg) {
          function callInvokeWithMethodAndArg() {
            return new PromiseImpl(function(resolve, reject) {
              invoke(method4, arg, resolve, reject);
            });
          }
          return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
        }
      });
    }
    function makeInvokeMethod(innerFn, self2, context) {
      var state = "suspendedStart";
      return function(method4, arg) {
        if ("executing" === state)
          throw new Error("Generator is already running");
        if ("completed" === state) {
          if ("throw" === method4)
            throw arg;
          return doneResult();
        }
        for (context.method = method4, context.arg = arg; ; ) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel)
                continue;
              return delegateResult;
            }
          }
          if ("next" === context.method)
            context.sent = context._sent = context.arg;
          else if ("throw" === context.method) {
            if ("suspendedStart" === state)
              throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else
            "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self2, context);
          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel)
              continue;
            return {
              value: record.arg,
              done: context.done
            };
          }
          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }
    function maybeInvokeDelegate(delegate, context) {
      var methodName = context.method, method4 = delegate.iterator[methodName];
      if (void 0 === method4)
        return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = void 0, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
      var record = tryCatch(method4, delegate.iterator, context.arg);
      if ("throw" === record.type)
        return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
      var info = record.arg;
      return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = void 0), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
      var entry = {
        tryLoc: locs[0]
      };
      1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context2(tryLocsList) {
      this.tryEntries = [{
        tryLoc: "root"
      }], tryLocsList.forEach(pushTryEntry, this), this.reset(true);
    }
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod)
          return iteratorMethod.call(iterable);
        if ("function" == typeof iterable.next)
          return iterable;
        if (!isNaN(iterable.length)) {
          var i = -1, next2 = function next3() {
            for (; ++i < iterable.length; )
              if (hasOwn.call(iterable, i))
                return next3.value = iterable[i], next3.done = false, next3;
            return next3.value = void 0, next3.done = true, next3;
          };
          return next2.next = next2;
        }
      }
      return {
        next: doneResult
      };
    }
    function doneResult() {
      return {
        value: void 0,
        done: true
      };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty3(Gp, "constructor", {
      value: GeneratorFunctionPrototype,
      configurable: true
    }), defineProperty3(GeneratorFunctionPrototype, "constructor", {
      value: GeneratorFunction,
      configurable: true
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
      var ctor = "function" == typeof genFun && genFun.constructor;
      return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
      return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
      return {
        __await: arg
      };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
      return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self2, tryLocsList, PromiseImpl) {
      void 0 === PromiseImpl && (PromiseImpl = Promise);
      var iter = new AsyncIterator(wrap(innerFn, outerFn, self2, tryLocsList), PromiseImpl);
      return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
        return result.done ? result.value : iter.next();
      });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
      return this;
    }), define(Gp, "toString", function() {
      return "[object Generator]";
    }), exports.keys = function(val) {
      var object5 = Object(val), keys2 = [];
      for (var key in object5)
        keys2.push(key);
      return keys2.reverse(), function next2() {
        for (; keys2.length; ) {
          var key2 = keys2.pop();
          if (key2 in object5)
            return next2.value = key2, next2.done = false, next2;
        }
        return next2.done = true, next2;
      };
    }, exports.values = values, Context2.prototype = {
      constructor: Context2,
      reset: function reset(skipTempReset) {
        if (this.prev = 0, this.next = 0, this.sent = this._sent = void 0, this.done = false, this.delegate = null, this.method = "next", this.arg = void 0, this.tryEntries.forEach(resetTryEntry), !skipTempReset)
          for (var name in this)
            "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = void 0);
      },
      stop: function stop() {
        this.done = true;
        var rootRecord = this.tryEntries[0].completion;
        if ("throw" === rootRecord.type)
          throw rootRecord.arg;
        return this.rval;
      },
      dispatchException: function dispatchException(exception) {
        if (this.done)
          throw exception;
        var context = this;
        function handle(loc, caught) {
          return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = void 0), !!caught;
        }
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i], record = entry.completion;
          if ("root" === entry.tryLoc)
            return handle("end");
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc)
                return handle(entry.catchLoc, true);
            } else {
              if (!hasFinally)
                throw new Error("try statement without catch or finally");
              if (this.prev < entry.finallyLoc)
                return handle(entry.finallyLoc);
            }
          }
        }
      },
      abrupt: function abrupt(type4, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
        finallyEntry && ("break" === type4 || "continue" === type4) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
        var record = finallyEntry ? finallyEntry.completion : {};
        return record.type = type4, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
      },
      complete: function complete(record, afterLoc) {
        if ("throw" === record.type)
          throw record.arg;
        return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
      },
      finish: function finish(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc)
            return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
        }
      },
      "catch": function _catch(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if ("throw" === record.type) {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
        throw new Error("illegal catch attempt");
      },
      delegateYield: function delegateYield(iterable, resultName, nextLoc) {
        return this.delegate = {
          iterator: values(iterable),
          resultName,
          nextLoc
        }, "next" === this.method && (this.arg = void 0), ContinueSentinel;
      }
    }, exports;
  }
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  function _asyncToGenerator(fn) {
    return function() {
      var self2 = this, args = arguments;
      return new Promise(function(resolve, reject) {
        var gen = fn.apply(self2, args);
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
        _next(void 0);
      });
    };
  }
  var fullClone = _objectSpread2({}, ReactDOM__default__namespace);
  var version = fullClone.version, reactRender = fullClone.render, unmountComponentAtNode = fullClone.unmountComponentAtNode;
  var createRoot;
  try {
    var mainVersion = Number((version || "").split(".")[0]);
    if (mainVersion >= 18) {
      createRoot = fullClone.createRoot;
    }
  } catch (e2) {
  }
  function toggleWarning(skip) {
    var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === "object") {
      __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
    }
  }
  var MARK = "__rc_react_root__";
  function modernRender(node2, container) {
    toggleWarning(true);
    var root = container[MARK] || createRoot(container);
    toggleWarning(false);
    root.render(node2);
    container[MARK] = root;
  }
  function legacyRender(node2, container) {
    reactRender(node2, container);
  }
  function render(node2, container) {
    if (createRoot) {
      modernRender(node2, container);
      return;
    }
    legacyRender(node2, container);
  }
  function modernUnmount(_x) {
    return _modernUnmount.apply(this, arguments);
  }
  function _modernUnmount() {
    _modernUnmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(container) {
      return _regeneratorRuntime().wrap(function _callee$(_context) {
        while (1)
          switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Promise.resolve().then(function() {
                var _container$MARK;
                (_container$MARK = container[MARK]) === null || _container$MARK === void 0 ? void 0 : _container$MARK.unmount();
                delete container[MARK];
              }));
            case 1:
            case "end":
              return _context.stop();
          }
      }, _callee);
    }));
    return _modernUnmount.apply(this, arguments);
  }
  function legacyUnmount(container) {
    unmountComponentAtNode(container);
  }
  function unmount(_x2) {
    return _unmount.apply(this, arguments);
  }
  function _unmount() {
    _unmount = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(container) {
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              if (!(createRoot !== void 0)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", modernUnmount(container));
            case 2:
              legacyUnmount(container);
            case 3:
            case "end":
              return _context2.stop();
          }
      }, _callee2);
    }));
    return _unmount.apply(this, arguments);
  }
  const isVisible = function(element) {
    if (!element) {
      return false;
    }
    if (element instanceof Element) {
      if (element.offsetParent) {
        return true;
      }
      if (element.getBBox) {
        var _getBBox = element.getBBox(), width = _getBBox.width, height = _getBBox.height;
        if (width || height) {
          return true;
        }
      }
      if (element.getBoundingClientRect) {
        var _element$getBoundingC = element.getBoundingClientRect(), _width = _element$getBoundingC.width, _height = _element$getBoundingC.height;
        if (_width || _height) {
          return true;
        }
      }
    }
    return false;
  };
  const genWaveStyle = (token2) => {
    const {
      componentCls,
      colorPrimary
    } = token2;
    return {
      [componentCls]: {
        position: "absolute",
        background: "transparent",
        pointerEvents: "none",
        boxSizing: "border-box",
        color: `var(--wave-color, ${colorPrimary})`,
        boxShadow: `0 0 0 0 currentcolor`,
        opacity: 0.2,
        // =================== Motion ===================
        "&.wave-motion-appear": {
          transition: [`box-shadow 0.4s ${token2.motionEaseOutCirc}`, `opacity 2s ${token2.motionEaseOutCirc}`].join(","),
          "&-active": {
            boxShadow: `0 0 0 6px currentcolor`,
            opacity: 0
          }
        }
      }
    };
  };
  const useStyle$7 = genComponentStyleHook("Wave", (token2) => [genWaveStyle(token2)]);
  function isNotGrey(color) {
    const match2 = (color || "").match(/rgba?\((\d*), (\d*), (\d*)(, [\d.]*)?\)/);
    if (match2 && match2[1] && match2[2] && match2[3]) {
      return !(match2[1] === match2[2] && match2[2] === match2[3]);
    }
    return true;
  }
  function isValidWaveColor(color) {
    return color && color !== "#fff" && color !== "#ffffff" && color !== "rgb(255, 255, 255)" && color !== "rgba(255, 255, 255, 1)" && isNotGrey(color) && !/rgba\((?:\d*, ){3}0\)/.test(color) && // any transparent rgba color
    color !== "transparent";
  }
  function getTargetWaveColor(node2) {
    const {
      borderTopColor,
      borderColor,
      backgroundColor
    } = getComputedStyle(node2);
    if (isValidWaveColor(borderTopColor)) {
      return borderTopColor;
    }
    if (isValidWaveColor(borderColor)) {
      return borderColor;
    }
    if (isValidWaveColor(backgroundColor)) {
      return backgroundColor;
    }
    return null;
  }
  function validateNum(value) {
    return Number.isNaN(value) ? 0 : value;
  }
  const WaveEffect = (props) => {
    const {
      className,
      target
    } = props;
    const divRef = React__namespace.useRef(null);
    const [color, setWaveColor] = React__namespace.useState(null);
    const [borderRadius, setBorderRadius] = React__namespace.useState([]);
    const [left, setLeft] = React__namespace.useState(0);
    const [top, setTop] = React__namespace.useState(0);
    const [width, setWidth] = React__namespace.useState(0);
    const [height, setHeight] = React__namespace.useState(0);
    const [enabled, setEnabled] = React__namespace.useState(false);
    const waveStyle = {
      left,
      top,
      width,
      height,
      borderRadius: borderRadius.map((radius) => `${radius}px`).join(" ")
    };
    if (color) {
      waveStyle["--wave-color"] = color;
    }
    function syncPos() {
      const nodeStyle = getComputedStyle(target);
      setWaveColor(getTargetWaveColor(target));
      const isStatic = nodeStyle.position === "static";
      const {
        borderLeftWidth,
        borderTopWidth
      } = nodeStyle;
      setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
      setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
      setWidth(target.offsetWidth);
      setHeight(target.offsetHeight);
      const {
        borderTopLeftRadius,
        borderTopRightRadius,
        borderBottomLeftRadius,
        borderBottomRightRadius
      } = nodeStyle;
      setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map((radius) => validateNum(parseFloat(radius))));
    }
    React__namespace.useEffect(() => {
      if (target) {
        const id2 = wrapperRaf(() => {
          syncPos();
          setEnabled(true);
        });
        let resizeObserver2;
        if (typeof ResizeObserver !== "undefined") {
          resizeObserver2 = new ResizeObserver(syncPos);
          resizeObserver2.observe(target);
        }
        return () => {
          wrapperRaf.cancel(id2);
          resizeObserver2 === null || resizeObserver2 === void 0 ? void 0 : resizeObserver2.disconnect();
        };
      }
    }, []);
    if (!enabled) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      visible: true,
      motionAppear: true,
      motionName: "wave-motion",
      motionDeadline: 5e3,
      onAppearEnd: (_2, event) => {
        var _a2;
        if (event.deadline || event.propertyName === "opacity") {
          const holder = (_a2 = divRef.current) === null || _a2 === void 0 ? void 0 : _a2.parentElement;
          unmount(holder).then(() => {
            holder === null || holder === void 0 ? void 0 : holder.remove();
          });
        }
        return false;
      }
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        ref: divRef,
        className: classNames(className, motionClassName),
        style: waveStyle
      });
    });
  };
  function showWaveEffect(node2, className) {
    const holder = document.createElement("div");
    holder.style.position = "absolute";
    holder.style.left = `0px`;
    holder.style.top = `0px`;
    node2 === null || node2 === void 0 ? void 0 : node2.insertBefore(holder, node2 === null || node2 === void 0 ? void 0 : node2.firstChild);
    render(/* @__PURE__ */ React__namespace.createElement(WaveEffect, {
      target: node2,
      className
    }), holder);
  }
  function useWave(nodeRef, className) {
    function showWave() {
      const node2 = nodeRef.current;
      showWaveEffect(node2, className);
    }
    return showWave;
  }
  const Wave = (props) => {
    const {
      children,
      disabled
    } = props;
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const containerRef = React.useRef(null);
    const prefixCls = getPrefixCls("wave");
    const [, hashId] = useStyle$7(prefixCls);
    const showWave = useWave(containerRef, classNames(prefixCls, hashId));
    React.useEffect(() => {
      const node2 = containerRef.current;
      if (!node2 || node2.nodeType !== 1 || disabled) {
        return;
      }
      const onClick = (e2) => {
        if (e2.target.tagName === "INPUT" || !isVisible(e2.target) || // No need wave
        !node2.getAttribute || node2.getAttribute("disabled") || node2.disabled || node2.className.includes("disabled") || node2.className.includes("-leave")) {
          return;
        }
        showWave();
      };
      node2.addEventListener("click", onClick, true);
      return () => {
        node2.removeEventListener("click", onClick, true);
      };
    }, [disabled]);
    if (!/* @__PURE__ */ React.isValidElement(children)) {
      return children !== null && children !== void 0 ? children : null;
    }
    const ref = supportRef(children) ? composeRef(children.ref, containerRef) : containerRef;
    return cloneElement(children, {
      ref
    });
  };
  const Wave$1 = Wave;
  const SpaceCompactItemContext = /* @__PURE__ */ React__namespace.createContext(null);
  const useCompactItemContext = (prefixCls, direction) => {
    const compactItemContext = React__namespace.useContext(SpaceCompactItemContext);
    const compactItemClassnames = React__namespace.useMemo(() => {
      if (!compactItemContext) {
        return "";
      }
      const {
        compactDirection,
        isFirstItem,
        isLastItem
      } = compactItemContext;
      const separator = compactDirection === "vertical" ? "-vertical-" : "-";
      return classNames({
        [`${prefixCls}-compact${separator}item`]: true,
        [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
        [`${prefixCls}-compact${separator}last-item`]: isLastItem,
        [`${prefixCls}-compact${separator}item-rtl`]: direction === "rtl"
      });
    }, [prefixCls, direction, compactItemContext]);
    return {
      compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
      compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
      compactItemClassnames
    };
  };
  const NoCompactStyle = (_ref) => {
    let {
      children
    } = _ref;
    return /* @__PURE__ */ React__namespace.createElement(SpaceCompactItemContext.Provider, {
      value: null
    }, children);
  };
  const IconWrapper = /* @__PURE__ */ React.forwardRef((props, ref) => {
    const {
      className,
      style: style2,
      children,
      prefixCls
    } = props;
    const iconWrapperCls = classNames(`${prefixCls}-icon`, className);
    return /* @__PURE__ */ React.createElement("span", {
      ref,
      className: iconWrapperCls,
      style: style2
    }, children);
  });
  const IconWrapper$1 = IconWrapper;
  const InnerLoadingIcon = /* @__PURE__ */ React.forwardRef((_ref, ref) => {
    let {
      prefixCls,
      className,
      style: style2,
      iconClassName
    } = _ref;
    const mergedIconCls = classNames(`${prefixCls}-loading-icon`, className);
    return /* @__PURE__ */ React.createElement(IconWrapper$1, {
      prefixCls,
      className: mergedIconCls,
      style: style2,
      ref
    }, /* @__PURE__ */ React.createElement(LoadingOutlined$1, {
      className: iconClassName
    }));
  });
  const getCollapsedWidth = () => ({
    width: 0,
    opacity: 0,
    transform: "scale(0)"
  });
  const getRealWidth = (node2) => ({
    width: node2.scrollWidth,
    opacity: 1,
    transform: "scale(1)"
  });
  const LoadingIcon = (_ref2) => {
    let {
      prefixCls,
      loading,
      existIcon,
      className,
      style: style2
    } = _ref2;
    const visible = !!loading;
    if (existIcon) {
      return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: style2
      });
    }
    return /* @__PURE__ */ React.createElement(CSSMotion, {
      visible,
      // We do not really use this motionName
      motionName: `${prefixCls}-loading-icon-motion`,
      removeOnLeave: true,
      onAppearStart: getCollapsedWidth,
      onAppearActive: getRealWidth,
      onEnterStart: getCollapsedWidth,
      onEnterActive: getRealWidth,
      onLeaveStart: getRealWidth,
      onLeaveActive: getCollapsedWidth
    }, (_ref3, ref) => {
      let {
        className: motionCls,
        style: motionStyle
      } = _ref3;
      return /* @__PURE__ */ React.createElement(InnerLoadingIcon, {
        prefixCls,
        className,
        style: Object.assign(Object.assign({}, style2), motionStyle),
        ref,
        iconClassName: motionCls
      });
    });
  };
  const LoadingIcon$1 = LoadingIcon;
  var __rest$b = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const GroupSizeContext = /* @__PURE__ */ React__namespace.createContext(void 0);
  const ButtonGroup = (props) => {
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const {
      prefixCls: customizePrefixCls,
      size,
      className
    } = props, others = __rest$b(props, ["prefixCls", "size", "className"]);
    const prefixCls = getPrefixCls("btn-group", customizePrefixCls);
    const [, , hashId] = useToken$2();
    let sizeCls = "";
    switch (size) {
      case "large":
        sizeCls = "lg";
        break;
      case "small":
        sizeCls = "sm";
        break;
    }
    const classes = classNames(prefixCls, {
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, hashId);
    return /* @__PURE__ */ React__namespace.createElement(GroupSizeContext.Provider, {
      value: size
    }, /* @__PURE__ */ React__namespace.createElement("div", Object.assign({}, others, {
      className: classes
    })));
  };
  const Group = ButtonGroup;
  const rxTwoCNChar = /^[\u4e00-\u9fa5]{2}$/;
  const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
  function isString$2(str) {
    return typeof str === "string";
  }
  function isUnBorderedButtonType(type4) {
    return type4 === "text" || type4 === "link";
  }
  function splitCNCharsBySpace(child, needInserted) {
    if (child === null || child === void 0) {
      return;
    }
    const SPACE = needInserted ? " " : "";
    if (typeof child !== "string" && typeof child !== "number" && isString$2(child.type) && isTwoCNChar(child.props.children)) {
      return cloneElement(child, {
        children: child.props.children.split("").join(SPACE)
      });
    }
    if (typeof child === "string") {
      return isTwoCNChar(child) ? /* @__PURE__ */ React.createElement("span", null, child.split("").join(SPACE)) : /* @__PURE__ */ React.createElement("span", null, child);
    }
    if (isFragment(child)) {
      return /* @__PURE__ */ React.createElement("span", null, child);
    }
    return child;
  }
  function spaceChildren(children, needInserted) {
    let isPrevChildPure = false;
    const childList = [];
    React.Children.forEach(children, (child) => {
      const type4 = typeof child;
      const isCurrentChildPure = type4 === "string" || type4 === "number";
      if (isPrevChildPure && isCurrentChildPure) {
        const lastIndex = childList.length - 1;
        const lastChild = childList[lastIndex];
        childList[lastIndex] = `${lastChild}${child}`;
      } else {
        childList.push(child);
      }
      isPrevChildPure = isCurrentChildPure;
    });
    return React.Children.map(childList, (child) => splitCNCharsBySpace(child, needInserted));
  }
  function compactItemBorder(token2, parentCls, options) {
    const {
      focusElCls,
      focus,
      borderElCls
    } = options;
    const childCombinator = borderElCls ? "> *" : "";
    const hoverEffects = ["hover", focus ? "focus" : null, "active"].filter(Boolean).map((n2) => `&:${n2} ${childCombinator}`).join(",");
    return {
      [`&-item:not(${parentCls}-last-item)`]: {
        marginInlineEnd: -token2.lineWidth
      },
      "&-item": Object.assign(Object.assign({
        [hoverEffects]: {
          zIndex: 2
        }
      }, focusElCls ? {
        [`&${focusElCls}`]: {
          zIndex: 2
        }
      } : {}), {
        [`&[disabled] ${childCombinator}`]: {
          zIndex: 0
        }
      })
    };
  }
  function compactItemBorderRadius(prefixCls, parentCls, options) {
    const {
      borderElCls
    } = options;
    const childCombinator = borderElCls ? `> ${borderElCls}` : "";
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
        borderRadius: 0
      },
      [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0
        }
      },
      [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
        [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0
        }
      }
    };
  }
  function genCompactItemStyle(token2) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      focus: true
    };
    const {
      componentCls
    } = token2;
    const compactCls = `${componentCls}-compact`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token2, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
    };
  }
  function compactItemVerticalBorder(token2, parentCls) {
    return {
      // border collapse
      [`&-item:not(${parentCls}-last-item)`]: {
        marginBottom: -token2.lineWidth
      },
      "&-item": {
        "&:hover,&:focus,&:active": {
          zIndex: 2
        },
        "&[disabled]": {
          zIndex: 0
        }
      }
    };
  }
  function compactItemBorderVerticalRadius(prefixCls, parentCls) {
    return {
      [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
        borderRadius: 0
      },
      [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderEndEndRadius: 0,
          borderEndStartRadius: 0
        }
      },
      [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
        [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
          borderStartStartRadius: 0,
          borderStartEndRadius: 0
        }
      }
    };
  }
  function genCompactItemVerticalStyle(token2) {
    const compactCls = `${token2.componentCls}-compact-vertical`;
    return {
      [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token2, compactCls)), compactItemBorderVerticalRadius(token2.componentCls, compactCls))
    };
  }
  const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
    // Border
    [`> span, > ${buttonTypeCls}`]: {
      "&:not(:last-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineEndColor: borderColor
          }
        }
      },
      "&:not(:first-child)": {
        [`&, & > ${buttonTypeCls}`]: {
          "&:not(:disabled)": {
            borderInlineStartColor: borderColor
          }
        }
      }
    }
  });
  const genGroupStyle = (token2) => {
    const {
      componentCls,
      fontSize,
      lineWidth,
      colorPrimaryHover,
      colorErrorHover
    } = token2;
    return {
      [`${componentCls}-group`]: [
        {
          position: "relative",
          display: "inline-flex",
          // Border
          [`> span, > ${componentCls}`]: {
            "&:not(:last-child)": {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            "&:not(:first-child)": {
              marginInlineStart: -lineWidth,
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: "relative",
            zIndex: 1,
            [`&:hover,
          &:focus,
          &:active`]: {
              zIndex: 2
            },
            "&[disabled]": {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, colorPrimaryHover),
        genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)
      ]
    };
  };
  const genGroupStyle$1 = genGroupStyle;
  const genSharedButtonStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      buttonFontWeight
    } = token2;
    return {
      [componentCls]: {
        outline: "none",
        position: "relative",
        display: "inline-block",
        fontWeight: buttonFontWeight,
        whiteSpace: "nowrap",
        textAlign: "center",
        backgroundImage: "none",
        backgroundColor: "transparent",
        border: `${token2.lineWidth}px ${token2.lineType} transparent`,
        cursor: "pointer",
        transition: `all ${token2.motionDurationMid} ${token2.motionEaseInOut}`,
        userSelect: "none",
        touchAction: "manipulation",
        lineHeight: token2.lineHeight,
        color: token2.colorText,
        "&:disabled > *": {
          pointerEvents: "none"
        },
        "> span": {
          display: "inline-block"
        },
        [`${componentCls}-icon`]: {
          lineHeight: 0
        },
        // Leave a space between icon and text.
        [`> ${iconCls} + span, > span + ${iconCls}`]: {
          marginInlineStart: token2.marginXS
        },
        [`&:not(${componentCls}-icon-only) > ${componentCls}-icon`]: {
          [`&${componentCls}-loading-icon, &:not(:last-child)`]: {
            marginInlineEnd: token2.marginXS
          }
        },
        "> a": {
          color: "currentColor"
        },
        "&:not(:disabled)": Object.assign({}, genFocusStyle(token2)),
        // make `btn-icon-only` not too narrow
        [`&-icon-only${componentCls}-compact-item`]: {
          flex: "none"
        },
        // Special styles for Primary Button
        [`&-compact-item${componentCls}-primary`]: {
          [`&:not([disabled]) + ${componentCls}-compact-item${componentCls}-primary:not([disabled])`]: {
            position: "relative",
            "&:before": {
              position: "absolute",
              top: -token2.lineWidth,
              insetInlineStart: -token2.lineWidth,
              display: "inline-block",
              width: token2.lineWidth,
              height: `calc(100% + ${token2.lineWidth * 2}px)`,
              backgroundColor: token2.colorPrimaryHover,
              content: '""'
            }
          }
        },
        // Special styles for Primary Button
        "&-compact-vertical-item": {
          [`&${componentCls}-primary`]: {
            [`&:not([disabled]) + ${componentCls}-compact-vertical-item${componentCls}-primary:not([disabled])`]: {
              position: "relative",
              "&:before": {
                position: "absolute",
                top: -token2.lineWidth,
                insetInlineStart: -token2.lineWidth,
                display: "inline-block",
                width: `calc(100% + ${token2.lineWidth * 2}px)`,
                height: token2.lineWidth,
                backgroundColor: token2.colorPrimaryHover,
                content: '""'
              }
            }
          }
        }
      }
    };
  };
  const genHoverActiveButtonStyle = (hoverStyle, activeStyle) => ({
    "&:not(:disabled)": {
      "&:hover": hoverStyle,
      "&:active": activeStyle
    }
  });
  const genCircleButtonStyle = (token2) => ({
    minWidth: token2.controlHeight,
    paddingInlineStart: 0,
    paddingInlineEnd: 0,
    borderRadius: "50%"
  });
  const genRoundButtonStyle = (token2) => ({
    borderRadius: token2.controlHeight,
    paddingInlineStart: token2.controlHeight / 2,
    paddingInlineEnd: token2.controlHeight / 2
  });
  const genDisabledStyle = (token2) => ({
    cursor: "not-allowed",
    borderColor: token2.colorBorder,
    color: token2.colorTextDisabled,
    backgroundColor: token2.colorBgContainerDisabled,
    boxShadow: "none"
  });
  const genGhostButtonStyle = (btnCls, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
    [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
      color: textColor || void 0,
      backgroundColor: "transparent",
      borderColor: borderColor || void 0,
      boxShadow: "none"
    }, genHoverActiveButtonStyle(Object.assign({
      backgroundColor: "transparent"
    }, hoverStyle), Object.assign({
      backgroundColor: "transparent"
    }, activeStyle))), {
      "&:disabled": {
        cursor: "not-allowed",
        color: textColorDisabled || void 0,
        borderColor: borderColorDisabled || void 0
      }
    })
  });
  const genSolidDisabledButtonStyle = (token2) => ({
    "&:disabled": Object.assign({}, genDisabledStyle(token2))
  });
  const genSolidButtonStyle = (token2) => Object.assign({}, genSolidDisabledButtonStyle(token2));
  const genPureDisabledButtonStyle = (token2) => ({
    "&:disabled": {
      cursor: "not-allowed",
      color: token2.colorTextDisabled
    }
  });
  const genDefaultButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
    backgroundColor: token2.colorBgContainer,
    borderColor: token2.colorBorder,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlTmpOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorBgContainer, token2.colorBgContainer, token2.colorTextDisabled, token2.colorBorder)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
      color: token2.colorError,
      borderColor: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorBorderHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder)), genSolidDisabledButtonStyle(token2))
  });
  const genPrimaryButtonStyle = (token2) => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genSolidButtonStyle(token2)), {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimary,
    boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.controlOutline}`
  }), genHoverActiveButtonStyle({
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryHover
  }, {
    color: token2.colorTextLightSolid,
    backgroundColor: token2.colorPrimaryActive
  })), genGhostButtonStyle(token2.componentCls, token2.colorPrimary, token2.colorPrimary, token2.colorTextDisabled, token2.colorBorder, {
    color: token2.colorPrimaryHover,
    borderColor: token2.colorPrimaryHover
  }, {
    color: token2.colorPrimaryActive,
    borderColor: token2.colorPrimaryActive
  })), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign(Object.assign({
      backgroundColor: token2.colorError,
      boxShadow: `0 ${token2.controlOutlineWidth}px 0 ${token2.colorErrorOutline}`
    }, genHoverActiveButtonStyle({
      backgroundColor: token2.colorErrorHover
    }, {
      backgroundColor: token2.colorErrorActive
    })), genGhostButtonStyle(token2.componentCls, token2.colorError, token2.colorError, token2.colorTextDisabled, token2.colorBorder, {
      color: token2.colorErrorHover,
      borderColor: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive,
      borderColor: token2.colorErrorActive
    })), genSolidDisabledButtonStyle(token2))
  });
  const genDashedButtonStyle = (token2) => Object.assign(Object.assign({}, genDefaultButtonStyle(token2)), {
    borderStyle: "dashed"
  });
  const genLinkButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({
    color: token2.colorLink
  }, genHoverActiveButtonStyle({
    color: token2.colorLinkHover
  }, {
    color: token2.colorLinkActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
      color: token2.colorError
    }, genHoverActiveButtonStyle({
      color: token2.colorErrorHover
    }, {
      color: token2.colorErrorActive
    })), genPureDisabledButtonStyle(token2))
  });
  const genTextButtonStyle = (token2) => Object.assign(Object.assign(Object.assign({}, genHoverActiveButtonStyle({
    color: token2.colorText,
    backgroundColor: token2.colorBgTextHover
  }, {
    color: token2.colorText,
    backgroundColor: token2.colorBgTextActive
  })), genPureDisabledButtonStyle(token2)), {
    [`&${token2.componentCls}-dangerous`]: Object.assign(Object.assign({
      color: token2.colorError
    }, genPureDisabledButtonStyle(token2)), genHoverActiveButtonStyle({
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }, {
      color: token2.colorErrorHover,
      backgroundColor: token2.colorErrorBg
    }))
  });
  const genDisabledButtonStyle = (token2) => Object.assign(Object.assign({}, genDisabledStyle(token2)), {
    [`&${token2.componentCls}:hover`]: Object.assign({}, genDisabledStyle(token2))
  });
  const genTypeButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-default`]: genDefaultButtonStyle(token2),
      [`${componentCls}-primary`]: genPrimaryButtonStyle(token2),
      [`${componentCls}-dashed`]: genDashedButtonStyle(token2),
      [`${componentCls}-link`]: genLinkButtonStyle(token2),
      [`${componentCls}-text`]: genTextButtonStyle(token2),
      [`${componentCls}-disabled`]: genDisabledButtonStyle(token2)
    };
  };
  const genSizeButtonStyle = function(token2) {
    let sizePrefixCls = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const {
      componentCls,
      controlHeight,
      fontSize,
      lineHeight,
      lineWidth,
      borderRadius,
      buttonPaddingHorizontal,
      iconCls
    } = token2;
    const paddingVertical = Math.max(0, (controlHeight - fontSize * lineHeight) / 2 - lineWidth);
    const paddingHorizontal = buttonPaddingHorizontal - lineWidth;
    const iconOnlyCls = `${componentCls}-icon-only`;
    return [
      // Size
      {
        [`${componentCls}${sizePrefixCls}`]: {
          fontSize,
          height: controlHeight,
          padding: `${paddingVertical}px ${paddingHorizontal}px`,
          borderRadius,
          [`&${iconOnlyCls}`]: {
            width: controlHeight,
            paddingInlineStart: 0,
            paddingInlineEnd: 0,
            [`&${componentCls}-round`]: {
              width: "auto"
            },
            [iconCls]: {
              fontSize: token2.buttonIconOnlyFontSize
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: token2.opacityLoading,
            cursor: "default"
          },
          [`${componentCls}-loading-icon`]: {
            transition: `width ${token2.motionDurationSlow} ${token2.motionEaseInOut}, opacity ${token2.motionDurationSlow} ${token2.motionEaseInOut}`
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${sizePrefixCls}`]: genCircleButtonStyle(token2)
      },
      {
        [`${componentCls}${componentCls}-round${sizePrefixCls}`]: genRoundButtonStyle(token2)
      }
    ];
  };
  const genSizeBaseButtonStyle = (token2) => genSizeButtonStyle(token2);
  const genSizeSmallButtonStyle = (token2) => {
    const smallToken = merge$1(token2, {
      controlHeight: token2.controlHeightSM,
      padding: token2.paddingXS,
      buttonPaddingHorizontal: 8,
      borderRadius: token2.borderRadiusSM,
      buttonIconOnlyFontSize: token2.fontSizeLG - 2
    });
    return genSizeButtonStyle(smallToken, `${token2.componentCls}-sm`);
  };
  const genSizeLargeButtonStyle = (token2) => {
    const largeToken = merge$1(token2, {
      controlHeight: token2.controlHeightLG,
      fontSize: token2.fontSizeLG,
      borderRadius: token2.borderRadiusLG,
      buttonIconOnlyFontSize: token2.fontSizeLG + 2
    });
    return genSizeButtonStyle(largeToken, `${token2.componentCls}-lg`);
  };
  const genBlockButtonStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [componentCls]: {
        [`&${componentCls}-block`]: {
          width: "100%"
        }
      }
    };
  };
  const useStyle$6 = genComponentStyleHook("Button", (token2) => {
    const {
      controlTmpOutline,
      paddingContentHorizontal
    } = token2;
    const buttonToken = merge$1(token2, {
      colorOutlineDefault: controlTmpOutline,
      buttonPaddingHorizontal: paddingContentHorizontal,
      buttonIconOnlyFontSize: token2.fontSizeLG,
      buttonFontWeight: 400
    });
    return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeSmallButtonStyle(buttonToken),
      genSizeBaseButtonStyle(buttonToken),
      genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Group (type, ghost, danger, disabled, loading)
      genTypeButtonStyle(buttonToken),
      // Button Group
      genGroupStyle$1(buttonToken),
      // Space Compact
      genCompactItemStyle(token2),
      genCompactItemVerticalStyle(token2)
    ];
  });
  var __rest$a = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  function convertLegacyProps(type4) {
    if (type4 === "danger") {
      return {
        danger: true
      };
    }
    return {
      type: type4
    };
  }
  function getLoadingConfig(loading) {
    if (typeof loading === "object" && loading) {
      const delay = loading === null || loading === void 0 ? void 0 : loading.delay;
      const isDelay = !Number.isNaN(delay) && typeof delay === "number";
      return {
        loading: false,
        delay: isDelay ? delay : 0
      };
    }
    return {
      loading: !!loading,
      delay: 0
    };
  }
  const InternalButton = (props, ref) => {
    var _a2, _b;
    const {
      loading = false,
      prefixCls: customizePrefixCls,
      type: type4 = "default",
      danger,
      shape = "default",
      size: customizeSize,
      styles,
      disabled: customDisabled,
      className,
      rootClassName,
      children,
      icon,
      ghost = false,
      block = false,
      // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
      htmlType = "button",
      classNames: customClassNames,
      style: customStyle = {}
    } = props, rest = __rest$a(props, ["loading", "prefixCls", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "ghost", "block", "htmlType", "classNames", "style"]);
    const {
      getPrefixCls,
      autoInsertSpaceInButton,
      direction,
      button
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls("btn", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$6(prefixCls);
    const disabled = React.useContext(DisabledContext$1);
    const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
    const groupSize = React.useContext(GroupSizeContext);
    const loadingOrDelay = React.useMemo(() => getLoadingConfig(loading), [loading]);
    const [innerLoading, setLoading] = React.useState(loadingOrDelay.loading);
    const [hasTwoCNChar, setHasTwoCNChar] = React.useState(false);
    const internalRef = /* @__PURE__ */ React.createRef();
    const buttonRef = composeRef(ref, internalRef);
    const needInserted = React.Children.count(children) === 1 && !icon && !isUnBorderedButtonType(type4);
    React.useEffect(() => {
      let delayTimer = null;
      if (loadingOrDelay.delay > 0) {
        delayTimer = setTimeout(() => {
          delayTimer = null;
          setLoading(true);
        }, loadingOrDelay.delay);
      } else {
        setLoading(loadingOrDelay.loading);
      }
      function cleanupTimer() {
        if (delayTimer) {
          clearTimeout(delayTimer);
          delayTimer = null;
        }
      }
      return cleanupTimer;
    }, [loadingOrDelay]);
    React.useEffect(() => {
      if (!buttonRef || !buttonRef.current || autoInsertSpaceInButton === false) {
        return;
      }
      const buttonText = buttonRef.current.textContent;
      if (needInserted && isTwoCNChar(buttonText)) {
        if (!hasTwoCNChar) {
          setHasTwoCNChar(true);
        }
      } else if (hasTwoCNChar) {
        setHasTwoCNChar(false);
      }
    }, [buttonRef]);
    const handleClick = (e2) => {
      const {
        onClick
      } = props;
      if (innerLoading || mergedDisabled) {
        e2.preventDefault();
        return;
      }
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    };
    const autoInsertSpace = autoInsertSpaceInButton !== false;
    const {
      compactSize,
      compactItemClassnames
    } = useCompactItemContext(prefixCls, direction);
    const sizeClassNameMap = {
      large: "lg",
      small: "sm",
      middle: void 0
    };
    const sizeFullName = useSize$1((ctxSize) => {
      var _a3, _b2;
      return (_b2 = (_a3 = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a3 !== void 0 ? _a3 : groupSize) !== null && _b2 !== void 0 ? _b2 : ctxSize;
    });
    const sizeCls = sizeFullName ? sizeClassNameMap[sizeFullName] || "" : "";
    const iconType = innerLoading ? "loading" : icon;
    const linkButtonRestProps = omit(rest, ["navigate"]);
    const hrefAndDisabled = linkButtonRestProps.href !== void 0 && mergedDisabled;
    const classes = classNames(prefixCls, hashId, {
      [`${prefixCls}-${shape}`]: shape !== "default" && shape,
      [`${prefixCls}-${type4}`]: type4,
      [`${prefixCls}-${sizeCls}`]: sizeCls,
      [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
      [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonType(type4),
      [`${prefixCls}-loading`]: innerLoading,
      [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && autoInsertSpace && !innerLoading,
      [`${prefixCls}-block`]: block,
      [`${prefixCls}-dangerous`]: !!danger,
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-disabled`]: hrefAndDisabled
    }, compactItemClassnames, className, rootClassName, button === null || button === void 0 ? void 0 : button.className);
    const fullStyle = Object.assign(Object.assign({}, button === null || button === void 0 ? void 0 : button.style), customStyle);
    const iconClasses = classNames(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, (_a2 = button === null || button === void 0 ? void 0 : button.classNames) === null || _a2 === void 0 ? void 0 : _a2.icon);
    const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), ((_b = button === null || button === void 0 ? void 0 : button.styles) === null || _b === void 0 ? void 0 : _b.icon) || {});
    const iconNode = icon && !innerLoading ? /* @__PURE__ */ React.createElement(IconWrapper$1, {
      prefixCls,
      className: iconClasses,
      style: iconStyle
    }, icon) : /* @__PURE__ */ React.createElement(LoadingIcon$1, {
      existIcon: !!icon,
      prefixCls,
      loading: !!innerLoading
    });
    const kids = children || children === 0 ? spaceChildren(children, needInserted && autoInsertSpace) : null;
    if (linkButtonRestProps.href !== void 0) {
      return wrapSSR(/* @__PURE__ */ React.createElement("a", Object.assign({}, linkButtonRestProps, {
        className: classes,
        style: fullStyle,
        onClick: handleClick,
        ref: buttonRef
      }), iconNode, kids));
    }
    let buttonNode = /* @__PURE__ */ React.createElement("button", Object.assign({}, rest, {
      type: htmlType,
      className: classes,
      style: fullStyle,
      onClick: handleClick,
      disabled: mergedDisabled,
      ref: buttonRef
    }), iconNode, kids);
    if (!isUnBorderedButtonType(type4)) {
      buttonNode = /* @__PURE__ */ React.createElement(Wave$1, {
        disabled: !!innerLoading
      }, buttonNode);
    }
    return wrapSSR(buttonNode);
  };
  const Button = /* @__PURE__ */ React.forwardRef(InternalButton);
  Button.Group = Group;
  Button.__ANT_BUTTON = true;
  const Button$1 = Button;
  function isThenable$1(thing) {
    return !!(thing && thing.then);
  }
  const ActionButton = (props) => {
    const {
      type: type4,
      children,
      prefixCls,
      buttonProps,
      close,
      autoFocus,
      emitEvent,
      quitOnNullishReturnValue,
      actionFn
    } = props;
    const clickedRef = React__namespace.useRef(false);
    const buttonRef = React__namespace.useRef(null);
    const [loading, setLoading] = useSafeState(false);
    const onInternalClose = function() {
      close === null || close === void 0 ? void 0 : close.apply(void 0, arguments);
    };
    React__namespace.useEffect(() => {
      let timeoutId = null;
      if (autoFocus) {
        timeoutId = setTimeout(() => {
          var _a2;
          (_a2 = buttonRef.current) === null || _a2 === void 0 ? void 0 : _a2.focus();
        });
      }
      return () => {
        if (timeoutId) {
          clearTimeout(timeoutId);
        }
      };
    }, []);
    const handlePromiseOnOk = (returnValueOfOnOk) => {
      if (!isThenable$1(returnValueOfOnOk)) {
        return;
      }
      setLoading(true);
      returnValueOfOnOk.then(function() {
        setLoading(false, true);
        onInternalClose.apply(void 0, arguments);
        clickedRef.current = false;
      }, (e2) => {
        setLoading(false, true);
        clickedRef.current = false;
        return Promise.reject(e2);
      });
    };
    const onClick = (e2) => {
      if (clickedRef.current) {
        return;
      }
      clickedRef.current = true;
      if (!actionFn) {
        onInternalClose();
        return;
      }
      let returnValueOfOnOk;
      if (emitEvent) {
        returnValueOfOnOk = actionFn(e2);
        if (quitOnNullishReturnValue && !isThenable$1(returnValueOfOnOk)) {
          clickedRef.current = false;
          onInternalClose(e2);
          return;
        }
      } else if (actionFn.length) {
        returnValueOfOnOk = actionFn(close);
        clickedRef.current = false;
      } else {
        returnValueOfOnOk = actionFn();
        if (!returnValueOfOnOk) {
          onInternalClose();
          return;
        }
      }
      handlePromiseOnOk(returnValueOfOnOk);
    };
    return /* @__PURE__ */ React__namespace.createElement(Button$1, Object.assign({}, convertLegacyProps(type4), {
      onClick,
      loading,
      prefixCls
    }, buttonProps, {
      ref: buttonRef
    }), children);
  };
  const ActionButton$1 = ActionButton;
  const getTransitionName = (rootPrefixCls, motion, transitionName) => {
    if (transitionName !== void 0) {
      return transitionName;
    }
    return `${rootPrefixCls}-${motion}`;
  };
  var OrderContext = /* @__PURE__ */ React__namespace.createContext(null);
  var EMPTY_LIST = [];
  function useDom(render2, debug) {
    var _React$useState = React__namespace.useState(function() {
      if (!canUseDom()) {
        return null;
      }
      var defaultEle = document.createElement("div");
      return defaultEle;
    }), _React$useState2 = _slicedToArray(_React$useState, 1), ele = _React$useState2[0];
    var appendedRef = React__namespace.useRef(false);
    var queueCreate = React__namespace.useContext(OrderContext);
    var _React$useState3 = React__namespace.useState(EMPTY_LIST), _React$useState4 = _slicedToArray(_React$useState3, 2), queue = _React$useState4[0], setQueue = _React$useState4[1];
    var mergedQueueCreate = queueCreate || (appendedRef.current ? void 0 : function(appendFn) {
      setQueue(function(origin) {
        var newQueue = [appendFn].concat(_toConsumableArray(origin));
        return newQueue;
      });
    });
    function append3() {
      if (!ele.parentElement) {
        document.body.appendChild(ele);
      }
      appendedRef.current = true;
    }
    function cleanup2() {
      var _ele$parentElement;
      (_ele$parentElement = ele.parentElement) === null || _ele$parentElement === void 0 ? void 0 : _ele$parentElement.removeChild(ele);
      appendedRef.current = false;
    }
    useLayoutEffect(function() {
      if (render2) {
        if (queueCreate) {
          queueCreate(append3);
        } else {
          append3();
        }
      } else {
        cleanup2();
      }
      return cleanup2;
    }, [render2]);
    useLayoutEffect(function() {
      if (queue.length) {
        queue.forEach(function(appendFn) {
          return appendFn();
        });
        setQueue(EMPTY_LIST);
      }
    }, [queue]);
    return [ele, mergedQueueCreate];
  }
  var cached;
  function getScrollBarSize(fresh) {
    if (typeof document === "undefined") {
      return 0;
    }
    if (fresh || cached === void 0) {
      var inner = document.createElement("div");
      inner.style.width = "100%";
      inner.style.height = "200px";
      var outer = document.createElement("div");
      var outerStyle = outer.style;
      outerStyle.position = "absolute";
      outerStyle.top = "0";
      outerStyle.left = "0";
      outerStyle.pointerEvents = "none";
      outerStyle.visibility = "hidden";
      outerStyle.width = "200px";
      outerStyle.height = "150px";
      outerStyle.overflow = "hidden";
      outer.appendChild(inner);
      document.body.appendChild(outer);
      var widthContained = inner.offsetWidth;
      outer.style.overflow = "scroll";
      var widthScroll = inner.offsetWidth;
      if (widthContained === widthScroll) {
        widthScroll = outer.clientWidth;
      }
      document.body.removeChild(outer);
      cached = widthContained - widthScroll;
    }
    return cached;
  }
  function isBodyOverflowing() {
    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight) && window.innerWidth > document.body.offsetWidth;
  }
  var UNIQUE_ID = "rc-util-locker-".concat(Date.now());
  var uuid$2 = 0;
  function useScrollLocker(lock) {
    var mergedLock = !!lock;
    var _React$useState = React__namespace.useState(function() {
      uuid$2 += 1;
      return "".concat(UNIQUE_ID, "_").concat(uuid$2);
    }), _React$useState2 = _slicedToArray(_React$useState, 1), id2 = _React$useState2[0];
    useLayoutEffect(function() {
      if (mergedLock) {
        var scrollbarSize = getScrollBarSize();
        var isOverflow = isBodyOverflowing();
        updateCSS("\nhtml body {\n  overflow-y: hidden;\n  ".concat(isOverflow ? "width: calc(100% - ".concat(scrollbarSize, "px);") : "", "\n}"), id2);
      } else {
        removeCSS(id2);
      }
      return function() {
        removeCSS(id2);
      };
    }, [mergedLock, id2]);
  }
  var inline = false;
  function inlineMock(nextInline) {
    if (typeof nextInline === "boolean") {
      inline = nextInline;
    }
    return inline;
  }
  var getPortalContainer = function getPortalContainer2(getContainer2) {
    if (getContainer2 === false) {
      return false;
    }
    if (!canUseDom() || !getContainer2) {
      return null;
    }
    if (typeof getContainer2 === "string") {
      return document.querySelector(getContainer2);
    }
    if (typeof getContainer2 === "function") {
      return getContainer2();
    }
    return getContainer2;
  };
  var Portal = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var open = props.open, autoLock = props.autoLock, getContainer2 = props.getContainer;
    props.debug;
    var _props$autoDestroy = props.autoDestroy, autoDestroy = _props$autoDestroy === void 0 ? true : _props$autoDestroy, children = props.children;
    var _React$useState = React__namespace.useState(open), _React$useState2 = _slicedToArray(_React$useState, 2), shouldRender = _React$useState2[0], setShouldRender = _React$useState2[1];
    var mergedRender = shouldRender || open;
    React__namespace.useEffect(function() {
      if (autoDestroy || open) {
        setShouldRender(open);
      }
    }, [open, autoDestroy]);
    var _React$useState3 = React__namespace.useState(function() {
      return getPortalContainer(getContainer2);
    }), _React$useState4 = _slicedToArray(_React$useState3, 2), innerContainer = _React$useState4[0], setInnerContainer = _React$useState4[1];
    React__namespace.useEffect(function() {
      var customizeContainer = getPortalContainer(getContainer2);
      setInnerContainer(customizeContainer !== null && customizeContainer !== void 0 ? customizeContainer : null);
    });
    var _useDom = useDom(mergedRender && !innerContainer), _useDom2 = _slicedToArray(_useDom, 2), defaultContainer = _useDom2[0], queueCreate = _useDom2[1];
    var mergedContainer = innerContainer !== null && innerContainer !== void 0 ? innerContainer : defaultContainer;
    useScrollLocker(autoLock && open && canUseDom() && (mergedContainer === defaultContainer || mergedContainer === document.body));
    var childRef = null;
    if (children && supportRef(children) && ref) {
      var _ref = children;
      childRef = _ref.ref;
    }
    var mergedRef = useComposeRef(childRef, ref);
    if (!mergedRender || !canUseDom() || innerContainer === void 0) {
      return null;
    }
    var renderInline = mergedContainer === false || inlineMock();
    var reffedChildren = children;
    if (ref) {
      reffedChildren = /* @__PURE__ */ React__namespace.cloneElement(children, {
        ref: mergedRef
      });
    }
    return /* @__PURE__ */ React__namespace.createElement(OrderContext.Provider, {
      value: queueCreate
    }, renderInline ? reffedChildren : /* @__PURE__ */ ReactDOM__default.createPortal(reffedChildren, mergedContainer));
  });
  function getUseId() {
    var fullClone2 = _objectSpread2({}, React__namespace);
    return fullClone2.useId;
  }
  var uuid$1 = 0;
  function useId(id2) {
    var _React$useState = React__namespace.useState("ssr-id"), _React$useState2 = _slicedToArray(_React$useState, 2), innerId = _React$useState2[0], setInnerId = _React$useState2[1];
    var useOriginId = getUseId();
    var reactNativeId = useOriginId === null || useOriginId === void 0 ? void 0 : useOriginId();
    React__namespace.useEffect(function() {
      if (!useOriginId) {
        var nextId = uuid$1;
        uuid$1 += 1;
        setInnerId("rc_unique_".concat(nextId));
      }
    }, []);
    if (id2) {
      return id2;
    }
    return reactNativeId || innerId;
  }
  function getMotionName(prefixCls, transitionName, animationName) {
    var motionName = transitionName;
    if (!motionName && animationName) {
      motionName = "".concat(prefixCls, "-").concat(animationName);
    }
    return motionName;
  }
  function getScroll(w2, top) {
    var ret = w2["page".concat(top ? "Y" : "X", "Offset")];
    var method4 = "scroll".concat(top ? "Top" : "Left");
    if (typeof ret !== "number") {
      var d2 = w2.document;
      ret = d2.documentElement[method4];
      if (typeof ret !== "number") {
        ret = d2.body[method4];
      }
    }
    return ret;
  }
  function offset(el) {
    var rect = el.getBoundingClientRect();
    var pos = {
      left: rect.left,
      top: rect.top
    };
    var doc = el.ownerDocument;
    var w2 = doc.defaultView || doc.parentWindow;
    pos.left += getScroll(w2);
    pos.top += getScroll(w2, true);
    return pos;
  }
  const MemoChildren = /* @__PURE__ */ React__namespace.memo(function(_ref) {
    var children = _ref.children;
    return children;
  }, function(_2, _ref2) {
    var shouldUpdate = _ref2.shouldUpdate;
    return !shouldUpdate;
  });
  var sentinelStyle = {
    width: 0,
    height: 0,
    overflow: "hidden",
    outline: "none"
  };
  var Panel = /* @__PURE__ */ React.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, className = props.className, style2 = props.style, title = props.title, ariaId = props.ariaId, footer = props.footer, closable = props.closable, closeIcon = props.closeIcon, onClose = props.onClose, children = props.children, bodyStyle = props.bodyStyle, bodyProps = props.bodyProps, modalRender = props.modalRender, onMouseDown = props.onMouseDown, onMouseUp = props.onMouseUp, holderRef = props.holderRef, visible = props.visible, forceRender = props.forceRender, width = props.width, height = props.height;
    var sentinelStartRef = React.useRef();
    var sentinelEndRef = React.useRef();
    React.useImperativeHandle(ref, function() {
      return {
        focus: function focus() {
          var _sentinelStartRef$cur;
          (_sentinelStartRef$cur = sentinelStartRef.current) === null || _sentinelStartRef$cur === void 0 ? void 0 : _sentinelStartRef$cur.focus();
        },
        changeActive: function changeActive(next2) {
          var _document = document, activeElement = _document.activeElement;
          if (next2 && activeElement === sentinelEndRef.current) {
            sentinelStartRef.current.focus();
          } else if (!next2 && activeElement === sentinelStartRef.current) {
            sentinelEndRef.current.focus();
          }
        }
      };
    });
    var contentStyle = {};
    if (width !== void 0) {
      contentStyle.width = width;
    }
    if (height !== void 0) {
      contentStyle.height = height;
    }
    var footerNode;
    if (footer) {
      footerNode = /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-footer")
      }, footer);
    }
    var headerNode;
    if (title) {
      headerNode = /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-header")
      }, /* @__PURE__ */ React.createElement("div", {
        className: "".concat(prefixCls, "-title"),
        id: ariaId
      }, title));
    }
    var closer;
    if (closable) {
      closer = /* @__PURE__ */ React.createElement("button", {
        type: "button",
        onClick: onClose,
        "aria-label": "Close",
        className: "".concat(prefixCls, "-close")
      }, closeIcon || /* @__PURE__ */ React.createElement("span", {
        className: "".concat(prefixCls, "-close-x")
      }));
    }
    var content = /* @__PURE__ */ React.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, closer, headerNode, /* @__PURE__ */ React.createElement("div", _extends$2({
      className: "".concat(prefixCls, "-body"),
      style: bodyStyle
    }, bodyProps), children), footerNode);
    return /* @__PURE__ */ React.createElement("div", {
      key: "dialog-element",
      role: "dialog",
      "aria-labelledby": title ? ariaId : null,
      "aria-modal": "true",
      ref: holderRef,
      style: _objectSpread2(_objectSpread2({}, style2), contentStyle),
      className: classNames(prefixCls, className),
      onMouseDown,
      onMouseUp
    }, /* @__PURE__ */ React.createElement("div", {
      tabIndex: 0,
      ref: sentinelStartRef,
      style: sentinelStyle,
      "aria-hidden": "true"
    }), /* @__PURE__ */ React.createElement(MemoChildren, {
      shouldUpdate: visible || forceRender
    }, modalRender ? modalRender(content) : content), /* @__PURE__ */ React.createElement("div", {
      tabIndex: 0,
      ref: sentinelEndRef,
      style: sentinelStyle,
      "aria-hidden": "true"
    }));
  });
  var Content$1 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var prefixCls = props.prefixCls, title = props.title, style2 = props.style, className = props.className, visible = props.visible, forceRender = props.forceRender, destroyOnClose = props.destroyOnClose, motionName = props.motionName, ariaId = props.ariaId, onVisibleChanged = props.onVisibleChanged, mousePosition2 = props.mousePosition;
    var dialogRef = React.useRef();
    var _React$useState = React__namespace.useState(), _React$useState2 = _slicedToArray(_React$useState, 2), transformOrigin = _React$useState2[0], setTransformOrigin = _React$useState2[1];
    var contentStyle = {};
    if (transformOrigin) {
      contentStyle.transformOrigin = transformOrigin;
    }
    function onPrepare() {
      var elementOffset = offset(dialogRef.current);
      setTransformOrigin(mousePosition2 ? "".concat(mousePosition2.x - elementOffset.left, "px ").concat(mousePosition2.y - elementOffset.top, "px") : "");
    }
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      visible,
      onVisibleChanged,
      onAppearPrepare: onPrepare,
      onEnterPrepare: onPrepare,
      forceRender,
      motionName,
      removeOnLeave: destroyOnClose,
      ref: dialogRef
    }, function(_ref, motionRef) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      return /* @__PURE__ */ React__namespace.createElement(Panel, _extends$2({}, props, {
        ref,
        title,
        ariaId,
        prefixCls,
        holderRef: motionRef,
        style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), style2), contentStyle),
        className: classNames(className, motionClassName)
      }));
    });
  });
  Content$1.displayName = "Content";
  function Mask$1(props) {
    var prefixCls = props.prefixCls, style2 = props.style, visible = props.visible, maskProps = props.maskProps, motionName = props.motionName;
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      key: "mask",
      visible,
      motionName,
      leavedClassName: "".concat(prefixCls, "-mask-hidden")
    }, function(_ref, ref) {
      var motionClassName = _ref.className, motionStyle = _ref.style;
      return /* @__PURE__ */ React__namespace.createElement("div", _extends$2({
        ref,
        style: _objectSpread2(_objectSpread2({}, motionStyle), style2),
        className: classNames("".concat(prefixCls, "-mask"), motionClassName)
      }, maskProps));
    });
  }
  function Dialog(props) {
    var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-dialog" : _props$prefixCls, zIndex = props.zIndex, _props$visible = props.visible, visible = _props$visible === void 0 ? false : _props$visible, _props$keyboard = props.keyboard, keyboard = _props$keyboard === void 0 ? true : _props$keyboard, _props$focusTriggerAf = props.focusTriggerAfterClose, focusTriggerAfterClose = _props$focusTriggerAf === void 0 ? true : _props$focusTriggerAf, wrapStyle = props.wrapStyle, wrapClassName = props.wrapClassName, wrapProps = props.wrapProps, onClose = props.onClose, afterOpenChange = props.afterOpenChange, afterClose = props.afterClose, transitionName = props.transitionName, animation = props.animation, _props$closable = props.closable, closable = _props$closable === void 0 ? true : _props$closable, _props$mask = props.mask, mask = _props$mask === void 0 ? true : _props$mask, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, maskStyle = props.maskStyle, maskProps = props.maskProps, rootClassName = props.rootClassName;
    var lastOutSideActiveElementRef = React.useRef();
    var wrapperRef = React.useRef();
    var contentRef = React.useRef();
    var _React$useState = React__namespace.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
    var ariaId = useId();
    function saveLastOutSideActiveElementRef() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        lastOutSideActiveElementRef.current = document.activeElement;
      }
    }
    function focusDialogContent() {
      if (!contains(wrapperRef.current, document.activeElement)) {
        var _contentRef$current;
        (_contentRef$current = contentRef.current) === null || _contentRef$current === void 0 ? void 0 : _contentRef$current.focus();
      }
    }
    function onDialogVisibleChanged(newVisible) {
      if (newVisible) {
        focusDialogContent();
      } else {
        setAnimatedVisible(false);
        if (mask && lastOutSideActiveElementRef.current && focusTriggerAfterClose) {
          try {
            lastOutSideActiveElementRef.current.focus({
              preventScroll: true
            });
          } catch (e2) {
          }
          lastOutSideActiveElementRef.current = null;
        }
        if (animatedVisible) {
          afterClose === null || afterClose === void 0 ? void 0 : afterClose();
        }
      }
      afterOpenChange === null || afterOpenChange === void 0 ? void 0 : afterOpenChange(newVisible);
    }
    function onInternalClose(e2) {
      onClose === null || onClose === void 0 ? void 0 : onClose(e2);
    }
    var contentClickRef = React.useRef(false);
    var contentTimeoutRef = React.useRef();
    var onContentMouseDown = function onContentMouseDown2() {
      clearTimeout(contentTimeoutRef.current);
      contentClickRef.current = true;
    };
    var onContentMouseUp = function onContentMouseUp2() {
      contentTimeoutRef.current = setTimeout(function() {
        contentClickRef.current = false;
      });
    };
    var onWrapperClick = null;
    if (maskClosable) {
      onWrapperClick = function onWrapperClick2(e2) {
        if (contentClickRef.current) {
          contentClickRef.current = false;
        } else if (wrapperRef.current === e2.target) {
          onInternalClose(e2);
        }
      };
    }
    function onWrapperKeyDown(e2) {
      if (keyboard && e2.keyCode === KeyCode.ESC) {
        e2.stopPropagation();
        onInternalClose(e2);
        return;
      }
      if (visible) {
        if (e2.keyCode === KeyCode.TAB) {
          contentRef.current.changeActive(!e2.shiftKey);
        }
      }
    }
    React.useEffect(function() {
      if (visible) {
        setAnimatedVisible(true);
        saveLastOutSideActiveElementRef();
      }
    }, [visible]);
    React.useEffect(function() {
      return function() {
        clearTimeout(contentTimeoutRef.current);
      };
    }, []);
    return /* @__PURE__ */ React__namespace.createElement("div", _extends$2({
      className: classNames("".concat(prefixCls, "-root"), rootClassName)
    }, pickAttrs(props, {
      data: true
    })), /* @__PURE__ */ React__namespace.createElement(Mask$1, {
      prefixCls,
      visible: mask && visible,
      motionName: getMotionName(prefixCls, maskTransitionName, maskAnimation),
      style: _objectSpread2({
        zIndex
      }, maskStyle),
      maskProps
    }), /* @__PURE__ */ React__namespace.createElement("div", _extends$2({
      tabIndex: -1,
      onKeyDown: onWrapperKeyDown,
      className: classNames("".concat(prefixCls, "-wrap"), wrapClassName),
      ref: wrapperRef,
      onClick: onWrapperClick,
      style: _objectSpread2(_objectSpread2({
        zIndex
      }, wrapStyle), {}, {
        display: !animatedVisible ? "none" : null
      })
    }, wrapProps), /* @__PURE__ */ React__namespace.createElement(Content$1, _extends$2({}, props, {
      onMouseDown: onContentMouseDown,
      onMouseUp: onContentMouseUp,
      ref: contentRef,
      closable,
      ariaId,
      prefixCls,
      visible: visible && animatedVisible,
      onClose: onInternalClose,
      onVisibleChanged: onDialogVisibleChanged,
      motionName: getMotionName(prefixCls, transitionName, animation)
    }))));
  }
  var DialogWrap = function DialogWrap2(props) {
    var visible = props.visible, getContainer2 = props.getContainer, forceRender = props.forceRender, _props$destroyOnClose = props.destroyOnClose, destroyOnClose = _props$destroyOnClose === void 0 ? false : _props$destroyOnClose, _afterClose = props.afterClose;
    var _React$useState = React__namespace.useState(visible), _React$useState2 = _slicedToArray(_React$useState, 2), animatedVisible = _React$useState2[0], setAnimatedVisible = _React$useState2[1];
    React__namespace.useEffect(function() {
      if (visible) {
        setAnimatedVisible(true);
      }
    }, [visible]);
    if (!forceRender && destroyOnClose && !animatedVisible) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(Portal, {
      open: visible || forceRender || animatedVisible,
      autoDestroy: false,
      getContainer: getContainer2,
      autoLock: visible || animatedVisible
    }, /* @__PURE__ */ React__namespace.createElement(Dialog, _extends$2({}, props, {
      destroyOnClose,
      afterClose: function afterClose() {
        _afterClose === null || _afterClose === void 0 ? void 0 : _afterClose();
        setAnimatedVisible(false);
      }
    })));
  };
  DialogWrap.displayName = "Dialog";
  const canUseDocElement = () => canUseDom() && window.document.documentElement;
  var HOOK_MARK = "RC_FORM_INTERNAL_HOOKS";
  var warningFunc = function warningFunc2() {
    warningOnce(false, "Can not find FormContext. Please make sure you wrap Field under Form.");
  };
  var Context = /* @__PURE__ */ React__namespace.createContext({
    getFieldValue: warningFunc,
    getFieldsValue: warningFunc,
    getFieldError: warningFunc,
    getFieldWarning: warningFunc,
    getFieldsError: warningFunc,
    isFieldsTouched: warningFunc,
    isFieldTouched: warningFunc,
    isFieldValidating: warningFunc,
    isFieldsValidating: warningFunc,
    resetFields: warningFunc,
    setFields: warningFunc,
    setFieldValue: warningFunc,
    setFieldsValue: warningFunc,
    validateFields: warningFunc,
    submit: warningFunc,
    getInternalHooks: function getInternalHooks() {
      warningFunc();
      return {
        dispatch: warningFunc,
        initEntityValue: warningFunc,
        registerField: warningFunc,
        useSubscribe: warningFunc,
        setInitialValues: warningFunc,
        destroyForm: warningFunc,
        setCallbacks: warningFunc,
        registerWatch: warningFunc,
        getFields: warningFunc,
        setValidateMessages: warningFunc,
        setPreserve: warningFunc,
        getInitialValue: warningFunc
      };
    }
  });
  var ListContext = /* @__PURE__ */ React__namespace.createContext(null);
  function toArray$2(value) {
    if (value === void 0 || value === null) {
      return [];
    }
    return Array.isArray(value) ? value : [value];
  }
  function isFormInstance(form) {
    return form && !!form._init;
  }
  function _extends$1() {
    _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends$1.apply(this, arguments);
  }
  function _inheritsLoose$1(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf$1(subClass, superClass);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _setPrototypeOf$1(o, p2) {
    _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf$1(o, p2);
  }
  function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
      }));
      return true;
    } catch (e2) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (_isNativeReflectConstruct()) {
      _construct = Reflect.construct.bind();
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf$1(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf$1(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  var formatRegExp = /%[sdj%]/g;
  var warning = function warning2() {
  };
  if (typeof process !== "undefined" && process.env && false) {
    warning = function warning3(type4, errors) {
      if (typeof console !== "undefined" && console.warn && typeof ASYNC_VALIDATOR_NO_WARNING === "undefined") {
        if (errors.every(function(e2) {
          return typeof e2 === "string";
        })) {
          console.warn(type4, errors);
        }
      }
    };
  }
  function convertFieldsError(errors) {
    if (!errors || !errors.length)
      return null;
    var fields = {};
    errors.forEach(function(error) {
      var field = error.field;
      fields[field] = fields[field] || [];
      fields[field].push(error);
    });
    return fields;
  }
  function format(template) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    var i = 0;
    var len = args.length;
    if (typeof template === "function") {
      return template.apply(null, args);
    }
    if (typeof template === "string") {
      var str = template.replace(formatRegExp, function(x2) {
        if (x2 === "%%") {
          return "%";
        }
        if (i >= len) {
          return x2;
        }
        switch (x2) {
          case "%s":
            return String(args[i++]);
          case "%d":
            return Number(args[i++]);
          case "%j":
            try {
              return JSON.stringify(args[i++]);
            } catch (_2) {
              return "[Circular]";
            }
            break;
          default:
            return x2;
        }
      });
      return str;
    }
    return template;
  }
  function isNativeStringType(type4) {
    return type4 === "string" || type4 === "url" || type4 === "hex" || type4 === "email" || type4 === "date" || type4 === "pattern";
  }
  function isEmptyValue(value, type4) {
    if (value === void 0 || value === null) {
      return true;
    }
    if (type4 === "array" && Array.isArray(value) && !value.length) {
      return true;
    }
    if (isNativeStringType(type4) && typeof value === "string" && !value) {
      return true;
    }
    return false;
  }
  function asyncParallelArray(arr, func, callback) {
    var results = [];
    var total = 0;
    var arrLength = arr.length;
    function count(errors) {
      results.push.apply(results, errors || []);
      total++;
      if (total === arrLength) {
        callback(results);
      }
    }
    arr.forEach(function(a) {
      func(a, count);
    });
  }
  function asyncSerialArray(arr, func, callback) {
    var index2 = 0;
    var arrLength = arr.length;
    function next2(errors) {
      if (errors && errors.length) {
        callback(errors);
        return;
      }
      var original = index2;
      index2 = index2 + 1;
      if (original < arrLength) {
        func(arr[original], next2);
      } else {
        callback([]);
      }
    }
    next2([]);
  }
  function flattenObjArr(objArr) {
    var ret = [];
    Object.keys(objArr).forEach(function(k2) {
      ret.push.apply(ret, objArr[k2] || []);
    });
    return ret;
  }
  var AsyncValidationError = /* @__PURE__ */ function(_Error) {
    _inheritsLoose$1(AsyncValidationError2, _Error);
    function AsyncValidationError2(errors, fields) {
      var _this;
      _this = _Error.call(this, "Async Validation Error") || this;
      _this.errors = errors;
      _this.fields = fields;
      return _this;
    }
    return AsyncValidationError2;
  }(/* @__PURE__ */ _wrapNativeSuper(Error));
  function asyncMap(objArr, option, func, callback, source) {
    if (option.first) {
      var _pending = new Promise(function(resolve, reject) {
        var next2 = function next3(errors) {
          callback(errors);
          return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
        };
        var flattenArr = flattenObjArr(objArr);
        asyncSerialArray(flattenArr, func, next2);
      });
      _pending["catch"](function(e2) {
        return e2;
      });
      return _pending;
    }
    var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
    var objArrKeys = Object.keys(objArr);
    var objArrLength = objArrKeys.length;
    var total = 0;
    var results = [];
    var pending = new Promise(function(resolve, reject) {
      var next2 = function next3(errors) {
        results.push.apply(results, errors);
        total++;
        if (total === objArrLength) {
          callback(results);
          return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
        }
      };
      if (!objArrKeys.length) {
        callback(results);
        resolve(source);
      }
      objArrKeys.forEach(function(key) {
        var arr = objArr[key];
        if (firstFields.indexOf(key) !== -1) {
          asyncSerialArray(arr, func, next2);
        } else {
          asyncParallelArray(arr, func, next2);
        }
      });
    });
    pending["catch"](function(e2) {
      return e2;
    });
    return pending;
  }
  function isErrorObj(obj) {
    return !!(obj && obj.message !== void 0);
  }
  function getValue(value, path2) {
    var v2 = value;
    for (var i = 0; i < path2.length; i++) {
      if (v2 == void 0) {
        return v2;
      }
      v2 = v2[path2[i]];
    }
    return v2;
  }
  function complementError(rule, source) {
    return function(oe) {
      var fieldValue;
      if (rule.fullFields) {
        fieldValue = getValue(source, rule.fullFields);
      } else {
        fieldValue = source[oe.field || rule.fullField];
      }
      if (isErrorObj(oe)) {
        oe.field = oe.field || rule.fullField;
        oe.fieldValue = fieldValue;
        return oe;
      }
      return {
        message: typeof oe === "function" ? oe() : oe,
        fieldValue,
        field: oe.field || rule.fullField
      };
    };
  }
  function deepMerge(target, source) {
    if (source) {
      for (var s in source) {
        if (source.hasOwnProperty(s)) {
          var value = source[s];
          if (typeof value === "object" && typeof target[s] === "object") {
            target[s] = _extends$1({}, target[s], value);
          } else {
            target[s] = value;
          }
        }
      }
    }
    return target;
  }
  var required$1 = function required(rule, value, source, errors, options, type4) {
    if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type4 || rule.type))) {
      errors.push(format(options.messages.required, rule.fullField));
    }
  };
  var whitespace = function whitespace2(rule, value, source, errors, options) {
    if (/^\s+$/.test(value) || value === "") {
      errors.push(format(options.messages.whitespace, rule.fullField));
    }
  };
  var urlReg;
  var getUrlRegex = function() {
    if (urlReg) {
      return urlReg;
    }
    var word = "[a-fA-F\\d:]";
    var b2 = function b3(options) {
      return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=" + word + ")|(?<=" + word + ")(?=\\s|$))" : "";
    };
    var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
    var v6seg = "[a-fA-F\\d]{1,4}";
    var v6 = ("\n(?:\n(?:" + v6seg + ":){7}(?:" + v6seg + "|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8\n(?:" + v6seg + ":){6}(?:" + v4 + "|:" + v6seg + "|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4\n(?:" + v6seg + ":){5}(?::" + v4 + "|(?::" + v6seg + "){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4\n(?:" + v6seg + ":){4}(?:(?::" + v6seg + "){0,1}:" + v4 + "|(?::" + v6seg + "){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4\n(?:" + v6seg + ":){3}(?:(?::" + v6seg + "){0,2}:" + v4 + "|(?::" + v6seg + "){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4\n(?:" + v6seg + ":){2}(?:(?::" + v6seg + "){0,3}:" + v4 + "|(?::" + v6seg + "){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4\n(?:" + v6seg + ":){1}(?:(?::" + v6seg + "){0,4}:" + v4 + "|(?::" + v6seg + "){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4\n(?::(?:(?::" + v6seg + "){0,5}:" + v4 + "|(?::" + v6seg + "){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4\n)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1\n").replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
    var v46Exact = new RegExp("(?:^" + v4 + "$)|(?:^" + v6 + "$)");
    var v4exact = new RegExp("^" + v4 + "$");
    var v6exact = new RegExp("^" + v6 + "$");
    var ip = function ip2(options) {
      return options && options.exact ? v46Exact : new RegExp("(?:" + b2(options) + v4 + b2(options) + ")|(?:" + b2(options) + v6 + b2(options) + ")", "g");
    };
    ip.v4 = function(options) {
      return options && options.exact ? v4exact : new RegExp("" + b2(options) + v4 + b2(options), "g");
    };
    ip.v6 = function(options) {
      return options && options.exact ? v6exact : new RegExp("" + b2(options) + v6 + b2(options), "g");
    };
    var protocol = "(?:(?:[a-z]+:)?//)";
    var auth = "(?:\\S+(?::\\S*)?@)?";
    var ipv4 = ip.v4().source;
    var ipv6 = ip.v6().source;
    var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
    var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
    var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
    var port = "(?::\\d{2,5})?";
    var path2 = '(?:[/?#][^\\s"]*)?';
    var regex = "(?:" + protocol + "|www\\.)" + auth + "(?:localhost|" + ipv4 + "|" + ipv6 + "|" + host + domain + tld + ")" + port + path2;
    urlReg = new RegExp("(?:^" + regex + "$)", "i");
    return urlReg;
  };
  var pattern$2 = {
    // http://emailregex.com/
    email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
    // url: new RegExp(
    //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
    //   'i',
    // ),
    hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
  };
  var types = {
    integer: function integer(value) {
      return types.number(value) && parseInt(value, 10) === value;
    },
    "float": function float(value) {
      return types.number(value) && !types.integer(value);
    },
    array: function array(value) {
      return Array.isArray(value);
    },
    regexp: function regexp(value) {
      if (value instanceof RegExp) {
        return true;
      }
      try {
        return !!new RegExp(value);
      } catch (e2) {
        return false;
      }
    },
    date: function date(value) {
      return typeof value.getTime === "function" && typeof value.getMonth === "function" && typeof value.getYear === "function" && !isNaN(value.getTime());
    },
    number: function number(value) {
      if (isNaN(value)) {
        return false;
      }
      return typeof value === "number";
    },
    object: function object(value) {
      return typeof value === "object" && !types.array(value);
    },
    method: function method(value) {
      return typeof value === "function";
    },
    email: function email(value) {
      return typeof value === "string" && value.length <= 320 && !!value.match(pattern$2.email);
    },
    url: function url(value) {
      return typeof value === "string" && value.length <= 2048 && !!value.match(getUrlRegex());
    },
    hex: function hex(value) {
      return typeof value === "string" && !!value.match(pattern$2.hex);
    }
  };
  var type$1 = function type(rule, value, source, errors, options) {
    if (rule.required && value === void 0) {
      required$1(rule, value, source, errors, options);
      return;
    }
    var custom = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"];
    var ruleType = rule.type;
    if (custom.indexOf(ruleType) > -1) {
      if (!types[ruleType](value)) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    } else if (ruleType && typeof value !== rule.type) {
      errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
    }
  };
  var range = function range2(rule, value, source, errors, options) {
    var len = typeof rule.len === "number";
    var min = typeof rule.min === "number";
    var max = typeof rule.max === "number";
    var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
    var val = value;
    var key = null;
    var num = typeof value === "number";
    var str = typeof value === "string";
    var arr = Array.isArray(value);
    if (num) {
      key = "number";
    } else if (str) {
      key = "string";
    } else if (arr) {
      key = "array";
    }
    if (!key) {
      return false;
    }
    if (arr) {
      val = value.length;
    }
    if (str) {
      val = value.replace(spRegexp, "_").length;
    }
    if (len) {
      if (val !== rule.len) {
        errors.push(format(options.messages[key].len, rule.fullField, rule.len));
      }
    } else if (min && !max && val < rule.min) {
      errors.push(format(options.messages[key].min, rule.fullField, rule.min));
    } else if (max && !min && val > rule.max) {
      errors.push(format(options.messages[key].max, rule.fullField, rule.max));
    } else if (min && max && (val < rule.min || val > rule.max)) {
      errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
    }
  };
  var ENUM$1 = "enum";
  var enumerable$1 = function enumerable(rule, value, source, errors, options) {
    rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
    if (rule[ENUM$1].indexOf(value) === -1) {
      errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(", ")));
    }
  };
  var pattern$1 = function pattern(rule, value, source, errors, options) {
    if (rule.pattern) {
      if (rule.pattern instanceof RegExp) {
        rule.pattern.lastIndex = 0;
        if (!rule.pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      } else if (typeof rule.pattern === "string") {
        var _pattern = new RegExp(rule.pattern);
        if (!_pattern.test(value)) {
          errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
        }
      }
    }
  };
  var rules = {
    required: required$1,
    whitespace,
    type: type$1,
    range,
    "enum": enumerable$1,
    pattern: pattern$1
  };
  var string = function string2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "string");
      if (!isEmptyValue(value, "string")) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
        rules.pattern(rule, value, source, errors, options);
        if (rule.whitespace === true) {
          rules.whitespace(rule, value, source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var method2 = function method3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var number2 = function number3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (value === "") {
        value = void 0;
      }
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var _boolean = function _boolean2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var regexp2 = function regexp3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var integer2 = function integer3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var floatFn = function floatFn2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var array2 = function array3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if ((value === void 0 || value === null) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, "array");
      if (value !== void 0 && value !== null) {
        rules.type(rule, value, source, errors, options);
        rules.range(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var object$1 = function object2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var ENUM = "enum";
  var enumerable2 = function enumerable3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (value !== void 0) {
        rules[ENUM](rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var pattern2 = function pattern3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "string") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "string")) {
        rules.pattern(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var date2 = function date3(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, "date") && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
      if (!isEmptyValue(value, "date")) {
        var dateObject;
        if (value instanceof Date) {
          dateObject = value;
        } else {
          dateObject = new Date(value);
        }
        rules.type(rule, dateObject, source, errors, options);
        if (dateObject) {
          rules.range(rule, dateObject.getTime(), source, errors, options);
        }
      }
    }
    callback(errors);
  };
  var required2 = function required3(rule, value, callback, source, options) {
    var errors = [];
    var type4 = Array.isArray(value) ? "array" : typeof value;
    rules.required(rule, value, source, errors, options, type4);
    callback(errors);
  };
  var type2 = function type3(rule, value, callback, source, options) {
    var ruleType = rule.type;
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value, ruleType) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options, ruleType);
      if (!isEmptyValue(value, ruleType)) {
        rules.type(rule, value, source, errors, options);
      }
    }
    callback(errors);
  };
  var any = function any2(rule, value, callback, source, options) {
    var errors = [];
    var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
    if (validate) {
      if (isEmptyValue(value) && !rule.required) {
        return callback();
      }
      rules.required(rule, value, source, errors, options);
    }
    callback(errors);
  };
  var validators$2 = {
    string,
    method: method2,
    number: number2,
    "boolean": _boolean,
    regexp: regexp2,
    integer: integer2,
    "float": floatFn,
    array: array2,
    object: object$1,
    "enum": enumerable2,
    pattern: pattern2,
    date: date2,
    url: type2,
    hex: type2,
    email: type2,
    required: required2,
    any
  };
  function newMessages() {
    return {
      "default": "Validation error on field %s",
      required: "%s is required",
      "enum": "%s must be one of %s",
      whitespace: "%s cannot be empty",
      date: {
        format: "%s date %s is invalid for format %s",
        parse: "%s date could not be parsed, %s is invalid ",
        invalid: "%s date %s is invalid"
      },
      types: {
        string: "%s is not a %s",
        method: "%s is not a %s (function)",
        array: "%s is not an %s",
        object: "%s is not an %s",
        number: "%s is not a %s",
        date: "%s is not a %s",
        "boolean": "%s is not a %s",
        integer: "%s is not an %s",
        "float": "%s is not a %s",
        regexp: "%s is not a valid %s",
        email: "%s is not a valid %s",
        url: "%s is not a valid %s",
        hex: "%s is not a valid %s"
      },
      string: {
        len: "%s must be exactly %s characters",
        min: "%s must be at least %s characters",
        max: "%s cannot be longer than %s characters",
        range: "%s must be between %s and %s characters"
      },
      number: {
        len: "%s must equal %s",
        min: "%s cannot be less than %s",
        max: "%s cannot be greater than %s",
        range: "%s must be between %s and %s"
      },
      array: {
        len: "%s must be exactly %s in length",
        min: "%s cannot be less than %s in length",
        max: "%s cannot be greater than %s in length",
        range: "%s must be between %s and %s in length"
      },
      pattern: {
        mismatch: "%s value %s does not match pattern %s"
      },
      clone: function clone() {
        var cloned = JSON.parse(JSON.stringify(this));
        cloned.clone = this.clone;
        return cloned;
      }
    };
  }
  var messages = newMessages();
  var Schema = /* @__PURE__ */ function() {
    function Schema2(descriptor) {
      this.rules = null;
      this._messages = messages;
      this.define(descriptor);
    }
    var _proto = Schema2.prototype;
    _proto.define = function define(rules2) {
      var _this = this;
      if (!rules2) {
        throw new Error("Cannot configure a schema with no rules");
      }
      if (typeof rules2 !== "object" || Array.isArray(rules2)) {
        throw new Error("Rules must be an object");
      }
      this.rules = {};
      Object.keys(rules2).forEach(function(name) {
        var item = rules2[name];
        _this.rules[name] = Array.isArray(item) ? item : [item];
      });
    };
    _proto.messages = function messages2(_messages) {
      if (_messages) {
        this._messages = deepMerge(newMessages(), _messages);
      }
      return this._messages;
    };
    _proto.validate = function validate(source_, o, oc) {
      var _this2 = this;
      if (o === void 0) {
        o = {};
      }
      if (oc === void 0) {
        oc = function oc2() {
        };
      }
      var source = source_;
      var options = o;
      var callback = oc;
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      if (!this.rules || Object.keys(this.rules).length === 0) {
        if (callback) {
          callback(null, source);
        }
        return Promise.resolve(source);
      }
      function complete(results) {
        var errors = [];
        var fields = {};
        function add(e2) {
          if (Array.isArray(e2)) {
            var _errors;
            errors = (_errors = errors).concat.apply(_errors, e2);
          } else {
            errors.push(e2);
          }
        }
        for (var i = 0; i < results.length; i++) {
          add(results[i]);
        }
        if (!errors.length) {
          callback(null, source);
        } else {
          fields = convertFieldsError(errors);
          callback(errors, fields);
        }
      }
      if (options.messages) {
        var messages$1 = this.messages();
        if (messages$1 === messages) {
          messages$1 = newMessages();
        }
        deepMerge(messages$1, options.messages);
        options.messages = messages$1;
      } else {
        options.messages = this.messages();
      }
      var series = {};
      var keys2 = options.keys || Object.keys(this.rules);
      keys2.forEach(function(z2) {
        var arr = _this2.rules[z2];
        var value = source[z2];
        arr.forEach(function(r2) {
          var rule = r2;
          if (typeof rule.transform === "function") {
            if (source === source_) {
              source = _extends$1({}, source);
            }
            value = source[z2] = rule.transform(value);
          }
          if (typeof rule === "function") {
            rule = {
              validator: rule
            };
          } else {
            rule = _extends$1({}, rule);
          }
          rule.validator = _this2.getValidationMethod(rule);
          if (!rule.validator) {
            return;
          }
          rule.field = z2;
          rule.fullField = rule.fullField || z2;
          rule.type = _this2.getType(rule);
          series[z2] = series[z2] || [];
          series[z2].push({
            rule,
            value,
            source,
            field: z2
          });
        });
      });
      var errorFields = {};
      return asyncMap(series, options, function(data, doIt) {
        var rule = data.rule;
        var deep = (rule.type === "object" || rule.type === "array") && (typeof rule.fields === "object" || typeof rule.defaultField === "object");
        deep = deep && (rule.required || !rule.required && data.value);
        rule.field = data.field;
        function addFullField(key, schema) {
          return _extends$1({}, schema, {
            fullField: rule.fullField + "." + key,
            fullFields: rule.fullFields ? [].concat(rule.fullFields, [key]) : [key]
          });
        }
        function cb(e2) {
          if (e2 === void 0) {
            e2 = [];
          }
          var errorList = Array.isArray(e2) ? e2 : [e2];
          if (!options.suppressWarning && errorList.length) {
            Schema2.warning("async-validator:", errorList);
          }
          if (errorList.length && rule.message !== void 0) {
            errorList = [].concat(rule.message);
          }
          var filledErrors = errorList.map(complementError(rule, source));
          if (options.first && filledErrors.length) {
            errorFields[rule.field] = 1;
            return doIt(filledErrors);
          }
          if (!deep) {
            doIt(filledErrors);
          } else {
            if (rule.required && !data.value) {
              if (rule.message !== void 0) {
                filledErrors = [].concat(rule.message).map(complementError(rule, source));
              } else if (options.error) {
                filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
              }
              return doIt(filledErrors);
            }
            var fieldsSchema = {};
            if (rule.defaultField) {
              Object.keys(data.value).map(function(key) {
                fieldsSchema[key] = rule.defaultField;
              });
            }
            fieldsSchema = _extends$1({}, fieldsSchema, data.rule.fields);
            var paredFieldsSchema = {};
            Object.keys(fieldsSchema).forEach(function(field) {
              var fieldSchema = fieldsSchema[field];
              var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
              paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
            });
            var schema = new Schema2(paredFieldsSchema);
            schema.messages(options.messages);
            if (data.rule.options) {
              data.rule.options.messages = options.messages;
              data.rule.options.error = options.error;
            }
            schema.validate(data.value, data.rule.options || options, function(errs) {
              var finalErrors = [];
              if (filledErrors && filledErrors.length) {
                finalErrors.push.apply(finalErrors, filledErrors);
              }
              if (errs && errs.length) {
                finalErrors.push.apply(finalErrors, errs);
              }
              doIt(finalErrors.length ? finalErrors : null);
            });
          }
        }
        var res;
        if (rule.asyncValidator) {
          res = rule.asyncValidator(rule, data.value, cb, data.source, options);
        } else if (rule.validator) {
          try {
            res = rule.validator(rule, data.value, cb, data.source, options);
          } catch (error) {
            console.error == null ? void 0 : console.error(error);
            if (!options.suppressValidatorError) {
              setTimeout(function() {
                throw error;
              }, 0);
            }
            cb(error.message);
          }
          if (res === true) {
            cb();
          } else if (res === false) {
            cb(typeof rule.message === "function" ? rule.message(rule.fullField || rule.field) : rule.message || (rule.fullField || rule.field) + " fails");
          } else if (res instanceof Array) {
            cb(res);
          } else if (res instanceof Error) {
            cb(res.message);
          }
        }
        if (res && res.then) {
          res.then(function() {
            return cb();
          }, function(e2) {
            return cb(e2);
          });
        }
      }, function(results) {
        complete(results);
      }, source);
    };
    _proto.getType = function getType(rule) {
      if (rule.type === void 0 && rule.pattern instanceof RegExp) {
        rule.type = "pattern";
      }
      if (typeof rule.validator !== "function" && rule.type && !validators$2.hasOwnProperty(rule.type)) {
        throw new Error(format("Unknown rule type %s", rule.type));
      }
      return rule.type || "string";
    };
    _proto.getValidationMethod = function getValidationMethod(rule) {
      if (typeof rule.validator === "function") {
        return rule.validator;
      }
      var keys2 = Object.keys(rule);
      var messageIndex = keys2.indexOf("message");
      if (messageIndex !== -1) {
        keys2.splice(messageIndex, 1);
      }
      if (keys2.length === 1 && keys2[0] === "required") {
        return validators$2.required;
      }
      return validators$2[this.getType(rule)] || void 0;
    };
    return Schema2;
  }();
  Schema.register = function register(type4, validator2) {
    if (typeof validator2 !== "function") {
      throw new Error("Cannot register a validator by type, validator is not a function");
    }
    validators$2[type4] = validator2;
  };
  Schema.warning = warning;
  Schema.messages = messages;
  Schema.validators = validators$2;
  var typeTemplate = "'${name}' is not a valid ${type}";
  var defaultValidateMessages = {
    default: "Validation error on field '${name}'",
    required: "'${name}' is required",
    enum: "'${name}' must be one of [${enum}]",
    whitespace: "'${name}' cannot be empty",
    date: {
      format: "'${name}' is invalid for format date",
      parse: "'${name}' could not be parsed as date",
      invalid: "'${name}' is invalid date"
    },
    types: {
      string: typeTemplate,
      method: typeTemplate,
      array: typeTemplate,
      object: typeTemplate,
      number: typeTemplate,
      date: typeTemplate,
      boolean: typeTemplate,
      integer: typeTemplate,
      float: typeTemplate,
      regexp: typeTemplate,
      email: typeTemplate,
      url: typeTemplate,
      hex: typeTemplate
    },
    string: {
      len: "'${name}' must be exactly ${len} characters",
      min: "'${name}' must be at least ${min} characters",
      max: "'${name}' cannot be longer than ${max} characters",
      range: "'${name}' must be between ${min} and ${max} characters"
    },
    number: {
      len: "'${name}' must equal ${len}",
      min: "'${name}' cannot be less than ${min}",
      max: "'${name}' cannot be greater than ${max}",
      range: "'${name}' must be between ${min} and ${max}"
    },
    array: {
      len: "'${name}' must be exactly ${len} in length",
      min: "'${name}' cannot be less than ${min} in length",
      max: "'${name}' cannot be greater than ${max} in length",
      range: "'${name}' must be between ${min} and ${max} in length"
    },
    pattern: {
      mismatch: "'${name}' does not match pattern ${pattern}"
    }
  };
  var AsyncValidator = Schema;
  function replaceMessage(template, kv) {
    return template.replace(/\$\{\w+\}/g, function(str) {
      var key = str.slice(2, -1);
      return kv[key];
    });
  }
  var CODE_LOGIC_ERROR = "CODE_LOGIC_ERROR";
  function validateRule(_x, _x2, _x3, _x4, _x5) {
    return _validateRule.apply(this, arguments);
  }
  function _validateRule() {
    _validateRule = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
      var cloneRule, originValidator, subRuleField, validator2, messages2, result, subResults, kv, fillVariableResult;
      return _regeneratorRuntime().wrap(function _callee2$(_context2) {
        while (1)
          switch (_context2.prev = _context2.next) {
            case 0:
              cloneRule = _objectSpread2({}, rule);
              delete cloneRule.ruleIndex;
              AsyncValidator.warning = function() {
                return void 0;
              };
              if (cloneRule.validator) {
                originValidator = cloneRule.validator;
                cloneRule.validator = function() {
                  try {
                    return originValidator.apply(void 0, arguments);
                  } catch (error) {
                    console.error(error);
                    return Promise.reject(CODE_LOGIC_ERROR);
                  }
                };
              }
              subRuleField = null;
              if (cloneRule && cloneRule.type === "array" && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }
              validator2 = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
              messages2 = merge$2(defaultValidateMessages, options.validateMessages);
              validator2.messages(messages2);
              result = [];
              _context2.prev = 10;
              _context2.next = 13;
              return Promise.resolve(validator2.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](10);
              if (_context2.t0.errors) {
                result = _context2.t0.errors.map(function(_ref4, index2) {
                  var message = _ref4.message;
                  var mergedMessage = message === CODE_LOGIC_ERROR ? messages2.default : message;
                  return /* @__PURE__ */ React__namespace.isValidElement(mergedMessage) ? (
                    // Wrap ReactNode with `key`
                    /* @__PURE__ */ React__namespace.cloneElement(mergedMessage, {
                      key: "error_".concat(index2)
                    })
                  ) : mergedMessage;
                });
              }
            case 18:
              if (!(!result.length && subRuleField)) {
                _context2.next = 23;
                break;
              }
              _context2.next = 21;
              return Promise.all(value.map(function(subValue, i) {
                return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
              }));
            case 21:
              subResults = _context2.sent;
              return _context2.abrupt("return", subResults.reduce(function(prev2, errors) {
                return [].concat(_toConsumableArray(prev2), _toConsumableArray(errors));
              }, []));
            case 23:
              kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                name,
                enum: (rule.enum || []).join(", ")
              }, messageVariables);
              fillVariableResult = result.map(function(error) {
                if (typeof error === "string") {
                  return replaceMessage(error, kv);
                }
                return error;
              });
              return _context2.abrupt("return", fillVariableResult);
            case 26:
            case "end":
              return _context2.stop();
          }
      }, _callee2, null, [[10, 15]]);
    }));
    return _validateRule.apply(this, arguments);
  }
  function validateRules(namePath, value, rules2, options, validateFirst, messageVariables) {
    var name = namePath.join(".");
    var filledRules = rules2.map(function(currentRule, ruleIndex) {
      var originValidatorFunc = currentRule.validator;
      var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
        ruleIndex
      });
      if (originValidatorFunc) {
        cloneRule.validator = function(rule, val, callback) {
          var hasPromise = false;
          var wrappedCallback = function wrappedCallback2() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            Promise.resolve().then(function() {
              warningOnce(!hasPromise, "Your validator function has already return a promise. `callback` will be ignored.");
              if (!hasPromise) {
                callback.apply(void 0, args);
              }
            });
          };
          var promise = originValidatorFunc(rule, val, wrappedCallback);
          hasPromise = promise && typeof promise.then === "function" && typeof promise.catch === "function";
          warningOnce(hasPromise, "`callback` is deprecated. Please return a promise instead.");
          if (hasPromise) {
            promise.then(function() {
              callback();
            }).catch(function(err) {
              callback(err || " ");
            });
          }
        };
      }
      return cloneRule;
    }).sort(function(_ref, _ref2) {
      var w1 = _ref.warningOnly, i1 = _ref.ruleIndex;
      var w2 = _ref2.warningOnly, i2 = _ref2.ruleIndex;
      if (!!w1 === !!w2) {
        return i1 - i2;
      }
      if (w1) {
        return 1;
      }
      return -1;
    });
    var summaryPromise;
    if (validateFirst === true) {
      summaryPromise = new Promise(/* @__PURE__ */ function() {
        var _ref3 = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee(resolve, reject) {
          var i, rule, errors;
          return _regeneratorRuntime().wrap(function _callee$(_context) {
            while (1)
              switch (_context.prev = _context.next) {
                case 0:
                  i = 0;
                case 1:
                  if (!(i < filledRules.length)) {
                    _context.next = 12;
                    break;
                  }
                  rule = filledRules[i];
                  _context.next = 5;
                  return validateRule(name, value, rule, options, messageVariables);
                case 5:
                  errors = _context.sent;
                  if (!errors.length) {
                    _context.next = 9;
                    break;
                  }
                  reject([{
                    errors,
                    rule
                  }]);
                  return _context.abrupt("return");
                case 9:
                  i += 1;
                  _context.next = 1;
                  break;
                case 12:
                  resolve([]);
                case 13:
                case "end":
                  return _context.stop();
              }
          }, _callee);
        }));
        return function(_x6, _x7) {
          return _ref3.apply(this, arguments);
        };
      }());
    } else {
      var rulePromises = filledRules.map(function(rule) {
        return validateRule(name, value, rule, options, messageVariables).then(function(errors) {
          return {
            errors,
            rule
          };
        });
      });
      summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function(errors) {
        return Promise.reject(errors);
      });
    }
    summaryPromise.catch(function(e2) {
      return e2;
    });
    return summaryPromise;
  }
  function finishOnAllFailed(_x8) {
    return _finishOnAllFailed.apply(this, arguments);
  }
  function _finishOnAllFailed() {
    _finishOnAllFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee3(rulePromises) {
      return _regeneratorRuntime().wrap(function _callee3$(_context3) {
        while (1)
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Promise.all(rulePromises).then(function(errorsList) {
                var _ref5;
                var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                return errors;
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
      }, _callee3);
    }));
    return _finishOnAllFailed.apply(this, arguments);
  }
  function finishOnFirstFailed(_x9) {
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function _finishOnFirstFailed() {
    _finishOnFirstFailed = _asyncToGenerator(/* @__PURE__ */ _regeneratorRuntime().mark(function _callee4(rulePromises) {
      var count;
      return _regeneratorRuntime().wrap(function _callee4$(_context4) {
        while (1)
          switch (_context4.prev = _context4.next) {
            case 0:
              count = 0;
              return _context4.abrupt("return", new Promise(function(resolve) {
                rulePromises.forEach(function(promise) {
                  promise.then(function(ruleError) {
                    if (ruleError.errors.length) {
                      resolve([ruleError]);
                    }
                    count += 1;
                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
      }, _callee4);
    }));
    return _finishOnFirstFailed.apply(this, arguments);
  }
  function getNamePath(path2) {
    return toArray$2(path2);
  }
  function cloneByNamePathList(store, namePathList) {
    var newStore = {};
    namePathList.forEach(function(namePath) {
      var value = get(store, namePath);
      newStore = set(newStore, namePath, value);
    });
    return newStore;
  }
  function containsNamePath(namePathList, namePath) {
    return namePathList && namePathList.some(function(path2) {
      return matchNamePath(path2, namePath);
    });
  }
  function matchNamePath(namePath, changedNamePath) {
    if (!namePath || !changedNamePath || namePath.length !== changedNamePath.length) {
      return false;
    }
    return namePath.every(function(nameUnit, i) {
      return changedNamePath[i] === nameUnit;
    });
  }
  function isSimilar(source, target) {
    if (source === target) {
      return true;
    }
    if (!source && target || source && !target) {
      return false;
    }
    if (!source || !target || _typeof(source) !== "object" || _typeof(target) !== "object") {
      return false;
    }
    var sourceKeys = Object.keys(source);
    var targetKeys = Object.keys(target);
    var keys2 = new Set([].concat(sourceKeys, targetKeys));
    return _toConsumableArray(keys2).every(function(key) {
      var sourceValue = source[key];
      var targetValue = target[key];
      if (typeof sourceValue === "function" && typeof targetValue === "function") {
        return true;
      }
      return sourceValue === targetValue;
    });
  }
  function defaultGetValueFromEvent(valuePropName) {
    var event = arguments.length <= 1 ? void 0 : arguments[1];
    if (event && event.target && _typeof(event.target) === "object" && valuePropName in event.target) {
      return event.target[valuePropName];
    }
    return event;
  }
  function move(array5, moveIndex, toIndex) {
    var length2 = array5.length;
    if (moveIndex < 0 || moveIndex >= length2 || toIndex < 0 || toIndex >= length2) {
      return array5;
    }
    var item = array5[moveIndex];
    var diff = moveIndex - toIndex;
    if (diff > 0) {
      return [].concat(_toConsumableArray(array5.slice(0, toIndex)), [item], _toConsumableArray(array5.slice(toIndex, moveIndex)), _toConsumableArray(array5.slice(moveIndex + 1, length2)));
    }
    if (diff < 0) {
      return [].concat(_toConsumableArray(array5.slice(0, moveIndex)), _toConsumableArray(array5.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array5.slice(toIndex + 1, length2)));
    }
    return array5;
  }
  var _excluded$4 = ["name"];
  var EMPTY_ERRORS = [];
  function requireUpdate(shouldUpdate, prev2, next2, prevValue, nextValue, info) {
    if (typeof shouldUpdate === "function") {
      return shouldUpdate(prev2, next2, "source" in info ? {
        source: info.source
      } : {});
    }
    return prevValue !== nextValue;
  }
  var Field = /* @__PURE__ */ function(_React$Component) {
    _inherits(Field2, _React$Component);
    var _super = _createSuper(Field2);
    function Field2(props) {
      var _this;
      _classCallCheck(this, Field2);
      _this = _super.call(this, props);
      _this.state = {
        resetCount: 0
      };
      _this.cancelRegisterFunc = null;
      _this.mounted = false;
      _this.touched = false;
      _this.dirty = false;
      _this.validatePromise = void 0;
      _this.prevValidating = void 0;
      _this.errors = EMPTY_ERRORS;
      _this.warnings = EMPTY_ERRORS;
      _this.cancelRegister = function() {
        var _this$props = _this.props, preserve = _this$props.preserve, isListField = _this$props.isListField, name = _this$props.name;
        if (_this.cancelRegisterFunc) {
          _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
        }
        _this.cancelRegisterFunc = null;
      };
      _this.getNamePath = function() {
        var _this$props2 = _this.props, name = _this$props2.name, fieldContext = _this$props2.fieldContext;
        var _fieldContext$prefixN = fieldContext.prefixName, prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
        return name !== void 0 ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
      };
      _this.getRules = function() {
        var _this$props3 = _this.props, _this$props3$rules = _this$props3.rules, rules2 = _this$props3$rules === void 0 ? [] : _this$props3$rules, fieldContext = _this$props3.fieldContext;
        return rules2.map(function(rule) {
          if (typeof rule === "function") {
            return rule(fieldContext);
          }
          return rule;
        });
      };
      _this.refresh = function() {
        if (!_this.mounted)
          return;
        _this.setState(function(_ref) {
          var resetCount = _ref.resetCount;
          return {
            resetCount: resetCount + 1
          };
        });
      };
      _this.triggerMetaEvent = function(destroy) {
        var onMetaChange = _this.props.onMetaChange;
        onMetaChange === null || onMetaChange === void 0 ? void 0 : onMetaChange(_objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
          destroy
        }));
      };
      _this.onStoreChange = function(prevStore, namePathList, info) {
        var _this$props4 = _this.props, shouldUpdate = _this$props4.shouldUpdate, _this$props4$dependen = _this$props4.dependencies, dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen, onReset = _this$props4.onReset;
        var store = info.store;
        var namePath = _this.getNamePath();
        var prevValue = _this.getValue(prevStore);
        var curValue = _this.getValue(store);
        var namePathMatch = namePathList && containsNamePath(namePathList, namePath);
        if (info.type === "valueUpdate" && info.source === "external" && prevValue !== curValue) {
          _this.touched = true;
          _this.dirty = true;
          _this.validatePromise = null;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();
        }
        switch (info.type) {
          case "reset":
            if (!namePathList || namePathMatch) {
              _this.touched = false;
              _this.dirty = false;
              _this.validatePromise = void 0;
              _this.errors = EMPTY_ERRORS;
              _this.warnings = EMPTY_ERRORS;
              _this.triggerMetaEvent();
              onReset === null || onReset === void 0 ? void 0 : onReset();
              _this.refresh();
              return;
            }
            break;
          case "remove": {
            if (shouldUpdate) {
              _this.reRender();
              return;
            }
            break;
          }
          case "setField": {
            if (namePathMatch) {
              var data = info.data;
              if ("touched" in data) {
                _this.touched = data.touched;
              }
              if ("validating" in data && !("originRCField" in data)) {
                _this.validatePromise = data.validating ? Promise.resolve([]) : null;
              }
              if ("errors" in data) {
                _this.errors = data.errors || EMPTY_ERRORS;
              }
              if ("warnings" in data) {
                _this.warnings = data.warnings || EMPTY_ERRORS;
              }
              _this.dirty = true;
              _this.triggerMetaEvent();
              _this.reRender();
              return;
            }
            if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
          }
          case "dependenciesUpdate": {
            var dependencyList = dependencies.map(getNamePath);
            if (dependencyList.some(function(dependency) {
              return containsNamePath(info.relatedFields, dependency);
            })) {
              _this.reRender();
              return;
            }
            break;
          }
          default:
            if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
              _this.reRender();
              return;
            }
            break;
        }
        if (shouldUpdate === true) {
          _this.reRender();
        }
      };
      _this.validateRules = function(options) {
        var namePath = _this.getNamePath();
        var currentValue = _this.getValue();
        var _ref2 = options || {}, triggerName = _ref2.triggerName, _ref2$validateOnly = _ref2.validateOnly, validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;
        var rootPromise = Promise.resolve().then(function() {
          if (!_this.mounted) {
            return [];
          }
          var _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables;
          var filteredRules = _this.getRules();
          if (triggerName) {
            filteredRules = filteredRules.filter(function(rule) {
              return rule;
            }).filter(function(rule) {
              var validateTrigger = rule.validateTrigger;
              if (!validateTrigger) {
                return true;
              }
              var triggerList = toArray$2(validateTrigger);
              return triggerList.includes(triggerName);
            });
          }
          var promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
          promise.catch(function(e2) {
            return e2;
          }).then(function() {
            var ruleErrors = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : EMPTY_ERRORS;
            if (_this.validatePromise === rootPromise) {
              var _ruleErrors$forEach;
              _this.validatePromise = null;
              var nextErrors = [];
              var nextWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref3) {
                var warningOnly = _ref3.rule.warningOnly, _ref3$errors = _ref3.errors, errors = _ref3$errors === void 0 ? EMPTY_ERRORS : _ref3$errors;
                if (warningOnly) {
                  nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                } else {
                  nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                }
              });
              _this.errors = nextErrors;
              _this.warnings = nextWarnings;
              _this.triggerMetaEvent();
              _this.reRender();
            }
          });
          return promise;
        });
        if (validateOnly) {
          return rootPromise;
        }
        _this.validatePromise = rootPromise;
        _this.dirty = true;
        _this.errors = EMPTY_ERRORS;
        _this.warnings = EMPTY_ERRORS;
        _this.triggerMetaEvent();
        _this.reRender();
        return rootPromise;
      };
      _this.isFieldValidating = function() {
        return !!_this.validatePromise;
      };
      _this.isFieldTouched = function() {
        return _this.touched;
      };
      _this.isFieldDirty = function() {
        if (_this.dirty || _this.props.initialValue !== void 0) {
          return true;
        }
        var fieldContext = _this.props.fieldContext;
        var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK), getInitialValue = _fieldContext$getInte.getInitialValue;
        if (getInitialValue(_this.getNamePath()) !== void 0) {
          return true;
        }
        return false;
      };
      _this.getErrors = function() {
        return _this.errors;
      };
      _this.getWarnings = function() {
        return _this.warnings;
      };
      _this.isListField = function() {
        return _this.props.isListField;
      };
      _this.isList = function() {
        return _this.props.isList;
      };
      _this.isPreserve = function() {
        return _this.props.preserve;
      };
      _this.getMeta = function() {
        _this.prevValidating = _this.isFieldValidating();
        var meta = {
          touched: _this.isFieldTouched(),
          validating: _this.prevValidating,
          errors: _this.errors,
          warnings: _this.warnings,
          name: _this.getNamePath(),
          validated: _this.validatePromise === null
        };
        return meta;
      };
      _this.getOnlyChild = function(children) {
        if (typeof children === "function") {
          var meta = _this.getMeta();
          return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), meta, _this.props.fieldContext))), {}, {
            isFunction: true
          });
        }
        var childList = toArray$3(children);
        if (childList.length !== 1 || !/* @__PURE__ */ React__namespace.isValidElement(childList[0])) {
          return {
            child: childList,
            isFunction: false
          };
        }
        return {
          child: childList[0],
          isFunction: false
        };
      };
      _this.getValue = function(store) {
        var getFieldsValue = _this.props.fieldContext.getFieldsValue;
        var namePath = _this.getNamePath();
        return get(store || getFieldsValue(true), namePath);
      };
      _this.getControlled = function() {
        var childProps = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        var _this$props6 = _this.props, trigger = _this$props6.trigger, validateTrigger = _this$props6.validateTrigger, getValueFromEvent = _this$props6.getValueFromEvent, normalize2 = _this$props6.normalize, valuePropName = _this$props6.valuePropName, getValueProps = _this$props6.getValueProps, fieldContext = _this$props6.fieldContext;
        var mergedValidateTrigger = validateTrigger !== void 0 ? validateTrigger : fieldContext.validateTrigger;
        var namePath = _this.getNamePath();
        var getInternalHooks3 = fieldContext.getInternalHooks, getFieldsValue = fieldContext.getFieldsValue;
        var _getInternalHooks = getInternalHooks3(HOOK_MARK), dispatch = _getInternalHooks.dispatch;
        var value = _this.getValue();
        var mergedGetValueProps = getValueProps || function(val) {
          return _defineProperty({}, valuePropName, val);
        };
        var originTriggerFunc = childProps[trigger];
        var control = _objectSpread2(_objectSpread2({}, childProps), mergedGetValueProps(value));
        control[trigger] = function() {
          _this.touched = true;
          _this.dirty = true;
          _this.triggerMetaEvent();
          var newValue;
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          if (getValueFromEvent) {
            newValue = getValueFromEvent.apply(void 0, args);
          } else {
            newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
          }
          if (normalize2) {
            newValue = normalize2(newValue, value, getFieldsValue(true));
          }
          dispatch({
            type: "updateValue",
            namePath,
            value: newValue
          });
          if (originTriggerFunc) {
            originTriggerFunc.apply(void 0, args);
          }
        };
        var validateTriggerList = toArray$2(mergedValidateTrigger || []);
        validateTriggerList.forEach(function(triggerName) {
          var originTrigger = control[triggerName];
          control[triggerName] = function() {
            if (originTrigger) {
              originTrigger.apply(void 0, arguments);
            }
            var rules2 = _this.props.rules;
            if (rules2 && rules2.length) {
              dispatch({
                type: "validateField",
                namePath,
                triggerName
              });
            }
          };
        });
        return control;
      };
      if (props.fieldContext) {
        var getInternalHooks2 = props.fieldContext.getInternalHooks;
        var _getInternalHooks2 = getInternalHooks2(HOOK_MARK), initEntityValue = _getInternalHooks2.initEntityValue;
        initEntityValue(_assertThisInitialized$1(_this));
      }
      return _this;
    }
    _createClass$1(Field2, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        var _this$props7 = this.props, shouldUpdate = _this$props7.shouldUpdate, fieldContext = _this$props7.fieldContext;
        this.mounted = true;
        if (fieldContext) {
          var getInternalHooks2 = fieldContext.getInternalHooks;
          var _getInternalHooks3 = getInternalHooks2(HOOK_MARK), registerField = _getInternalHooks3.registerField;
          this.cancelRegisterFunc = registerField(this);
        }
        if (shouldUpdate === true) {
          this.reRender();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.cancelRegister();
        this.triggerMetaEvent(true);
        this.mounted = false;
      }
    }, {
      key: "reRender",
      value: function reRender() {
        if (!this.mounted)
          return;
        this.forceUpdate();
      }
    }, {
      key: "render",
      value: function render2() {
        var resetCount = this.state.resetCount;
        var children = this.props.children;
        var _this$getOnlyChild = this.getOnlyChild(children), child = _this$getOnlyChild.child, isFunction2 = _this$getOnlyChild.isFunction;
        var returnChildNode;
        if (isFunction2) {
          returnChildNode = child;
        } else if (/* @__PURE__ */ React__namespace.isValidElement(child)) {
          returnChildNode = /* @__PURE__ */ React__namespace.cloneElement(child, this.getControlled(child.props));
        } else {
          warningOnce(!child, "`children` of Field is not validate ReactElement.");
          returnChildNode = child;
        }
        return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, {
          key: resetCount
        }, returnChildNode);
      }
    }]);
    return Field2;
  }(React__namespace.Component);
  Field.contextType = Context;
  Field.defaultProps = {
    trigger: "onChange",
    valuePropName: "value"
  };
  function WrapperField(_ref5) {
    var name = _ref5.name, restProps = _objectWithoutProperties(_ref5, _excluded$4);
    var fieldContext = React__namespace.useContext(Context);
    var listContext = React__namespace.useContext(ListContext);
    var namePath = name !== void 0 ? getNamePath(name) : void 0;
    var key = "keep";
    if (!restProps.isListField) {
      key = "_".concat((namePath || []).join("_"));
    }
    return /* @__PURE__ */ React__namespace.createElement(Field, _extends$2({
      key,
      name: namePath,
      isListField: !!listContext
    }, restProps, {
      fieldContext
    }));
  }
  var List = function List2(_ref) {
    var name = _ref.name, initialValue = _ref.initialValue, children = _ref.children, rules2 = _ref.rules, validateTrigger = _ref.validateTrigger, isListField = _ref.isListField;
    var context = React__namespace.useContext(Context);
    var wrapperListContext = React__namespace.useContext(ListContext);
    var keyRef = React__namespace.useRef({
      keys: [],
      id: 0
    });
    var keyManager = keyRef.current;
    var prefixName = React__namespace.useMemo(function() {
      var parentPrefixName = getNamePath(context.prefixName) || [];
      return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
    }, [context.prefixName, name]);
    var fieldContext = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, context), {}, {
        prefixName
      });
    }, [context, prefixName]);
    var listContext = React__namespace.useMemo(function() {
      return {
        getKey: function getKey(namePath) {
          var len = prefixName.length;
          var pathName = namePath[len];
          return [keyManager.keys[pathName], namePath.slice(len + 1)];
        }
      };
    }, [prefixName]);
    if (typeof children !== "function") {
      warningOnce(false, "Form.List only accepts function as children.");
      return null;
    }
    var shouldUpdate = function shouldUpdate2(prevValue, nextValue, _ref2) {
      var source = _ref2.source;
      if (source === "internal") {
        return false;
      }
      return prevValue !== nextValue;
    };
    return /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
      value: listContext
    }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: fieldContext
    }, /* @__PURE__ */ React__namespace.createElement(WrapperField, {
      name: [],
      shouldUpdate,
      rules: rules2,
      validateTrigger,
      initialValue,
      isList: true,
      isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
    }, function(_ref3, meta) {
      var _ref3$value = _ref3.value, value = _ref3$value === void 0 ? [] : _ref3$value, onChange = _ref3.onChange;
      var getFieldValue = context.getFieldValue;
      var getNewValue = function getNewValue2() {
        var values = getFieldValue(prefixName || []);
        return values || [];
      };
      var operations = {
        add: function add(defaultValue, index2) {
          var newValue = getNewValue();
          if (index2 >= 0 && index2 <= newValue.length) {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index2)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index2)));
            onChange([].concat(_toConsumableArray(newValue.slice(0, index2)), [defaultValue], _toConsumableArray(newValue.slice(index2))));
          } else {
            keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
            onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
          }
          keyManager.id += 1;
        },
        remove: function remove2(index2) {
          var newValue = getNewValue();
          var indexSet = new Set(Array.isArray(index2) ? index2 : [index2]);
          if (indexSet.size <= 0) {
            return;
          }
          keyManager.keys = keyManager.keys.filter(function(_2, keysIndex) {
            return !indexSet.has(keysIndex);
          });
          onChange(newValue.filter(function(_2, valueIndex) {
            return !indexSet.has(valueIndex);
          }));
        },
        move: function move$1(from2, to) {
          if (from2 === to) {
            return;
          }
          var newValue = getNewValue();
          if (from2 < 0 || from2 >= newValue.length || to < 0 || to >= newValue.length) {
            return;
          }
          keyManager.keys = move(keyManager.keys, from2, to);
          onChange(move(newValue, from2, to));
        }
      };
      var listValue = value || [];
      if (!Array.isArray(listValue)) {
        listValue = [];
      }
      return children(listValue.map(function(__, index2) {
        var key = keyManager.keys[index2];
        if (key === void 0) {
          keyManager.keys[index2] = keyManager.id;
          key = keyManager.keys[index2];
          keyManager.id += 1;
        }
        return {
          name: index2,
          key,
          isListField: true
        };
      }), operations, meta);
    })));
  };
  function allPromiseFinish(promiseList) {
    var hasError = false;
    var count = promiseList.length;
    var results = [];
    if (!promiseList.length) {
      return Promise.resolve([]);
    }
    return new Promise(function(resolve, reject) {
      promiseList.forEach(function(promise, index2) {
        promise.catch(function(e2) {
          hasError = true;
          return e2;
        }).then(function(result) {
          count -= 1;
          results[index2] = result;
          if (count > 0) {
            return;
          }
          if (hasError) {
            reject(results);
          }
          resolve(results);
        });
      });
    });
  }
  var SPLIT = "__@field_split__";
  function normalize(namePath) {
    return namePath.map(function(cell) {
      return "".concat(_typeof(cell), ":").concat(cell);
    }).join(SPLIT);
  }
  var NameMap = /* @__PURE__ */ function() {
    function NameMap2() {
      _classCallCheck(this, NameMap2);
      this.kvs = /* @__PURE__ */ new Map();
    }
    _createClass$1(NameMap2, [{
      key: "set",
      value: function set5(key, value) {
        this.kvs.set(normalize(key), value);
      }
    }, {
      key: "get",
      value: function get4(key) {
        return this.kvs.get(normalize(key));
      }
    }, {
      key: "update",
      value: function update(key, updater) {
        var origin = this.get(key);
        var next2 = updater(origin);
        if (!next2) {
          this.delete(key);
        } else {
          this.set(key, next2);
        }
      }
    }, {
      key: "delete",
      value: function _delete(key) {
        this.kvs.delete(normalize(key));
      }
      // Since we only use this in test, let simply realize this
    }, {
      key: "map",
      value: function map2(callback) {
        return _toConsumableArray(this.kvs.entries()).map(function(_ref) {
          var _ref2 = _slicedToArray(_ref, 2), key = _ref2[0], value = _ref2[1];
          var cells = key.split(SPLIT);
          return callback({
            key: cells.map(function(cell) {
              var _cell$match = cell.match(/^([^:]*):(.*)$/), _cell$match2 = _slicedToArray(_cell$match, 3), type4 = _cell$match2[1], unit = _cell$match2[2];
              return type4 === "number" ? Number(unit) : unit;
            }),
            value
          });
        });
      }
    }, {
      key: "toJSON",
      value: function toJSON3() {
        var json = {};
        this.map(function(_ref3) {
          var key = _ref3.key, value = _ref3.value;
          json[key.join(".")] = value;
          return null;
        });
        return json;
      }
    }]);
    return NameMap2;
  }();
  var _excluded$3 = ["name"];
  var FormStore = /* @__PURE__ */ _createClass$1(function FormStore2(forceRootUpdate) {
    var _this = this;
    _classCallCheck(this, FormStore2);
    this.formHooked = false;
    this.forceRootUpdate = void 0;
    this.subscribable = true;
    this.store = {};
    this.fieldEntities = [];
    this.initialValues = {};
    this.callbacks = {};
    this.validateMessages = null;
    this.preserve = null;
    this.lastValidatePromise = null;
    this.getForm = function() {
      return {
        getFieldValue: _this.getFieldValue,
        getFieldsValue: _this.getFieldsValue,
        getFieldError: _this.getFieldError,
        getFieldWarning: _this.getFieldWarning,
        getFieldsError: _this.getFieldsError,
        isFieldsTouched: _this.isFieldsTouched,
        isFieldTouched: _this.isFieldTouched,
        isFieldValidating: _this.isFieldValidating,
        isFieldsValidating: _this.isFieldsValidating,
        resetFields: _this.resetFields,
        setFields: _this.setFields,
        setFieldValue: _this.setFieldValue,
        setFieldsValue: _this.setFieldsValue,
        validateFields: _this.validateFields,
        submit: _this.submit,
        _init: true,
        getInternalHooks: _this.getInternalHooks
      };
    };
    this.getInternalHooks = function(key) {
      if (key === HOOK_MARK) {
        _this.formHooked = true;
        return {
          dispatch: _this.dispatch,
          initEntityValue: _this.initEntityValue,
          registerField: _this.registerField,
          useSubscribe: _this.useSubscribe,
          setInitialValues: _this.setInitialValues,
          destroyForm: _this.destroyForm,
          setCallbacks: _this.setCallbacks,
          setValidateMessages: _this.setValidateMessages,
          getFields: _this.getFields,
          setPreserve: _this.setPreserve,
          getInitialValue: _this.getInitialValue,
          registerWatch: _this.registerWatch
        };
      }
      warningOnce(false, "`getInternalHooks` is internal usage. Should not call directly.");
      return null;
    };
    this.useSubscribe = function(subscribable) {
      _this.subscribable = subscribable;
    };
    this.prevWithoutPreserves = null;
    this.setInitialValues = function(initialValues, init) {
      _this.initialValues = initialValues || {};
      if (init) {
        var _this$prevWithoutPres;
        var nextStore = merge$2(initialValues, _this.store);
        (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 ? void 0 : _this$prevWithoutPres.map(function(_ref) {
          var namePath = _ref.key;
          nextStore = set(nextStore, namePath, get(initialValues, namePath));
        });
        _this.prevWithoutPreserves = null;
        _this.updateStore(nextStore);
      }
    };
    this.destroyForm = function() {
      var prevWithoutPreserves = new NameMap();
      _this.getFieldEntities(true).forEach(function(entity) {
        if (!_this.isMergedPreserve(entity.isPreserve())) {
          prevWithoutPreserves.set(entity.getNamePath(), true);
        }
      });
      _this.prevWithoutPreserves = prevWithoutPreserves;
    };
    this.getInitialValue = function(namePath) {
      var initValue = get(_this.initialValues, namePath);
      return namePath.length ? merge$2(initValue) : initValue;
    };
    this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    this.setValidateMessages = function(validateMessages) {
      _this.validateMessages = validateMessages;
    };
    this.setPreserve = function(preserve) {
      _this.preserve = preserve;
    };
    this.watchList = [];
    this.registerWatch = function(callback) {
      _this.watchList.push(callback);
      return function() {
        _this.watchList = _this.watchList.filter(function(fn) {
          return fn !== callback;
        });
      };
    };
    this.notifyWatch = function() {
      var namePath = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      if (_this.watchList.length) {
        var values = _this.getFieldsValue();
        var allValues = _this.getFieldsValue(true);
        _this.watchList.forEach(function(callback) {
          callback(values, allValues, namePath);
        });
      }
    };
    this.timeoutId = null;
    this.warningUnhooked = function() {
    };
    this.updateStore = function(nextStore) {
      _this.store = nextStore;
    };
    this.getFieldEntities = function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      if (!pure) {
        return _this.fieldEntities;
      }
      return _this.fieldEntities.filter(function(field) {
        return field.getNamePath().length;
      });
    };
    this.getFieldsMap = function() {
      var pure = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var cache = new NameMap();
      _this.getFieldEntities(pure).forEach(function(field) {
        var namePath = field.getNamePath();
        cache.set(namePath, field);
      });
      return cache;
    };
    this.getFieldEntitiesForNamePathList = function(nameList) {
      if (!nameList) {
        return _this.getFieldEntities(true);
      }
      var cache = _this.getFieldsMap(true);
      return nameList.map(function(name) {
        var namePath = getNamePath(name);
        return cache.get(namePath) || {
          INVALIDATE_NAME_PATH: getNamePath(name)
        };
      });
    };
    this.getFieldsValue = function(nameList, filterFunc) {
      _this.warningUnhooked();
      if (nameList === true && !filterFunc) {
        return _this.store;
      }
      var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(nameList) ? nameList : null);
      var filteredNameList = [];
      fieldEntities.forEach(function(entity) {
        var _entity$isListField;
        var namePath = "INVALIDATE_NAME_PATH" in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();
        if (!nameList && ((_entity$isListField = entity.isListField) === null || _entity$isListField === void 0 ? void 0 : _entity$isListField.call(entity))) {
          return;
        }
        if (!filterFunc) {
          filteredNameList.push(namePath);
        } else {
          var meta = "getMeta" in entity ? entity.getMeta() : null;
          if (filterFunc(meta)) {
            filteredNameList.push(namePath);
          }
        }
      });
      return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
    };
    this.getFieldValue = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      return get(_this.store, namePath);
    };
    this.getFieldsError = function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
      return fieldEntities.map(function(entity, index2) {
        if (entity && !("INVALIDATE_NAME_PATH" in entity)) {
          return {
            name: entity.getNamePath(),
            errors: entity.getErrors(),
            warnings: entity.getWarnings()
          };
        }
        return {
          name: getNamePath(nameList[index2]),
          errors: [],
          warnings: []
        };
      });
    };
    this.getFieldError = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.errors;
    };
    this.getFieldWarning = function(name) {
      _this.warningUnhooked();
      var namePath = getNamePath(name);
      var fieldError = _this.getFieldsError([namePath])[0];
      return fieldError.warnings;
    };
    this.isFieldsTouched = function() {
      _this.warningUnhooked();
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var arg0 = args[0], arg1 = args[1];
      var namePathList;
      var isAllFieldsTouched = false;
      if (args.length === 0) {
        namePathList = null;
      } else if (args.length === 1) {
        if (Array.isArray(arg0)) {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = false;
        } else {
          namePathList = null;
          isAllFieldsTouched = arg0;
        }
      } else {
        namePathList = arg0.map(getNamePath);
        isAllFieldsTouched = arg1;
      }
      var fieldEntities = _this.getFieldEntities(true);
      var isFieldTouched = function isFieldTouched2(field) {
        return field.isFieldTouched();
      };
      if (!namePathList) {
        return isAllFieldsTouched ? fieldEntities.every(isFieldTouched) : fieldEntities.some(isFieldTouched);
      }
      var map2 = new NameMap();
      namePathList.forEach(function(shortNamePath) {
        map2.set(shortNamePath, []);
      });
      fieldEntities.forEach(function(field) {
        var fieldNamePath = field.getNamePath();
        namePathList.forEach(function(shortNamePath) {
          if (shortNamePath.every(function(nameUnit, i) {
            return fieldNamePath[i] === nameUnit;
          })) {
            map2.update(shortNamePath, function(list) {
              return [].concat(_toConsumableArray(list), [field]);
            });
          }
        });
      });
      var isNamePathListTouched = function isNamePathListTouched2(entities) {
        return entities.some(isFieldTouched);
      };
      var namePathListEntities = map2.map(function(_ref2) {
        var value = _ref2.value;
        return value;
      });
      return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
    };
    this.isFieldTouched = function(name) {
      _this.warningUnhooked();
      return _this.isFieldsTouched([name]);
    };
    this.isFieldsValidating = function(nameList) {
      _this.warningUnhooked();
      var fieldEntities = _this.getFieldEntities();
      if (!nameList) {
        return fieldEntities.some(function(testField) {
          return testField.isFieldValidating();
        });
      }
      var namePathList = nameList.map(getNamePath);
      return fieldEntities.some(function(testField) {
        var fieldNamePath = testField.getNamePath();
        return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
      });
    };
    this.isFieldValidating = function(name) {
      _this.warningUnhooked();
      return _this.isFieldsValidating([name]);
    };
    this.resetWithFieldInitialValue = function() {
      var info = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
      var cache = new NameMap();
      var fieldEntities = _this.getFieldEntities(true);
      fieldEntities.forEach(function(field) {
        var initialValue = field.props.initialValue;
        var namePath = field.getNamePath();
        if (initialValue !== void 0) {
          var records = cache.get(namePath) || /* @__PURE__ */ new Set();
          records.add({
            entity: field,
            value: initialValue
          });
          cache.set(namePath, records);
        }
      });
      var resetWithFields = function resetWithFields2(entities) {
        entities.forEach(function(field) {
          var initialValue = field.props.initialValue;
          if (initialValue !== void 0) {
            var namePath = field.getNamePath();
            var formInitialValue = _this.getInitialValue(namePath);
            if (formInitialValue !== void 0) {
              warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join("."), "'. Field can not overwrite it."));
            } else {
              var records = cache.get(namePath);
              if (records && records.size > 1) {
                warningOnce(false, "Multiple Field with path '".concat(namePath.join("."), "' set 'initialValue'. Can not decide which one to pick."));
              } else if (records) {
                var originValue = _this.getFieldValue(namePath);
                if (!info.skipExist || originValue === void 0) {
                  _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                }
              }
            }
          }
        });
      };
      var requiredFieldEntities;
      if (info.entities) {
        requiredFieldEntities = info.entities;
      } else if (info.namePathList) {
        requiredFieldEntities = [];
        info.namePathList.forEach(function(namePath) {
          var records = cache.get(namePath);
          if (records) {
            var _requiredFieldEntitie;
            (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function(r2) {
              return r2.entity;
            })));
          }
        });
      } else {
        requiredFieldEntities = fieldEntities;
      }
      resetWithFields(requiredFieldEntities);
    };
    this.resetFields = function(nameList) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (!nameList) {
        _this.updateStore(merge$2(_this.initialValues));
        _this.resetWithFieldInitialValue();
        _this.notifyObservers(prevStore, null, {
          type: "reset"
        });
        _this.notifyWatch();
        return;
      }
      var namePathList = nameList.map(getNamePath);
      namePathList.forEach(function(namePath) {
        var initialValue = _this.getInitialValue(namePath);
        _this.updateStore(set(_this.store, namePath, initialValue));
      });
      _this.resetWithFieldInitialValue({
        namePathList
      });
      _this.notifyObservers(prevStore, namePathList, {
        type: "reset"
      });
      _this.notifyWatch(namePathList);
    };
    this.setFields = function(fields) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      var namePathList = [];
      fields.forEach(function(fieldData) {
        var name = fieldData.name, data = _objectWithoutProperties(fieldData, _excluded$3);
        var namePath = getNamePath(name);
        namePathList.push(namePath);
        if ("value" in data) {
          _this.updateStore(set(_this.store, namePath, data.value));
        }
        _this.notifyObservers(prevStore, [namePath], {
          type: "setField",
          data: fieldData
        });
      });
      _this.notifyWatch(namePathList);
    };
    this.getFields = function() {
      var entities = _this.getFieldEntities(true);
      var fields = entities.map(function(field) {
        var namePath = field.getNamePath();
        var meta = field.getMeta();
        var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
          name: namePath,
          value: _this.getFieldValue(namePath)
        });
        Object.defineProperty(fieldData, "originRCField", {
          value: true
        });
        return fieldData;
      });
      return fields;
    };
    this.initEntityValue = function(entity) {
      var initialValue = entity.props.initialValue;
      if (initialValue !== void 0) {
        var namePath = entity.getNamePath();
        var prevValue = get(_this.store, namePath);
        if (prevValue === void 0) {
          _this.updateStore(set(_this.store, namePath, initialValue));
        }
      }
    };
    this.isMergedPreserve = function(fieldPreserve) {
      var mergedPreserve = fieldPreserve !== void 0 ? fieldPreserve : _this.preserve;
      return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
    };
    this.registerField = function(entity) {
      _this.fieldEntities.push(entity);
      var namePath = entity.getNamePath();
      _this.notifyWatch([namePath]);
      if (entity.props.initialValue !== void 0) {
        var prevStore = _this.store;
        _this.resetWithFieldInitialValue({
          entities: [entity],
          skipExist: true
        });
        _this.notifyObservers(prevStore, [entity.getNamePath()], {
          type: "valueUpdate",
          source: "internal"
        });
      }
      return function(isListField, preserve) {
        var subNamePath = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : [];
        _this.fieldEntities = _this.fieldEntities.filter(function(item) {
          return item !== entity;
        });
        if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
          var defaultValue = isListField ? void 0 : _this.getInitialValue(namePath);
          if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function(field) {
            return (
              // Only reset when no namePath exist
              !matchNamePath(field.getNamePath(), namePath)
            );
          })) {
            var _prevStore = _this.store;
            _this.updateStore(set(_prevStore, namePath, defaultValue, true));
            _this.notifyObservers(_prevStore, [namePath], {
              type: "remove"
            });
            _this.triggerDependenciesUpdate(_prevStore, namePath);
          }
        }
        _this.notifyWatch([namePath]);
      };
    };
    this.dispatch = function(action2) {
      switch (action2.type) {
        case "updateValue": {
          var namePath = action2.namePath, value = action2.value;
          _this.updateValue(namePath, value);
          break;
        }
        case "validateField": {
          var _namePath = action2.namePath, triggerName = action2.triggerName;
          _this.validateFields([_namePath], {
            triggerName
          });
          break;
        }
      }
    };
    this.notifyObservers = function(prevStore, namePathList, info) {
      if (_this.subscribable) {
        var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
          store: _this.getFieldsValue(true)
        });
        _this.getFieldEntities().forEach(function(_ref3) {
          var onStoreChange = _ref3.onStoreChange;
          onStoreChange(prevStore, namePathList, mergedInfo);
        });
      } else {
        _this.forceRootUpdate();
      }
    };
    this.triggerDependenciesUpdate = function(prevStore, namePath) {
      var childrenFields = _this.getDependencyChildrenFields(namePath);
      if (childrenFields.length) {
        _this.validateFields(childrenFields);
      }
      _this.notifyObservers(prevStore, childrenFields, {
        type: "dependenciesUpdate",
        relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
      });
      return childrenFields;
    };
    this.updateValue = function(name, value) {
      var namePath = getNamePath(name);
      var prevStore = _this.store;
      _this.updateStore(set(_this.store, namePath, value));
      _this.notifyObservers(prevStore, [namePath], {
        type: "valueUpdate",
        source: "internal"
      });
      _this.notifyWatch([namePath]);
      var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);
      var onValuesChange = _this.callbacks.onValuesChange;
      if (onValuesChange) {
        var changedValues = cloneByNamePathList(_this.store, [namePath]);
        onValuesChange(changedValues, _this.getFieldsValue());
      }
      _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
    };
    this.setFieldsValue = function(store) {
      _this.warningUnhooked();
      var prevStore = _this.store;
      if (store) {
        var nextStore = merge$2(_this.store, store);
        _this.updateStore(nextStore);
      }
      _this.notifyObservers(prevStore, null, {
        type: "valueUpdate",
        source: "external"
      });
      _this.notifyWatch();
    };
    this.setFieldValue = function(name, value) {
      _this.setFields([{
        name,
        value
      }]);
    };
    this.getDependencyChildrenFields = function(rootNamePath) {
      var children = /* @__PURE__ */ new Set();
      var childrenFields = [];
      var dependencies2fields = new NameMap();
      _this.getFieldEntities().forEach(function(field) {
        var dependencies = field.props.dependencies;
        (dependencies || []).forEach(function(dependency) {
          var dependencyNamePath = getNamePath(dependency);
          dependencies2fields.update(dependencyNamePath, function() {
            var fields = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : /* @__PURE__ */ new Set();
            fields.add(field);
            return fields;
          });
        });
      });
      var fillChildren = function fillChildren2(namePath) {
        var fields = dependencies2fields.get(namePath) || /* @__PURE__ */ new Set();
        fields.forEach(function(field) {
          if (!children.has(field)) {
            children.add(field);
            var fieldNamePath = field.getNamePath();
            if (field.isFieldDirty() && fieldNamePath.length) {
              childrenFields.push(fieldNamePath);
              fillChildren2(fieldNamePath);
            }
          }
        });
      };
      fillChildren(rootNamePath);
      return childrenFields;
    };
    this.triggerOnFieldsChange = function(namePathList, filedErrors) {
      var onFieldsChange = _this.callbacks.onFieldsChange;
      if (onFieldsChange) {
        var fields = _this.getFields();
        if (filedErrors) {
          var cache = new NameMap();
          filedErrors.forEach(function(_ref4) {
            var name = _ref4.name, errors = _ref4.errors;
            cache.set(name, errors);
          });
          fields.forEach(function(field) {
            field.errors = cache.get(field.name) || field.errors;
          });
        }
        var changedFields = fields.filter(function(_ref5) {
          var fieldName = _ref5.name;
          return containsNamePath(namePathList, fieldName);
        });
        onFieldsChange(changedFields, fields);
      }
    };
    this.validateFields = function(arg1, arg2) {
      _this.warningUnhooked();
      var nameList;
      var options;
      if (Array.isArray(arg1) || typeof arg1 === "string" || typeof arg2 === "string") {
        nameList = arg1;
        options = arg2;
      } else {
        options = arg1;
      }
      var provideNameList = !!nameList;
      var namePathList = provideNameList ? nameList.map(getNamePath) : [];
      var promiseList = [];
      _this.getFieldEntities(true).forEach(function(field) {
        var _options;
        if (!provideNameList) {
          namePathList.push(field.getNamePath());
        }
        if (((_options = options) === null || _options === void 0 ? void 0 : _options.recursive) && provideNameList) {
          var namePath = field.getNamePath();
          if (
            // nameList[i] === undefined 说明是以 nameList 开头的
            // ['name'] -> ['name','list']
            namePath.every(function(nameUnit, i) {
              return nameList[i] === nameUnit || nameList[i] === void 0;
            })
          ) {
            namePathList.push(namePath);
          }
        }
        if (!field.props.rules || !field.props.rules.length) {
          return;
        }
        var fieldNamePath = field.getNamePath();
        if (!provideNameList || containsNamePath(namePathList, fieldNamePath)) {
          var promise = field.validateRules(_objectSpread2({
            validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
          }, options));
          promiseList.push(promise.then(function() {
            return {
              name: fieldNamePath,
              errors: [],
              warnings: []
            };
          }).catch(function(ruleErrors) {
            var _ruleErrors$forEach;
            var mergedErrors = [];
            var mergedWarnings = [];
            (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 ? void 0 : _ruleErrors$forEach.call(ruleErrors, function(_ref6) {
              var warningOnly = _ref6.rule.warningOnly, errors = _ref6.errors;
              if (warningOnly) {
                mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
              } else {
                mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
              }
            });
            if (mergedErrors.length) {
              return Promise.reject({
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              });
            }
            return {
              name: fieldNamePath,
              errors: mergedErrors,
              warnings: mergedWarnings
            };
          }));
        }
      });
      var summaryPromise = allPromiseFinish(promiseList);
      _this.lastValidatePromise = summaryPromise;
      summaryPromise.catch(function(results) {
        return results;
      }).then(function(results) {
        var resultNamePathList = results.map(function(_ref7) {
          var name = _ref7.name;
          return name;
        });
        _this.notifyObservers(_this.store, resultNamePathList, {
          type: "validateFinish"
        });
        _this.triggerOnFieldsChange(resultNamePathList, results);
      });
      var returnPromise = summaryPromise.then(function() {
        if (_this.lastValidatePromise === summaryPromise) {
          return Promise.resolve(_this.getFieldsValue(namePathList));
        }
        return Promise.reject([]);
      }).catch(function(results) {
        var errorList = results.filter(function(result) {
          return result && result.errors.length;
        });
        return Promise.reject({
          values: _this.getFieldsValue(namePathList),
          errorFields: errorList,
          outOfDate: _this.lastValidatePromise !== summaryPromise
        });
      });
      returnPromise.catch(function(e2) {
        return e2;
      });
      _this.triggerOnFieldsChange(namePathList);
      return returnPromise;
    };
    this.submit = function() {
      _this.warningUnhooked();
      _this.validateFields().then(function(values) {
        var onFinish = _this.callbacks.onFinish;
        if (onFinish) {
          try {
            onFinish(values);
          } catch (err) {
            console.error(err);
          }
        }
      }).catch(function(e2) {
        var onFinishFailed = _this.callbacks.onFinishFailed;
        if (onFinishFailed) {
          onFinishFailed(e2);
        }
      });
    };
    this.forceRootUpdate = forceRootUpdate;
  });
  function useForm(form) {
    var formRef = React__namespace.useRef();
    var _React$useState = React__namespace.useState({}), _React$useState2 = _slicedToArray(_React$useState, 2), forceUpdate = _React$useState2[1];
    if (!formRef.current) {
      if (form) {
        formRef.current = form;
      } else {
        var forceReRender = function forceReRender2() {
          forceUpdate({});
        };
        var formStore = new FormStore(forceReRender);
        formRef.current = formStore.getForm();
      }
    }
    return [formRef.current];
  }
  var FormContext = /* @__PURE__ */ React__namespace.createContext({
    triggerFormChange: function triggerFormChange() {
    },
    triggerFormFinish: function triggerFormFinish() {
    },
    registerForm: function registerForm() {
    },
    unregisterForm: function unregisterForm() {
    }
  });
  var FormProvider = function FormProvider2(_ref) {
    var validateMessages = _ref.validateMessages, onFormChange = _ref.onFormChange, onFormFinish = _ref.onFormFinish, children = _ref.children;
    var formContext = React__namespace.useContext(FormContext);
    var formsRef = React__namespace.useRef({});
    return /* @__PURE__ */ React__namespace.createElement(FormContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, formContext), {}, {
        validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
        // =========================================================
        // =                  Global Form Control                  =
        // =========================================================
        triggerFormChange: function triggerFormChange2(name, changedFields) {
          if (onFormChange) {
            onFormChange(name, {
              changedFields,
              forms: formsRef.current
            });
          }
          formContext.triggerFormChange(name, changedFields);
        },
        triggerFormFinish: function triggerFormFinish2(name, values) {
          if (onFormFinish) {
            onFormFinish(name, {
              values,
              forms: formsRef.current
            });
          }
          formContext.triggerFormFinish(name, values);
        },
        registerForm: function registerForm2(name, form) {
          if (name) {
            formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
          }
          formContext.registerForm(name, form);
        },
        unregisterForm: function unregisterForm2(name) {
          var newForms = _objectSpread2({}, formsRef.current);
          delete newForms[name];
          formsRef.current = newForms;
          formContext.unregisterForm(name);
        }
      })
    }, children);
  };
  var _excluded$2 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed"];
  var Form = function Form2(_ref, ref) {
    var name = _ref.name, initialValues = _ref.initialValues, fields = _ref.fields, form = _ref.form, preserve = _ref.preserve, children = _ref.children, _ref$component = _ref.component, Component2 = _ref$component === void 0 ? "form" : _ref$component, validateMessages = _ref.validateMessages, _ref$validateTrigger = _ref.validateTrigger, validateTrigger = _ref$validateTrigger === void 0 ? "onChange" : _ref$validateTrigger, onValuesChange = _ref.onValuesChange, _onFieldsChange = _ref.onFieldsChange, _onFinish = _ref.onFinish, onFinishFailed = _ref.onFinishFailed, restProps = _objectWithoutProperties(_ref, _excluded$2);
    var formContext = React__namespace.useContext(FormContext);
    var _useForm = useForm(form), _useForm2 = _slicedToArray(_useForm, 1), formInstance = _useForm2[0];
    var _formInstance$getInte = formInstance.getInternalHooks(HOOK_MARK), useSubscribe = _formInstance$getInte.useSubscribe, setInitialValues = _formInstance$getInte.setInitialValues, setCallbacks = _formInstance$getInte.setCallbacks, setValidateMessages = _formInstance$getInte.setValidateMessages, setPreserve = _formInstance$getInte.setPreserve, destroyForm = _formInstance$getInte.destroyForm;
    React__namespace.useImperativeHandle(ref, function() {
      return formInstance;
    });
    React__namespace.useEffect(function() {
      formContext.registerForm(name, formInstance);
      return function() {
        formContext.unregisterForm(name);
      };
    }, [formContext, formInstance, name]);
    setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
    setCallbacks({
      onValuesChange,
      onFieldsChange: function onFieldsChange(changedFields) {
        formContext.triggerFormChange(name, changedFields);
        if (_onFieldsChange) {
          for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            rest[_key - 1] = arguments[_key];
          }
          _onFieldsChange.apply(void 0, [changedFields].concat(rest));
        }
      },
      onFinish: function onFinish(values2) {
        formContext.triggerFormFinish(name, values2);
        if (_onFinish) {
          _onFinish(values2);
        }
      },
      onFinishFailed
    });
    setPreserve(preserve);
    var mountRef = React__namespace.useRef(null);
    setInitialValues(initialValues, !mountRef.current);
    if (!mountRef.current) {
      mountRef.current = true;
    }
    React__namespace.useEffect(
      function() {
        return destroyForm;
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []
    );
    var childrenNode;
    var childrenRenderProps = typeof children === "function";
    if (childrenRenderProps) {
      var values = formInstance.getFieldsValue(true);
      childrenNode = children(values, formInstance);
    } else {
      childrenNode = children;
    }
    useSubscribe(!childrenRenderProps);
    var prevFieldsRef = React__namespace.useRef();
    React__namespace.useEffect(function() {
      if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
        formInstance.setFields(fields || []);
      }
      prevFieldsRef.current = fields;
    }, [fields, formInstance]);
    var formContextValue = React__namespace.useMemo(function() {
      return _objectSpread2(_objectSpread2({}, formInstance), {}, {
        validateTrigger
      });
    }, [formInstance, validateTrigger]);
    var wrapperNode = /* @__PURE__ */ React__namespace.createElement(ListContext.Provider, {
      value: null
    }, /* @__PURE__ */ React__namespace.createElement(Context.Provider, {
      value: formContextValue
    }, childrenNode));
    if (Component2 === false) {
      return wrapperNode;
    }
    return /* @__PURE__ */ React__namespace.createElement(Component2, _extends$2({}, restProps, {
      onSubmit: function onSubmit(event) {
        event.preventDefault();
        event.stopPropagation();
        formInstance.submit();
      },
      onReset: function onReset(event) {
        var _restProps$onReset;
        event.preventDefault();
        formInstance.resetFields();
        (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 ? void 0 : _restProps$onReset.call(restProps, event);
      }
    }), wrapperNode);
  };
  function stringify(value) {
    try {
      return JSON.stringify(value);
    } catch (err) {
      return Math.random();
    }
  }
  function useWatch$1() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var _args$ = args[0], dependencies = _args$ === void 0 ? [] : _args$, _args$2 = args[1], _form = _args$2 === void 0 ? {} : _args$2;
    var options = isFormInstance(_form) ? {
      form: _form
    } : _form;
    var form = options.form;
    var _useState = React.useState(), _useState2 = _slicedToArray(_useState, 2), value = _useState2[0], setValue = _useState2[1];
    var valueStr = React.useMemo(function() {
      return stringify(value);
    }, [value]);
    var valueStrRef = React.useRef(valueStr);
    valueStrRef.current = valueStr;
    var fieldContext = React.useContext(Context);
    var formInstance = form || fieldContext;
    var isValidForm = formInstance && formInstance._init;
    var namePath = getNamePath(dependencies);
    var namePathRef = React.useRef(namePath);
    namePathRef.current = namePath;
    React.useEffect(
      function() {
        if (!isValidForm) {
          return;
        }
        var getFieldsValue = formInstance.getFieldsValue, getInternalHooks2 = formInstance.getInternalHooks;
        var _getInternalHooks = getInternalHooks2(HOOK_MARK), registerWatch = _getInternalHooks.registerWatch;
        var cancelRegister = registerWatch(function(values, allValues) {
          var newValue = get(options.preserve ? allValues : values, namePathRef.current);
          var nextValueStr = stringify(newValue);
          if (valueStrRef.current !== nextValueStr) {
            valueStrRef.current = nextValueStr;
            setValue(newValue);
          }
        });
        var initialValue = get(options.preserve ? getFieldsValue(true) : getFieldsValue(), namePathRef.current);
        setValue(initialValue);
        return cancelRegister;
      },
      // We do not need re-register since namePath content is the same
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [isValidForm]
    );
    return value;
  }
  var InternalForm = /* @__PURE__ */ React__namespace.forwardRef(Form);
  var RefForm = InternalForm;
  RefForm.FormProvider = FormProvider;
  RefForm.Field = WrapperField;
  RefForm.List = List;
  RefForm.useForm = useForm;
  RefForm.useWatch = useWatch$1;
  const FormItemInputContext = /* @__PURE__ */ React__namespace.createContext({});
  const NoFormStyle = (_ref) => {
    let {
      children,
      status,
      override
    } = _ref;
    const formItemInputContext = React.useContext(FormItemInputContext);
    const newFormItemInputContext = React.useMemo(() => {
      const newContext = Object.assign({}, formItemInputContext);
      if (override) {
        delete newContext.isFormItemInput;
      }
      if (status) {
        delete newContext.status;
        delete newContext.hasFeedback;
        delete newContext.feedbackIcon;
      }
      return newContext;
    }, [status, override, formItemInputContext]);
    return /* @__PURE__ */ React__namespace.createElement(FormItemInputContext.Provider, {
      value: newFormItemInputContext
    }, children);
  };
  function renderCloseIcon(prefixCls, closeIcon) {
    return /* @__PURE__ */ React.createElement("span", {
      className: `${prefixCls}-close-x`
    }, closeIcon || /* @__PURE__ */ React.createElement(CloseOutlined$1, {
      className: `${prefixCls}-close-icon`
    }));
  }
  const Footer = (props) => {
    const {
      okText,
      okType = "primary",
      cancelText,
      confirmLoading,
      onOk,
      onCancel,
      okButtonProps,
      cancelButtonProps
    } = props;
    const [locale2] = useLocale$1("Modal", getConfirmLocale());
    return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(Button$1, Object.assign({
      onClick: onCancel
    }, cancelButtonProps), cancelText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.cancelText)), /* @__PURE__ */ React.createElement(Button$1, Object.assign({}, convertLegacyProps(okType), {
      loading: confirmLoading,
      onClick: onOk
    }, okButtonProps), okText || (locale2 === null || locale2 === void 0 ? void 0 : locale2.okText)));
  };
  const initMotionCommon = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotionCommonLeave = (duration) => ({
    animationDuration: duration,
    animationFillMode: "both"
  });
  const initMotion = function(motionCls, inKeyframes, outKeyframes, duration) {
    let sameLevel = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : false;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return {
      [`
      ${sameLevelPrefix}${motionCls}-enter,
      ${sameLevelPrefix}${motionCls}-appear
    `]: Object.assign(Object.assign({}, initMotionCommon(duration)), {
        animationPlayState: "paused"
      }),
      [`${sameLevelPrefix}${motionCls}-leave`]: Object.assign(Object.assign({}, initMotionCommonLeave(duration)), {
        animationPlayState: "paused"
      }),
      [`
      ${sameLevelPrefix}${motionCls}-enter${motionCls}-enter-active,
      ${sameLevelPrefix}${motionCls}-appear${motionCls}-appear-active
    `]: {
        animationName: inKeyframes,
        animationPlayState: "running"
      },
      [`${sameLevelPrefix}${motionCls}-leave${motionCls}-leave-active`]: {
        animationName: outKeyframes,
        animationPlayState: "running",
        pointerEvents: "none"
      }
    };
  };
  const fadeIn = new Keyframe("antFadeIn", {
    "0%": {
      opacity: 0
    },
    "100%": {
      opacity: 1
    }
  });
  const fadeOut = new Keyframe("antFadeOut", {
    "0%": {
      opacity: 1
    },
    "100%": {
      opacity: 0
    }
  });
  const initFadeMotion = function(token2) {
    let sameLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-fade`;
    const sameLevelPrefix = sameLevel ? "&" : "";
    return [initMotion(motionCls, fadeIn, fadeOut, token2.motionDurationMid, sameLevel), {
      [`
        ${sameLevelPrefix}${motionCls}-enter,
        ${sameLevelPrefix}${motionCls}-appear
      `]: {
        opacity: 0,
        animationTimingFunction: "linear"
      },
      [`${sameLevelPrefix}${motionCls}-leave`]: {
        animationTimingFunction: "linear"
      }
    }];
  };
  const zoomIn = new Keyframe("antZoomIn", {
    "0%": {
      transform: "scale(0.2)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomOut = new Keyframe("antZoomOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.2)",
      opacity: 0
    }
  });
  const zoomBigIn = new Keyframe("antZoomBigIn", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      opacity: 1
    }
  });
  const zoomBigOut = new Keyframe("antZoomBigOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0.8)",
      opacity: 0
    }
  });
  const zoomUpIn = new Keyframe("antZoomUpIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    }
  });
  const zoomUpOut = new Keyframe("antZoomUpOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 0%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 0%",
      opacity: 0
    }
  });
  const zoomLeftIn = new Keyframe("antZoomLeftIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    }
  });
  const zoomLeftOut = new Keyframe("antZoomLeftOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "0% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "0% 50%",
      opacity: 0
    }
  });
  const zoomRightIn = new Keyframe("antZoomRightIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    }
  });
  const zoomRightOut = new Keyframe("antZoomRightOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "100% 50%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "100% 50%",
      opacity: 0
    }
  });
  const zoomDownIn = new Keyframe("antZoomDownIn", {
    "0%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    }
  });
  const zoomDownOut = new Keyframe("antZoomDownOut", {
    "0%": {
      transform: "scale(1)",
      transformOrigin: "50% 100%"
    },
    "100%": {
      transform: "scale(0.8)",
      transformOrigin: "50% 100%",
      opacity: 0
    }
  });
  const zoomMotion = {
    zoom: {
      inKeyframes: zoomIn,
      outKeyframes: zoomOut
    },
    "zoom-big": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-big-fast": {
      inKeyframes: zoomBigIn,
      outKeyframes: zoomBigOut
    },
    "zoom-left": {
      inKeyframes: zoomLeftIn,
      outKeyframes: zoomLeftOut
    },
    "zoom-right": {
      inKeyframes: zoomRightIn,
      outKeyframes: zoomRightOut
    },
    "zoom-up": {
      inKeyframes: zoomUpIn,
      outKeyframes: zoomUpOut
    },
    "zoom-down": {
      inKeyframes: zoomDownIn,
      outKeyframes: zoomDownOut
    }
  };
  const initZoomMotion = (token2, motionName) => {
    const {
      antCls
    } = token2;
    const motionCls = `${antCls}-${motionName}`;
    const {
      inKeyframes,
      outKeyframes
    } = zoomMotion[motionName];
    return [initMotion(motionCls, inKeyframes, outKeyframes, motionName === "zoom-big-fast" ? token2.motionDurationFast : token2.motionDurationMid), {
      [`
        ${motionCls}-enter,
        ${motionCls}-appear
      `]: {
        transform: "scale(0)",
        opacity: 0,
        animationTimingFunction: token2.motionEaseOutCirc,
        "&-prepare": {
          transform: "none"
        }
      },
      [`${motionCls}-leave`]: {
        animationTimingFunction: token2.motionEaseInOutCirc
      }
    }];
  };
  function box(position2) {
    return {
      position: position2,
      top: 0,
      insetInlineEnd: 0,
      bottom: 0,
      insetInlineStart: 0
    };
  }
  const genModalMaskStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    return [{
      [`${componentCls}-root`]: {
        [`${componentCls}${antCls}-zoom-enter, ${componentCls}${antCls}-zoom-appear`]: {
          // reset scale avoid mousePosition bug
          transform: "none",
          opacity: 0,
          animationDuration: token2.motionDurationSlow,
          // https://github.com/ant-design/ant-design/issues/11777
          userSelect: "none"
        },
        // https://github.com/ant-design/ant-design/issues/37329
        // https://github.com/ant-design/ant-design/issues/40272
        [`${componentCls}${antCls}-zoom-leave ${componentCls}-content`]: {
          pointerEvents: "none"
        },
        [`${componentCls}-mask`]: Object.assign(Object.assign({}, box("fixed")), {
          zIndex: token2.zIndexPopupBase,
          height: "100%",
          backgroundColor: token2.colorBgMask,
          [`${componentCls}-hidden`]: {
            display: "none"
          }
        }),
        [`${componentCls}-wrap`]: Object.assign(Object.assign({}, box("fixed")), {
          overflow: "auto",
          outline: 0,
          WebkitOverflowScrolling: "touch"
        })
      }
    }, {
      [`${componentCls}-root`]: initFadeMotion(token2)
    }];
  };
  const genModalStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return [
      // ======================== Root =========================
      {
        [`${componentCls}-root`]: {
          [`${componentCls}-wrap`]: {
            zIndex: token2.zIndexPopupBase,
            position: "fixed",
            inset: 0,
            overflow: "auto",
            outline: 0,
            WebkitOverflowScrolling: "touch"
          },
          [`${componentCls}-wrap-rtl`]: {
            direction: "rtl"
          },
          [`${componentCls}-centered`]: {
            textAlign: "center",
            "&::before": {
              display: "inline-block",
              width: 0,
              height: "100%",
              verticalAlign: "middle",
              content: '""'
            },
            [componentCls]: {
              top: 0,
              display: "inline-block",
              paddingBottom: 0,
              textAlign: "start",
              verticalAlign: "middle"
            }
          },
          [`@media (max-width: ${token2.screenSMMax})`]: {
            [componentCls]: {
              maxWidth: "calc(100vw - 16px)",
              margin: `${token2.marginXS} auto`
            },
            [`${componentCls}-centered`]: {
              [componentCls]: {
                flex: 1
              }
            }
          }
        }
      },
      // ======================== Modal ========================
      {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
          pointerEvents: "none",
          position: "relative",
          top: 100,
          width: "auto",
          maxWidth: `calc(100vw - ${token2.margin * 2}px)`,
          margin: "0 auto",
          paddingBottom: token2.paddingLG,
          [`${componentCls}-title`]: {
            margin: 0,
            color: token2.titleColor,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.titleFontSize,
            lineHeight: token2.titleLineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-content`]: {
            position: "relative",
            backgroundColor: token2.contentBg,
            backgroundClip: "padding-box",
            border: 0,
            borderRadius: token2.borderRadiusLG,
            boxShadow: token2.boxShadow,
            pointerEvents: "auto",
            padding: `${token2.paddingMD}px ${token2.paddingContentHorizontalLG}px`
          },
          [`${componentCls}-close`]: Object.assign({
            position: "absolute",
            top: (token2.modalHeaderHeight - token2.modalCloseBtnSize) / 2,
            insetInlineEnd: (token2.modalHeaderHeight - token2.modalCloseBtnSize) / 2,
            zIndex: token2.zIndexPopupBase + 10,
            padding: 0,
            color: token2.modalCloseIconColor,
            fontWeight: token2.fontWeightStrong,
            lineHeight: 1,
            textDecoration: "none",
            background: "transparent",
            borderRadius: token2.borderRadiusSM,
            width: token2.modalCloseBtnSize,
            height: token2.modalCloseBtnSize,
            border: 0,
            outline: 0,
            cursor: "pointer",
            transition: `color ${token2.motionDurationMid}, background-color ${token2.motionDurationMid}`,
            "&-x": {
              display: "flex",
              fontSize: token2.fontSizeLG,
              fontStyle: "normal",
              lineHeight: `${token2.modalCloseBtnSize}px`,
              justifyContent: "center",
              textTransform: "none",
              textRendering: "auto"
            },
            "&:hover": {
              color: token2.modalIconHoverColor,
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContent,
              textDecoration: "none"
            },
            "&:active": {
              backgroundColor: token2.wireframe ? "transparent" : token2.colorFillContentHover
            }
          }, genFocusStyle(token2)),
          [`${componentCls}-header`]: {
            color: token2.colorText,
            background: token2.headerBg,
            borderRadius: `${token2.borderRadiusLG}px ${token2.borderRadiusLG}px 0 0`,
            marginBottom: token2.marginXS
          },
          [`${componentCls}-body`]: {
            fontSize: token2.fontSize,
            lineHeight: token2.lineHeight,
            wordWrap: "break-word"
          },
          [`${componentCls}-footer`]: {
            textAlign: "end",
            background: token2.footerBg,
            marginTop: token2.marginSM,
            [`${token2.antCls}-btn + ${token2.antCls}-btn:not(${token2.antCls}-dropdown-trigger)`]: {
              marginBottom: 0,
              marginInlineStart: token2.marginXS
            }
          },
          [`${componentCls}-open`]: {
            overflow: "hidden"
          }
        })
      },
      // ======================== Pure =========================
      {
        [`${componentCls}-pure-panel`]: {
          top: "auto",
          padding: 0,
          display: "flex",
          flexDirection: "column",
          [`${componentCls}-content,
          ${componentCls}-body,
          ${componentCls}-confirm-body-wrapper`]: {
            display: "flex",
            flexDirection: "column",
            flex: "auto"
          },
          [`${componentCls}-confirm-body`]: {
            marginBottom: "auto"
          }
        }
      }
    ];
  };
  const genModalConfirmStyle = (token2) => {
    const {
      componentCls
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [confirmComponentCls]: {
        "&-rtl": {
          direction: "rtl"
        },
        [`${token2.antCls}-modal-header`]: {
          display: "none"
        },
        [`${confirmComponentCls}-body-wrapper`]: Object.assign({}, clearFix()),
        [`${confirmComponentCls}-body`]: {
          display: "flex",
          flexWrap: "wrap",
          alignItems: "center",
          [`${confirmComponentCls}-title`]: {
            flex: "0 0 100%",
            display: "block",
            // create BFC to avoid
            // https://user-images.githubusercontent.com/507615/37702510-ba844e06-2d2d-11e8-9b67-8e19be57f445.png
            overflow: "hidden",
            color: token2.colorTextHeading,
            fontWeight: token2.fontWeightStrong,
            fontSize: token2.titleFontSize,
            lineHeight: token2.titleLineHeight,
            [`+ ${confirmComponentCls}-content`]: {
              marginBlockStart: token2.marginXS,
              flexBasis: "100%",
              maxWidth: `calc(100% - ${token2.modalConfirmIconSize + token2.marginSM}px)`
            }
          },
          [`${confirmComponentCls}-content`]: {
            color: token2.colorText,
            fontSize: token2.fontSize
          },
          [`> ${token2.iconCls}`]: {
            flex: "none",
            marginInlineEnd: token2.marginSM,
            fontSize: token2.modalConfirmIconSize,
            [`+ ${confirmComponentCls}-title`]: {
              flex: 1
            },
            // `content` after `icon` should set marginLeft
            [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
              marginInlineStart: token2.modalConfirmIconSize + token2.marginSM
            }
          }
        },
        [`${confirmComponentCls}-btns`]: {
          textAlign: "end",
          marginTop: token2.marginSM,
          [`${token2.antCls}-btn + ${token2.antCls}-btn`]: {
            marginBottom: 0,
            marginInlineStart: token2.marginXS
          }
        }
      },
      [`${confirmComponentCls}-error ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorError
      },
      [`${confirmComponentCls}-warning ${confirmComponentCls}-body > ${token2.iconCls},
        ${confirmComponentCls}-confirm ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorWarning
      },
      [`${confirmComponentCls}-info ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorInfo
      },
      [`${confirmComponentCls}-success ${confirmComponentCls}-body > ${token2.iconCls}`]: {
        color: token2.colorSuccess
      }
    };
  };
  const genRTLStyle = (token2) => {
    const {
      componentCls
    } = token2;
    return {
      [`${componentCls}-root`]: {
        [`${componentCls}-wrap-rtl`]: {
          direction: "rtl",
          [`${componentCls}-confirm-body`]: {
            direction: "rtl"
          }
        }
      }
    };
  };
  const genWireframeStyle = (token2) => {
    const {
      componentCls,
      antCls
    } = token2;
    const confirmComponentCls = `${componentCls}-confirm`;
    return {
      [componentCls]: {
        [`${componentCls}-content`]: {
          padding: 0
        },
        [`${componentCls}-header`]: {
          padding: token2.modalHeaderPadding,
          borderBottom: `${token2.modalHeaderBorderWidth}px ${token2.modalHeaderBorderStyle} ${token2.modalHeaderBorderColorSplit}`,
          marginBottom: 0
        },
        [`${componentCls}-body`]: {
          padding: token2.modalBodyPadding
        },
        [`${componentCls}-footer`]: {
          padding: `${token2.modalFooterPaddingVertical}px ${token2.modalFooterPaddingHorizontal}px`,
          borderTop: `${token2.modalFooterBorderWidth}px ${token2.modalFooterBorderStyle} ${token2.modalFooterBorderColorSplit}`,
          borderRadius: `0 0 ${token2.borderRadiusLG}px ${token2.borderRadiusLG}px`,
          marginTop: 0
        }
      },
      [confirmComponentCls]: {
        [`${antCls}-modal-body`]: {
          padding: `${token2.padding * 2}px ${token2.padding * 2}px ${token2.paddingLG}px`
        },
        [`${confirmComponentCls}-body`]: {
          [`> ${token2.iconCls}`]: {
            marginInlineEnd: token2.margin,
            // `content` after `icon` should set marginLeft
            [`+ ${confirmComponentCls}-title + ${confirmComponentCls}-content`]: {
              marginInlineStart: token2.modalConfirmIconSize + token2.margin
            }
          }
        },
        [`${confirmComponentCls}-btns`]: {
          marginTop: token2.marginLG
        }
      }
    };
  };
  const useStyle$5 = genComponentStyleHook("Modal", (token2) => {
    const headerPaddingVertical = token2.padding;
    const headerFontSize = token2.fontSizeHeading5;
    const headerLineHeight = token2.lineHeightHeading5;
    const modalToken = merge$1(token2, {
      modalBodyPadding: token2.paddingLG,
      modalHeaderPadding: `${headerPaddingVertical}px ${token2.paddingLG}px`,
      modalHeaderBorderWidth: token2.lineWidth,
      modalHeaderBorderStyle: token2.lineType,
      modalHeaderBorderColorSplit: token2.colorSplit,
      modalHeaderHeight: headerLineHeight * headerFontSize + headerPaddingVertical * 2,
      modalFooterBorderColorSplit: token2.colorSplit,
      modalFooterBorderStyle: token2.lineType,
      modalFooterPaddingVertical: token2.paddingXS,
      modalFooterPaddingHorizontal: token2.padding,
      modalFooterBorderWidth: token2.lineWidth,
      modalIconHoverColor: token2.colorIconHover,
      modalCloseIconColor: token2.colorIcon,
      modalCloseBtnSize: token2.fontSize * token2.lineHeight,
      modalConfirmIconSize: token2.fontSize * token2.lineHeight
    });
    return [genModalStyle(modalToken), genModalConfirmStyle(modalToken), genRTLStyle(modalToken), genModalMaskStyle(modalToken), token2.wireframe && genWireframeStyle(modalToken), initZoomMotion(modalToken, "zoom")];
  }, (token2) => ({
    footerBg: "transparent",
    headerBg: token2.colorBgElevated,
    titleLineHeight: token2.lineHeightHeading5,
    titleFontSize: token2.fontSizeHeading5,
    contentBg: token2.colorBgElevated,
    titleColor: token2.colorTextHeading
  }));
  var __rest$9 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  let mousePosition;
  const getClickPosition = (e2) => {
    mousePosition = {
      x: e2.pageX,
      y: e2.pageY
    };
    setTimeout(() => {
      mousePosition = null;
    }, 100);
  };
  if (canUseDocElement()) {
    document.documentElement.addEventListener("click", getClickPosition, true);
  }
  const Modal$2 = (props) => {
    var _a2;
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const handleCancel = (e2) => {
      const {
        onCancel
      } = props;
      onCancel === null || onCancel === void 0 ? void 0 : onCancel(e2);
    };
    const handleOk = (e2) => {
      const {
        onOk
      } = props;
      onOk === null || onOk === void 0 ? void 0 : onOk(e2);
    };
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      open,
      wrapClassName,
      centered,
      getContainer: getContainer2,
      closeIcon,
      focusTriggerAfterClose = true,
      // Deprecated
      visible,
      width = 520,
      footer
    } = props, restProps = __rest$9(props, ["prefixCls", "className", "rootClassName", "open", "wrapClassName", "centered", "getContainer", "closeIcon", "focusTriggerAfterClose", "visible", "width", "footer"]);
    const prefixCls = getPrefixCls("modal", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const [wrapSSR, hashId] = useStyle$5(prefixCls);
    const wrapClassNameExtended = classNames(wrapClassName, {
      [`${prefixCls}-centered`]: !!centered,
      [`${prefixCls}-wrap-rtl`]: direction === "rtl"
    });
    const dialogFooter = footer === void 0 ? /* @__PURE__ */ React__namespace.createElement(Footer, Object.assign({}, props, {
      onOk: handleOk,
      onCancel: handleCancel
    })) : footer;
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, /* @__PURE__ */ React__namespace.createElement(NoFormStyle, {
      status: true,
      override: true
    }, /* @__PURE__ */ React__namespace.createElement(DialogWrap, Object.assign({
      width
    }, restProps, {
      getContainer: getContainer2 === void 0 ? getContextPopupContainer : getContainer2,
      prefixCls,
      rootClassName: classNames(hashId, rootClassName),
      wrapClassName: wrapClassNameExtended,
      footer: dialogFooter,
      visible: open !== null && open !== void 0 ? open : visible,
      mousePosition: (_a2 = restProps.mousePosition) !== null && _a2 !== void 0 ? _a2 : mousePosition,
      onClose: handleCancel,
      closeIcon: renderCloseIcon(prefixCls, closeIcon),
      focusTriggerAfterClose,
      transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
      className: classNames(hashId, className)
    })))));
  };
  const OriginModal = Modal$2;
  function ConfirmContent(props) {
    const {
      icon,
      onCancel,
      onOk,
      close,
      okText,
      okButtonProps,
      cancelText,
      cancelButtonProps,
      confirmPrefixCls,
      rootPrefixCls,
      type: type4,
      okCancel,
      footer,
      // Legacy for static function usage
      locale: staticLocale
    } = props;
    let mergedIcon = icon;
    if (!icon && icon !== null) {
      switch (type4) {
        case "info":
          mergedIcon = /* @__PURE__ */ React__namespace.createElement(InfoCircleFilled$1, null);
          break;
        case "success":
          mergedIcon = /* @__PURE__ */ React__namespace.createElement(CheckCircleFilled$1, null);
          break;
        case "error":
          mergedIcon = /* @__PURE__ */ React__namespace.createElement(CloseCircleFilled$1, null);
          break;
        default:
          mergedIcon = /* @__PURE__ */ React__namespace.createElement(ExclamationCircleFilled$1, null);
      }
    }
    const okType = props.okType || "primary";
    const mergedOkCancel = okCancel !== null && okCancel !== void 0 ? okCancel : type4 === "confirm";
    const autoFocusButton = props.autoFocusButton === null ? false : props.autoFocusButton || "ok";
    const [locale2] = useLocale$1("Modal");
    const mergedLocale = staticLocale || locale2;
    const cancelButton = mergedOkCancel && /* @__PURE__ */ React__namespace.createElement(ActionButton$1, {
      actionFn: onCancel,
      close,
      autoFocus: autoFocusButton === "cancel",
      buttonProps: cancelButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, cancelText || (mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.cancelText));
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${confirmPrefixCls}-body-wrapper`
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${confirmPrefixCls}-body`
    }, mergedIcon, props.title === void 0 ? null : /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${confirmPrefixCls}-title`
    }, props.title), /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${confirmPrefixCls}-content`
    }, props.content)), footer === void 0 ? /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${confirmPrefixCls}-btns`
    }, cancelButton, /* @__PURE__ */ React__namespace.createElement(ActionButton$1, {
      type: okType,
      actionFn: onOk,
      close,
      autoFocus: autoFocusButton === "ok",
      buttonProps: okButtonProps,
      prefixCls: `${rootPrefixCls}-btn`
    }, okText || (mergedOkCancel ? mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.okText : mergedLocale === null || mergedLocale === void 0 ? void 0 : mergedLocale.justOkText))) : footer);
  }
  const ConfirmDialog = (props) => {
    const {
      close,
      zIndex,
      afterClose,
      visible,
      open,
      keyboard,
      centered,
      getContainer: getContainer2,
      maskStyle,
      direction,
      prefixCls,
      wrapClassName,
      rootPrefixCls,
      iconPrefixCls,
      theme: theme2,
      bodyStyle,
      closable = false,
      closeIcon,
      modalRender,
      focusTriggerAfterClose
    } = props;
    const confirmPrefixCls = `${prefixCls}-confirm`;
    const width = props.width || 416;
    const style2 = props.style || {};
    const mask = props.mask === void 0 ? true : props.mask;
    const maskClosable = props.maskClosable === void 0 ? false : props.maskClosable;
    const classString = classNames(confirmPrefixCls, `${confirmPrefixCls}-${props.type}`, {
      [`${confirmPrefixCls}-rtl`]: direction === "rtl"
    }, props.className);
    return /* @__PURE__ */ React__namespace.createElement(ConfigProvider, {
      prefixCls: rootPrefixCls,
      iconPrefixCls,
      direction,
      theme: theme2
    }, /* @__PURE__ */ React__namespace.createElement(OriginModal, {
      prefixCls,
      className: classString,
      wrapClassName: classNames({
        [`${confirmPrefixCls}-centered`]: !!props.centered
      }, wrapClassName),
      onCancel: () => close === null || close === void 0 ? void 0 : close({
        triggerCancel: true
      }),
      open,
      title: "",
      footer: null,
      transitionName: getTransitionName(rootPrefixCls, "zoom", props.transitionName),
      maskTransitionName: getTransitionName(rootPrefixCls, "fade", props.maskTransitionName),
      mask,
      maskClosable,
      maskStyle,
      style: style2,
      bodyStyle,
      width,
      zIndex,
      afterClose,
      keyboard,
      centered,
      getContainer: getContainer2,
      closable,
      closeIcon,
      modalRender,
      focusTriggerAfterClose
    }, /* @__PURE__ */ React__namespace.createElement(ConfirmContent, Object.assign({}, props, {
      confirmPrefixCls
    }))));
  };
  const ConfirmDialog$1 = ConfirmDialog;
  const destroyFns = [];
  const destroyFns$1 = destroyFns;
  var __rest$8 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  let defaultRootPrefixCls = "";
  function getRootPrefixCls() {
    return defaultRootPrefixCls;
  }
  function confirm(config) {
    const container = document.createDocumentFragment();
    let currentConfig = Object.assign(Object.assign({}, config), {
      close,
      open: true
    });
    let timeoutId;
    function destroy() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const triggerCancel = args.some((param) => param && param.triggerCancel);
      if (config.onCancel && triggerCancel) {
        config.onCancel.apply(config, [() => {
        }].concat(_toConsumableArray(args.slice(1))));
      }
      for (let i = 0; i < destroyFns$1.length; i++) {
        const fn = destroyFns$1[i];
        if (fn === close) {
          destroyFns$1.splice(i, 1);
          break;
        }
      }
      unmount(container);
    }
    function render$1(_a2) {
      var {
        okText,
        cancelText,
        prefixCls: customizePrefixCls,
        getContainer: getContainer2
      } = _a2, props = __rest$8(_a2, ["okText", "cancelText", "prefixCls", "getContainer"]);
      clearTimeout(timeoutId);
      timeoutId = setTimeout(() => {
        const runtimeLocale2 = getConfirmLocale();
        const {
          getPrefixCls,
          getIconPrefixCls,
          getTheme
        } = globalConfig();
        const rootPrefixCls = getPrefixCls(void 0, getRootPrefixCls());
        const prefixCls = customizePrefixCls || `${rootPrefixCls}-modal`;
        const iconPrefixCls = getIconPrefixCls();
        const theme2 = getTheme();
        let mergedGetContainer = getContainer2;
        if (mergedGetContainer === false) {
          mergedGetContainer = void 0;
        }
        render(/* @__PURE__ */ React__namespace.createElement(ConfirmDialog$1, Object.assign({}, props, {
          getContainer: mergedGetContainer,
          prefixCls,
          rootPrefixCls,
          iconPrefixCls,
          okText,
          locale: runtimeLocale2,
          theme: theme2,
          cancelText: cancelText || runtimeLocale2.cancelText
        })), container);
      });
    }
    function close() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      currentConfig = Object.assign(Object.assign({}, currentConfig), {
        open: false,
        afterClose: () => {
          if (typeof config.afterClose === "function") {
            config.afterClose();
          }
          destroy.apply(this, args);
        }
      });
      if (currentConfig.visible) {
        delete currentConfig.visible;
      }
      render$1(currentConfig);
    }
    function update(configUpdate) {
      if (typeof configUpdate === "function") {
        currentConfig = configUpdate(currentConfig);
      } else {
        currentConfig = Object.assign(Object.assign({}, currentConfig), configUpdate);
      }
      render$1(currentConfig);
    }
    render$1(currentConfig);
    destroyFns$1.push(close);
    return {
      destroy: close,
      update
    };
  }
  function withWarn(props) {
    return Object.assign(Object.assign({}, props), {
      type: "warning"
    });
  }
  function withInfo(props) {
    return Object.assign(Object.assign({}, props), {
      type: "info"
    });
  }
  function withSuccess(props) {
    return Object.assign(Object.assign({}, props), {
      type: "success"
    });
  }
  function withError(props) {
    return Object.assign(Object.assign({}, props), {
      type: "error"
    });
  }
  function withConfirm(props) {
    return Object.assign(Object.assign({}, props), {
      type: "confirm"
    });
  }
  function modalGlobalConfig(_ref) {
    let {
      rootPrefixCls
    } = _ref;
    defaultRootPrefixCls = rootPrefixCls;
  }
  const HookModal = (_ref, ref) => {
    let {
      afterClose: hookAfterClose,
      config
    } = _ref;
    var _a2;
    const [open, setOpen] = React__namespace.useState(true);
    const [innerConfig, setInnerConfig] = React__namespace.useState(config);
    const {
      direction,
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("modal");
    const rootPrefixCls = getPrefixCls();
    const afterClose = () => {
      var _a3;
      hookAfterClose();
      (_a3 = innerConfig.afterClose) === null || _a3 === void 0 ? void 0 : _a3.call(innerConfig);
    };
    const close = function() {
      setOpen(false);
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      const triggerCancel = args.some((param) => param && param.triggerCancel);
      if (innerConfig.onCancel && triggerCancel) {
        innerConfig.onCancel.apply(innerConfig, [() => {
        }].concat(_toConsumableArray(args.slice(1))));
      }
    };
    React__namespace.useImperativeHandle(ref, () => ({
      destroy: close,
      update: (newConfig) => {
        setInnerConfig((originConfig) => Object.assign(Object.assign({}, originConfig), newConfig));
      }
    }));
    const mergedOkCancel = (_a2 = innerConfig.okCancel) !== null && _a2 !== void 0 ? _a2 : innerConfig.type === "confirm";
    const [contextLocale] = useLocale$1("Modal", defaultLocale.Modal);
    return /* @__PURE__ */ React__namespace.createElement(ConfirmDialog$1, Object.assign({
      prefixCls,
      rootPrefixCls
    }, innerConfig, {
      close,
      open,
      afterClose,
      okText: innerConfig.okText || (mergedOkCancel ? contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.okText : contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.justOkText),
      direction: innerConfig.direction || direction,
      cancelText: innerConfig.cancelText || (contextLocale === null || contextLocale === void 0 ? void 0 : contextLocale.cancelText)
    }));
  };
  const HookModal$1 = /* @__PURE__ */ React__namespace.forwardRef(HookModal);
  let uuid = 0;
  const ElementsHolder = /* @__PURE__ */ React__namespace.memo(/* @__PURE__ */ React__namespace.forwardRef((_props, ref) => {
    const [elements, patchElement] = usePatchElement();
    React__namespace.useImperativeHandle(ref, () => ({
      patchElement
    }), []);
    return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, elements);
  }));
  function useModal() {
    const holderRef = React__namespace.useRef(null);
    const [actionQueue, setActionQueue] = React__namespace.useState([]);
    React__namespace.useEffect(() => {
      if (actionQueue.length) {
        const cloneQueue = _toConsumableArray(actionQueue);
        cloneQueue.forEach((action2) => {
          action2();
        });
        setActionQueue([]);
      }
    }, [actionQueue]);
    const getConfirmFunc = React__namespace.useCallback((withFunc) => function hookConfirm(config) {
      var _a2;
      uuid += 1;
      const modalRef = /* @__PURE__ */ React__namespace.createRef();
      let closeFunc;
      const modal = /* @__PURE__ */ React__namespace.createElement(HookModal$1, {
        key: `modal-${uuid}`,
        config: withFunc(config),
        ref: modalRef,
        afterClose: () => {
          closeFunc === null || closeFunc === void 0 ? void 0 : closeFunc();
        }
      });
      closeFunc = (_a2 = holderRef.current) === null || _a2 === void 0 ? void 0 : _a2.patchElement(modal);
      if (closeFunc) {
        destroyFns$1.push(closeFunc);
      }
      return {
        destroy: () => {
          function destroyAction() {
            var _a3;
            (_a3 = modalRef.current) === null || _a3 === void 0 ? void 0 : _a3.destroy();
          }
          if (modalRef.current) {
            destroyAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [destroyAction]));
          }
        },
        update: (newConfig) => {
          function updateAction() {
            var _a3;
            (_a3 = modalRef.current) === null || _a3 === void 0 ? void 0 : _a3.update(newConfig);
          }
          if (modalRef.current) {
            updateAction();
          } else {
            setActionQueue((prev2) => [].concat(_toConsumableArray(prev2), [updateAction]));
          }
        }
      };
    }, []);
    const fns = React__namespace.useMemo(() => ({
      info: getConfirmFunc(withInfo),
      success: getConfirmFunc(withSuccess),
      error: getConfirmFunc(withError),
      warning: getConfirmFunc(withWarn),
      confirm: getConfirmFunc(withConfirm)
    }), []);
    return [fns, /* @__PURE__ */ React__namespace.createElement(ElementsHolder, {
      key: "modal-holder",
      ref: holderRef
    })];
  }
  const isMobile = function() {
    if (typeof navigator === "undefined" || typeof window === "undefined") {
      return false;
    }
    var agent = navigator.userAgent || navigator.vendor || window.opera;
    return /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4));
  };
  var TriggerContext = /* @__PURE__ */ React__namespace.createContext(null);
  function toArray$1(val) {
    return val ? Array.isArray(val) ? val : [val] : [];
  }
  function useAction(mobile, action2, showAction, hideAction) {
    return React__namespace.useMemo(function() {
      var mergedShowAction = toArray$1(showAction !== null && showAction !== void 0 ? showAction : action2);
      var mergedHideAction = toArray$1(hideAction !== null && hideAction !== void 0 ? hideAction : action2);
      var showActionSet = new Set(mergedShowAction);
      var hideActionSet = new Set(mergedHideAction);
      if (mobile) {
        if (showActionSet.has("hover")) {
          showActionSet.delete("hover");
          showActionSet.add("click");
        }
        if (hideActionSet.has("hover")) {
          hideActionSet.delete("hover");
          hideActionSet.add("click");
        }
      }
      return [showActionSet, hideActionSet];
    }, [mobile, action2, showAction, hideAction]);
  }
  function isPointsEq() {
    var a1 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    var a2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
    var isAlignPoint = arguments.length > 2 ? arguments[2] : void 0;
    if (isAlignPoint) {
      return a1[0] === a2[0];
    }
    return a1[0] === a2[0] && a1[1] === a2[1];
  }
  function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
    var points = align.points;
    var placements2 = Object.keys(builtinPlacements);
    for (var i = 0; i < placements2.length; i += 1) {
      var _builtinPlacements$pl;
      var placement = placements2[i];
      if (isPointsEq((_builtinPlacements$pl = builtinPlacements[placement]) === null || _builtinPlacements$pl === void 0 ? void 0 : _builtinPlacements$pl.points, points, isAlignPoint)) {
        return "".concat(prefixCls, "-placement-").concat(placement);
      }
    }
    return "";
  }
  function getMotion(prefixCls, motion, animation, transitionName) {
    if (motion) {
      return motion;
    }
    if (animation) {
      return {
        motionName: "".concat(prefixCls, "-").concat(animation)
      };
    }
    if (transitionName) {
      return {
        motionName: transitionName
      };
    }
    return null;
  }
  function getWin(ele) {
    return ele.ownerDocument.defaultView;
  }
  function collectScroller(ele) {
    var scrollerList = [];
    var current = ele === null || ele === void 0 ? void 0 : ele.parentElement;
    var scrollStyle = ["hidden", "scroll", "clip", "auto"];
    while (current) {
      var _getWin$getComputedSt = getWin(current).getComputedStyle(current), overflowX = _getWin$getComputedSt.overflowX, overflowY = _getWin$getComputedSt.overflowY, overflow = _getWin$getComputedSt.overflow;
      if ([overflowX, overflowY, overflow].some(function(o) {
        return scrollStyle.includes(o);
      })) {
        scrollerList.push(current);
      }
      current = current.parentElement;
    }
    return scrollerList;
  }
  function toNum(num) {
    var defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
    return Number.isNaN(num) ? defaultValue : num;
  }
  function getPxValue(val) {
    return toNum(parseFloat(val), 0);
  }
  function getVisibleArea(initArea, scrollerList) {
    var visibleArea = _objectSpread2({}, initArea);
    (scrollerList || []).forEach(function(ele) {
      if (ele instanceof HTMLBodyElement) {
        return;
      }
      var _getWin$getComputedSt2 = getWin(ele).getComputedStyle(ele), overflow = _getWin$getComputedSt2.overflow, overflowClipMargin = _getWin$getComputedSt2.overflowClipMargin, borderTopWidth = _getWin$getComputedSt2.borderTopWidth, borderBottomWidth = _getWin$getComputedSt2.borderBottomWidth, borderLeftWidth = _getWin$getComputedSt2.borderLeftWidth, borderRightWidth = _getWin$getComputedSt2.borderRightWidth;
      var eleRect = ele.getBoundingClientRect();
      var eleOutHeight = ele.offsetHeight, eleInnerHeight = ele.clientHeight, eleOutWidth = ele.offsetWidth, eleInnerWidth = ele.clientWidth;
      var borderTopNum = getPxValue(borderTopWidth);
      var borderBottomNum = getPxValue(borderBottomWidth);
      var borderLeftNum = getPxValue(borderLeftWidth);
      var borderRightNum = getPxValue(borderRightWidth);
      var scaleX = toNum(Math.round(eleRect.width / eleOutWidth * 1e3) / 1e3);
      var scaleY = toNum(Math.round(eleRect.height / eleOutHeight * 1e3) / 1e3);
      var eleScrollWidth = (eleOutWidth - eleInnerWidth - borderLeftNum - borderRightNum) * scaleX;
      var eleScrollHeight = (eleOutHeight - eleInnerHeight - borderTopNum - borderBottomNum) * scaleY;
      var scaledBorderTopWidth = borderTopNum * scaleY;
      var scaledBorderBottomWidth = borderBottomNum * scaleY;
      var scaledBorderLeftWidth = borderLeftNum * scaleX;
      var scaledBorderRightWidth = borderRightNum * scaleX;
      var clipMarginWidth = 0;
      var clipMarginHeight = 0;
      if (overflow === "clip") {
        var clipNum = getPxValue(overflowClipMargin);
        clipMarginWidth = clipNum * scaleX;
        clipMarginHeight = clipNum * scaleY;
      }
      var eleLeft = eleRect.x + scaledBorderLeftWidth - clipMarginWidth;
      var eleTop = eleRect.y + scaledBorderTopWidth - clipMarginHeight;
      var eleRight = eleLeft + eleRect.width + 2 * clipMarginWidth - scaledBorderLeftWidth - scaledBorderRightWidth - eleScrollWidth;
      var eleBottom = eleTop + eleRect.height + 2 * clipMarginHeight - scaledBorderTopWidth - scaledBorderBottomWidth - eleScrollHeight;
      visibleArea.left = Math.max(visibleArea.left, eleLeft);
      visibleArea.top = Math.max(visibleArea.top, eleTop);
      visibleArea.right = Math.min(visibleArea.right, eleRight);
      visibleArea.bottom = Math.min(visibleArea.bottom, eleBottom);
    });
    return visibleArea;
  }
  function getUnitOffset(size) {
    var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
    var offsetStr = "".concat(offset2);
    var cells = offsetStr.match(/^(.*)\%$/);
    if (cells) {
      return size * (parseFloat(cells[1]) / 100);
    }
    return parseFloat(offsetStr);
  }
  function getNumberOffset(rect, offset2) {
    var _ref = offset2 || [], _ref2 = _slicedToArray(_ref, 2), offsetX = _ref2[0], offsetY = _ref2[1];
    return [getUnitOffset(rect.width, offsetX), getUnitOffset(rect.height, offsetY)];
  }
  function splitPoints() {
    var points = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
    return [points[0], points[1]];
  }
  function getAlignPoint(rect, points) {
    var topBottom = points[0];
    var leftRight = points[1];
    var x2;
    var y2;
    if (topBottom === "t") {
      y2 = rect.y;
    } else if (topBottom === "b") {
      y2 = rect.y + rect.height;
    } else {
      y2 = rect.y + rect.height / 2;
    }
    if (leftRight === "l") {
      x2 = rect.x;
    } else if (leftRight === "r") {
      x2 = rect.x + rect.width;
    } else {
      x2 = rect.x + rect.width / 2;
    }
    return {
      x: x2,
      y: y2
    };
  }
  function reversePoints(points, index2) {
    var reverseMap = {
      t: "b",
      b: "t",
      l: "r",
      r: "l"
    };
    return points.map(function(point, i) {
      if (i === index2) {
        return reverseMap[point] || "c";
      }
      return point;
    }).join("");
  }
  function useAlign(open, popupEle, target, placement, builtinPlacements, popupAlign, onPopupAlign) {
    var _React$useState = React__namespace.useState({
      ready: false,
      offsetX: 0,
      offsetY: 0,
      offsetR: 0,
      offsetB: 0,
      arrowX: 0,
      arrowY: 0,
      scaleX: 1,
      scaleY: 1,
      align: builtinPlacements[placement] || {}
    }), _React$useState2 = _slicedToArray(_React$useState, 2), offsetInfo = _React$useState2[0], setOffsetInfo = _React$useState2[1];
    var alignCountRef = React__namespace.useRef(0);
    var scrollerList = React__namespace.useMemo(function() {
      if (!popupEle) {
        return [];
      }
      return collectScroller(popupEle);
    }, [popupEle]);
    var prevFlipRef = React__namespace.useRef({});
    var resetFlipCache = function resetFlipCache2() {
      prevFlipRef.current = {};
    };
    if (!open) {
      resetFlipCache();
    }
    var onAlign = useEvent(function() {
      if (popupEle && target && open) {
        let getIntersectionVisibleArea = function(offsetX, offsetY) {
          var area = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : visibleArea;
          var l2 = popupRect.x + offsetX;
          var t2 = popupRect.y + offsetY;
          var r2 = l2 + popupWidth;
          var b2 = t2 + popupHeight;
          var visibleL = Math.max(l2, area.left);
          var visibleT = Math.max(t2, area.top);
          var visibleR = Math.min(r2, area.right);
          var visibleB = Math.min(b2, area.bottom);
          return Math.max(0, (visibleR - visibleL) * (visibleB - visibleT));
        }, syncNextPopupPosition = function() {
          nextPopupY = popupRect.y + nextOffsetY;
          nextPopupBottom = nextPopupY + popupHeight;
          nextPopupX = popupRect.x + nextOffsetX;
          nextPopupRight = nextPopupX + popupWidth;
        };
        var popupElement = popupEle;
        var originLeft = popupElement.style.left;
        var originTop = popupElement.style.top;
        var originRight = popupElement.style.right;
        var originBottom = popupElement.style.bottom;
        var doc = popupElement.ownerDocument;
        var win = getWin(popupElement);
        var placementInfo = _objectSpread2(_objectSpread2({}, builtinPlacements[placement]), popupAlign);
        popupElement.style.left = "0";
        popupElement.style.top = "0";
        popupElement.style.right = "auto";
        popupElement.style.bottom = "auto";
        var targetRect;
        if (Array.isArray(target)) {
          targetRect = {
            x: target[0],
            y: target[1],
            width: 0,
            height: 0
          };
        } else {
          var rect = target.getBoundingClientRect();
          targetRect = {
            x: rect.x,
            y: rect.y,
            width: rect.width,
            height: rect.height
          };
        }
        var popupRect = popupElement.getBoundingClientRect();
        var _win$getComputedStyle = win.getComputedStyle(popupElement), width = _win$getComputedStyle.width, height = _win$getComputedStyle.height;
        var _doc$documentElement = doc.documentElement, clientWidth = _doc$documentElement.clientWidth, clientHeight = _doc$documentElement.clientHeight, scrollWidth = _doc$documentElement.scrollWidth, scrollHeight = _doc$documentElement.scrollHeight, scrollTop = _doc$documentElement.scrollTop, scrollLeft = _doc$documentElement.scrollLeft;
        var popupHeight = popupRect.height;
        var popupWidth = popupRect.width;
        var targetHeight = targetRect.height;
        var targetWidth = targetRect.width;
        var visibleRegion = {
          left: 0,
          top: 0,
          right: clientWidth,
          bottom: clientHeight
        };
        var scrollRegion = {
          left: -scrollLeft,
          top: -scrollTop,
          right: scrollWidth - scrollLeft,
          bottom: scrollHeight - scrollTop
        };
        var htmlRegion = placementInfo.htmlRegion;
        var VISIBLE = "visible";
        var VISIBLE_FIRST = "visibleFirst";
        if (htmlRegion !== "scroll" && htmlRegion !== VISIBLE_FIRST) {
          htmlRegion = VISIBLE;
        }
        var isVisibleFirst = htmlRegion === VISIBLE_FIRST;
        var scrollRegionArea = getVisibleArea(scrollRegion, scrollerList);
        var visibleRegionArea = getVisibleArea(visibleRegion, scrollerList);
        var visibleArea = htmlRegion === VISIBLE ? visibleRegionArea : scrollRegionArea;
        var adjustCheckVisibleArea = isVisibleFirst ? visibleRegionArea : visibleArea;
        popupElement.style.left = "auto";
        popupElement.style.top = "auto";
        popupElement.style.right = "0";
        popupElement.style.bottom = "0";
        var popupMirrorRect = popupElement.getBoundingClientRect();
        popupElement.style.left = originLeft;
        popupElement.style.top = originTop;
        popupElement.style.right = originRight;
        popupElement.style.bottom = originBottom;
        var _scaleX = toNum(Math.round(popupWidth / parseFloat(width) * 1e3) / 1e3);
        var _scaleY = toNum(Math.round(popupHeight / parseFloat(height) * 1e3) / 1e3);
        if (_scaleX === 0 || _scaleY === 0 || isDOM(target) && !isVisible(target)) {
          return;
        }
        var offset2 = placementInfo.offset, targetOffset2 = placementInfo.targetOffset;
        var _getNumberOffset = getNumberOffset(popupRect, offset2), _getNumberOffset2 = _slicedToArray(_getNumberOffset, 2), popupOffsetX = _getNumberOffset2[0], popupOffsetY = _getNumberOffset2[1];
        var _getNumberOffset3 = getNumberOffset(targetRect, targetOffset2), _getNumberOffset4 = _slicedToArray(_getNumberOffset3, 2), targetOffsetX = _getNumberOffset4[0], targetOffsetY = _getNumberOffset4[1];
        targetRect.x -= targetOffsetX;
        targetRect.y -= targetOffsetY;
        var _ref3 = placementInfo.points || [], _ref4 = _slicedToArray(_ref3, 2), popupPoint = _ref4[0], targetPoint = _ref4[1];
        var targetPoints = splitPoints(targetPoint);
        var popupPoints = splitPoints(popupPoint);
        var targetAlignPoint = getAlignPoint(targetRect, targetPoints);
        var popupAlignPoint = getAlignPoint(popupRect, popupPoints);
        var nextAlignInfo = _objectSpread2({}, placementInfo);
        var nextOffsetX = targetAlignPoint.x - popupAlignPoint.x + popupOffsetX;
        var nextOffsetY = targetAlignPoint.y - popupAlignPoint.y + popupOffsetY;
        var originIntersectionVisibleArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY);
        var originIntersectionRecommendArea = getIntersectionVisibleArea(nextOffsetX, nextOffsetY, visibleRegionArea);
        var targetAlignPointTL = getAlignPoint(targetRect, ["t", "l"]);
        var popupAlignPointTL = getAlignPoint(popupRect, ["t", "l"]);
        var targetAlignPointBR = getAlignPoint(targetRect, ["b", "r"]);
        var popupAlignPointBR = getAlignPoint(popupRect, ["b", "r"]);
        var overflow = placementInfo.overflow || {};
        var adjustX = overflow.adjustX, adjustY = overflow.adjustY, shiftX = overflow.shiftX, shiftY = overflow.shiftY;
        var supportAdjust = function supportAdjust2(val) {
          if (typeof val === "boolean") {
            return val;
          }
          return val >= 0;
        };
        var nextPopupY;
        var nextPopupBottom;
        var nextPopupX;
        var nextPopupRight;
        syncNextPopupPosition();
        var needAdjustY = supportAdjust(adjustY);
        var sameTB = popupPoints[0] === targetPoints[0];
        if (needAdjustY && popupPoints[0] === "t" && (nextPopupBottom > adjustCheckVisibleArea.bottom || prevFlipRef.current.bt)) {
          var tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            tmpNextOffsetY -= popupHeight - targetHeight;
          } else {
            tmpNextOffsetY = targetAlignPointTL.y - popupAlignPointBR.y - popupOffsetY;
          }
          var newVisibleArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY);
          var newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            newVisibleArea > originIntersectionVisibleArea || newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.bt = true;
            nextOffsetY = tmpNextOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.bt = false;
          }
        }
        if (needAdjustY && popupPoints[0] === "b" && (nextPopupY < adjustCheckVisibleArea.top || prevFlipRef.current.tb)) {
          var _tmpNextOffsetY = nextOffsetY;
          if (sameTB) {
            _tmpNextOffsetY += popupHeight - targetHeight;
          } else {
            _tmpNextOffsetY = targetAlignPointBR.y - popupAlignPointTL.y - popupOffsetY;
          }
          var _newVisibleArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY);
          var _newVisibleRecommendArea = getIntersectionVisibleArea(nextOffsetX, _tmpNextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea > originIntersectionVisibleArea || _newVisibleArea === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.tb = true;
            nextOffsetY = _tmpNextOffsetY;
            nextAlignInfo.points = [reversePoints(popupPoints, 0), reversePoints(targetPoints, 0)];
          } else {
            prevFlipRef.current.tb = false;
          }
        }
        var needAdjustX = supportAdjust(adjustX);
        var sameLR = popupPoints[1] === targetPoints[1];
        if (needAdjustX && popupPoints[1] === "l" && (nextPopupRight > adjustCheckVisibleArea.right || prevFlipRef.current.rl)) {
          var tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            tmpNextOffsetX -= popupWidth - targetWidth;
          } else {
            tmpNextOffsetX = targetAlignPointTL.x - popupAlignPointBR.x - popupOffsetX;
          }
          var _newVisibleArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea2 = getIntersectionVisibleArea(tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea2 > originIntersectionVisibleArea || _newVisibleArea2 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea2 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.rl = true;
            nextOffsetX = tmpNextOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.rl = false;
          }
        }
        if (needAdjustX && popupPoints[1] === "r" && (nextPopupX < adjustCheckVisibleArea.left || prevFlipRef.current.lr)) {
          var _tmpNextOffsetX = nextOffsetX;
          if (sameLR) {
            _tmpNextOffsetX += popupWidth - targetWidth;
          } else {
            _tmpNextOffsetX = targetAlignPointBR.x - popupAlignPointTL.x - popupOffsetX;
          }
          var _newVisibleArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY);
          var _newVisibleRecommendArea3 = getIntersectionVisibleArea(_tmpNextOffsetX, nextOffsetY, visibleRegionArea);
          if (
            // Of course use larger one
            _newVisibleArea3 > originIntersectionVisibleArea || _newVisibleArea3 === originIntersectionVisibleArea && (!isVisibleFirst || // Choose recommend one
            _newVisibleRecommendArea3 >= originIntersectionRecommendArea)
          ) {
            prevFlipRef.current.lr = true;
            nextOffsetX = _tmpNextOffsetX;
            nextAlignInfo.points = [reversePoints(popupPoints, 1), reversePoints(targetPoints, 1)];
          } else {
            prevFlipRef.current.lr = false;
          }
        }
        syncNextPopupPosition();
        var numShiftX = shiftX === true ? 0 : shiftX;
        if (typeof numShiftX === "number") {
          if (nextPopupX < visibleRegionArea.left) {
            nextOffsetX -= nextPopupX - visibleRegionArea.left;
            if (targetRect.x + targetWidth < visibleRegionArea.left + numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.left + targetWidth - numShiftX;
            }
          }
          if (nextPopupRight > visibleRegionArea.right) {
            nextOffsetX -= nextPopupRight - visibleRegionArea.right;
            if (targetRect.x > visibleRegionArea.right - numShiftX) {
              nextOffsetX += targetRect.x - visibleRegionArea.right + numShiftX;
            }
          }
        }
        var numShiftY = shiftY === true ? 0 : shiftY;
        if (typeof numShiftY === "number") {
          if (nextPopupY < visibleRegionArea.top) {
            nextOffsetY -= nextPopupY - visibleRegionArea.top;
            if (targetRect.y + targetHeight < visibleRegionArea.top + numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.top + targetHeight - numShiftY;
            }
          }
          if (nextPopupBottom > visibleRegionArea.bottom) {
            nextOffsetY -= nextPopupBottom - visibleRegionArea.bottom;
            if (targetRect.y > visibleRegionArea.bottom - numShiftY) {
              nextOffsetY += targetRect.y - visibleRegionArea.bottom + numShiftY;
            }
          }
        }
        var popupLeft = popupRect.x + nextOffsetX;
        var popupRight = popupLeft + popupWidth;
        var popupTop = popupRect.y + nextOffsetY;
        var popupBottom = popupTop + popupHeight;
        var targetLeft = targetRect.x;
        var targetRight = targetLeft + targetWidth;
        var targetTop = targetRect.y;
        var targetBottom = targetTop + targetHeight;
        var maxLeft = Math.max(popupLeft, targetLeft);
        var minRight = Math.min(popupRight, targetRight);
        var xCenter = (maxLeft + minRight) / 2;
        var nextArrowX = xCenter - popupLeft;
        var maxTop = Math.max(popupTop, targetTop);
        var minBottom = Math.min(popupBottom, targetBottom);
        var yCenter = (maxTop + minBottom) / 2;
        var nextArrowY = yCenter - popupTop;
        onPopupAlign === null || onPopupAlign === void 0 ? void 0 : onPopupAlign(popupEle, nextAlignInfo);
        var offsetX4Right = popupMirrorRect.right - popupRect.x - (nextOffsetX + popupRect.width);
        var offsetY4Bottom = popupMirrorRect.bottom - popupRect.y - (nextOffsetY + popupRect.height);
        setOffsetInfo({
          ready: true,
          offsetX: nextOffsetX / _scaleX,
          offsetY: nextOffsetY / _scaleY,
          offsetR: offsetX4Right / _scaleX,
          offsetB: offsetY4Bottom / _scaleY,
          arrowX: nextArrowX / _scaleX,
          arrowY: nextArrowY / _scaleY,
          scaleX: _scaleX,
          scaleY: _scaleY,
          align: nextAlignInfo
        });
      }
    });
    var triggerAlign = function triggerAlign2() {
      alignCountRef.current += 1;
      var id2 = alignCountRef.current;
      Promise.resolve().then(function() {
        if (alignCountRef.current === id2) {
          onAlign();
        }
      });
    };
    var resetReady = function resetReady2() {
      setOffsetInfo(function(ori) {
        return _objectSpread2(_objectSpread2({}, ori), {}, {
          ready: false
        });
      });
    };
    useLayoutEffect(resetReady, [placement]);
    useLayoutEffect(function() {
      if (!open) {
        resetReady();
      }
    }, [open]);
    return [offsetInfo.ready, offsetInfo.offsetX, offsetInfo.offsetY, offsetInfo.offsetR, offsetInfo.offsetB, offsetInfo.arrowX, offsetInfo.arrowY, offsetInfo.scaleX, offsetInfo.scaleY, offsetInfo.align, triggerAlign];
  }
  function useWatch(open, target, popup, onAlign) {
    useLayoutEffect(function() {
      if (open && target && popup) {
        let notifyScroll = function() {
          onAlign();
        };
        var targetElement = target;
        var popupElement = popup;
        var targetScrollList = collectScroller(targetElement);
        var popupScrollList = collectScroller(popupElement);
        var win = getWin(popupElement);
        var mergedList = new Set([win].concat(_toConsumableArray(targetScrollList), _toConsumableArray(popupScrollList)));
        mergedList.forEach(function(scroller) {
          scroller.addEventListener("scroll", notifyScroll, {
            passive: true
          });
        });
        win.addEventListener("resize", notifyScroll, {
          passive: true
        });
        onAlign();
        return function() {
          mergedList.forEach(function(scroller) {
            scroller.removeEventListener("scroll", notifyScroll);
            win.removeEventListener("resize", notifyScroll);
          });
        };
      }
    }, [open, target, popup]);
  }
  function useWinClick(open, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen) {
    var openRef = React__namespace.useRef(open);
    var lockRef = React__namespace.useRef(false);
    if (openRef.current !== open) {
      lockRef.current = true;
      openRef.current = open;
    }
    React__namespace.useEffect(function() {
      var id2 = wrapperRaf(function() {
        lockRef.current = false;
      });
      return function() {
        wrapperRaf.cancel(id2);
      };
    }, [open]);
    React__namespace.useEffect(function() {
      if (clickToHide && popupEle && (!mask || maskClosable)) {
        var genClickEvents = function genClickEvents2() {
          var clickInside = false;
          var onWindowMouseDown = function onWindowMouseDown2(_ref) {
            var target = _ref.target;
            clickInside = inPopupOrChild(target);
          };
          var onWindowClick = function onWindowClick2(_ref2) {
            var target = _ref2.target;
            if (!lockRef.current && openRef.current && !clickInside && !inPopupOrChild(target)) {
              triggerOpen(false);
            }
          };
          return [onWindowMouseDown, onWindowClick];
        };
        var _genClickEvents = genClickEvents(), _genClickEvents2 = _slicedToArray(_genClickEvents, 2), onWinMouseDown = _genClickEvents2[0], onWinClick = _genClickEvents2[1];
        var _genClickEvents3 = genClickEvents(), _genClickEvents4 = _slicedToArray(_genClickEvents3, 2), onShadowMouseDown = _genClickEvents4[0], onShadowClick = _genClickEvents4[1];
        var win = getWin(popupEle);
        win.addEventListener("mousedown", onWinMouseDown);
        win.addEventListener("click", onWinClick);
        win.addEventListener("contextmenu", onWinClick);
        var targetShadowRoot = getShadowRoot(targetEle);
        if (targetShadowRoot) {
          targetShadowRoot.addEventListener("mousedown", onShadowMouseDown);
          targetShadowRoot.addEventListener("click", onShadowClick);
          targetShadowRoot.addEventListener("contextmenu", onShadowClick);
        }
        return function() {
          win.removeEventListener("mousedown", onWinMouseDown);
          win.removeEventListener("click", onWinClick);
          win.removeEventListener("contextmenu", onWinClick);
          if (targetShadowRoot) {
            targetShadowRoot.removeEventListener("mousedown", onShadowMouseDown);
            targetShadowRoot.removeEventListener("click", onShadowClick);
            targetShadowRoot.removeEventListener("contextmenu", onShadowClick);
          }
        };
      }
    }, [clickToHide, targetEle, popupEle, mask, maskClosable]);
  }
  function Arrow(props) {
    var prefixCls = props.prefixCls, align = props.align, arrow = props.arrow, arrowPos = props.arrowPos;
    var _ref = arrow || {}, className = _ref.className, content = _ref.content;
    var _arrowPos$x = arrowPos.x, x2 = _arrowPos$x === void 0 ? 0 : _arrowPos$x, _arrowPos$y = arrowPos.y, y2 = _arrowPos$y === void 0 ? 0 : _arrowPos$y;
    var arrowRef = React__namespace.useRef();
    if (!align || !align.points) {
      return null;
    }
    var alignStyle = {
      position: "absolute"
    };
    if (align.autoArrow !== false) {
      var popupPoints = align.points[0];
      var targetPoints = align.points[1];
      var popupTB = popupPoints[0];
      var popupLR = popupPoints[1];
      var targetTB = targetPoints[0];
      var targetLR = targetPoints[1];
      if (popupTB === targetTB || !["t", "b"].includes(popupTB)) {
        alignStyle.top = y2;
      } else if (popupTB === "t") {
        alignStyle.top = 0;
      } else {
        alignStyle.bottom = 0;
      }
      if (popupLR === targetLR || !["l", "r"].includes(popupLR)) {
        alignStyle.left = x2;
      } else if (popupLR === "l") {
        alignStyle.left = 0;
      } else {
        alignStyle.right = 0;
      }
    }
    return /* @__PURE__ */ React__namespace.createElement("div", {
      ref: arrowRef,
      className: classNames("".concat(prefixCls, "-arrow"), className),
      style: alignStyle
    }, content);
  }
  function Mask(props) {
    var prefixCls = props.prefixCls, open = props.open, zIndex = props.zIndex, mask = props.mask, motion = props.motion;
    if (!mask) {
      return null;
    }
    return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$2({}, motion, {
      motionAppear: true,
      visible: open,
      removeOnLeave: true
    }), function(_ref) {
      var className = _ref.className;
      return /* @__PURE__ */ React__namespace.createElement("div", {
        style: {
          zIndex
        },
        className: classNames("".concat(prefixCls, "-mask"), className)
      });
    });
  }
  var PopupContent = /* @__PURE__ */ React__namespace.memo(function(_ref) {
    var children = _ref.children;
    return children;
  }, function(_2, next2) {
    return next2.cache;
  });
  var Popup$1 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var popup = props.popup, className = props.className, prefixCls = props.prefixCls, style2 = props.style, target = props.target, _onVisibleChanged = props.onVisibleChanged, open = props.open, keepDom = props.keepDom, onClick = props.onClick, mask = props.mask, arrow = props.arrow, arrowPos = props.arrowPos, align = props.align, motion = props.motion, maskMotion = props.maskMotion, forceRender = props.forceRender, getPopupContainer = props.getPopupContainer, autoDestroy = props.autoDestroy, Portal2 = props.portal, zIndex = props.zIndex, onMouseEnter = props.onMouseEnter, onMouseLeave = props.onMouseLeave, ready = props.ready, offsetX = props.offsetX, offsetY = props.offsetY, offsetR = props.offsetR, offsetB = props.offsetB, onAlign = props.onAlign, onPrepare = props.onPrepare, stretch = props.stretch, targetWidth = props.targetWidth, targetHeight = props.targetHeight;
    var childNode = typeof popup === "function" ? popup() : popup;
    var isNodeVisible = open || keepDom;
    var getPopupContainerNeedParams = (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer.length) > 0;
    var _React$useState = React__namespace.useState(!getPopupContainer || !getPopupContainerNeedParams), _React$useState2 = _slicedToArray(_React$useState, 2), show = _React$useState2[0], setShow = _React$useState2[1];
    useLayoutEffect(function() {
      if (!show && getPopupContainerNeedParams && target) {
        setShow(true);
      }
    }, [show, getPopupContainerNeedParams, target]);
    if (!show) {
      return null;
    }
    var AUTO2 = "auto";
    var offsetStyle = {
      left: "-1000vw",
      top: "-1000vh",
      right: AUTO2,
      bottom: AUTO2
    };
    if (ready || !open) {
      var points = align.points, _experimental = align._experimental;
      var dynamicInset = _experimental === null || _experimental === void 0 ? void 0 : _experimental.dynamicInset;
      var alignRight = dynamicInset && points[0][1] === "r";
      var alignBottom = dynamicInset && points[0][0] === "b";
      if (alignRight) {
        offsetStyle.right = offsetR;
        offsetStyle.left = AUTO2;
      } else {
        offsetStyle.left = offsetX;
        offsetStyle.right = AUTO2;
      }
      if (alignBottom) {
        offsetStyle.bottom = offsetB;
        offsetStyle.top = AUTO2;
      } else {
        offsetStyle.top = offsetY;
        offsetStyle.bottom = AUTO2;
      }
    }
    var miscStyle = {};
    if (stretch) {
      if (stretch.includes("height") && targetHeight) {
        miscStyle.height = targetHeight;
      } else if (stretch.includes("minHeight") && targetHeight) {
        miscStyle.minHeight = targetHeight;
      }
      if (stretch.includes("width") && targetWidth) {
        miscStyle.width = targetWidth;
      } else if (stretch.includes("minWidth") && targetWidth) {
        miscStyle.minWidth = targetWidth;
      }
    }
    if (!open) {
      miscStyle.pointerEvents = "none";
    }
    return /* @__PURE__ */ React__namespace.createElement(Portal2, {
      open: forceRender || isNodeVisible,
      getContainer: getPopupContainer && function() {
        return getPopupContainer(target);
      },
      autoDestroy
    }, /* @__PURE__ */ React__namespace.createElement(Mask, {
      prefixCls,
      open,
      zIndex,
      mask,
      motion: maskMotion
    }), /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
      onResize: onAlign,
      disabled: !open
    }, function(resizeObserverRef) {
      return /* @__PURE__ */ React__namespace.createElement(CSSMotion, _extends$2({
        motionAppear: true,
        motionEnter: true,
        motionLeave: true,
        removeOnLeave: false,
        forceRender,
        leavedClassName: "".concat(prefixCls, "-hidden")
      }, motion, {
        onAppearPrepare: onPrepare,
        onEnterPrepare: onPrepare,
        visible: open,
        onVisibleChanged: function onVisibleChanged(nextVisible) {
          var _motion$onVisibleChan;
          motion === null || motion === void 0 ? void 0 : (_motion$onVisibleChan = motion.onVisibleChanged) === null || _motion$onVisibleChan === void 0 ? void 0 : _motion$onVisibleChan.call(motion, nextVisible);
          _onVisibleChanged(nextVisible);
        }
      }), function(_ref, motionRef) {
        var motionClassName = _ref.className, motionStyle = _ref.style;
        var cls = classNames(prefixCls, motionClassName, className);
        return /* @__PURE__ */ React__namespace.createElement("div", {
          ref: composeRef(resizeObserverRef, ref, motionRef),
          className: cls,
          style: _objectSpread2(_objectSpread2(_objectSpread2(_objectSpread2({
            "--arrow-x": "".concat(arrowPos.x || 0, "px"),
            "--arrow-y": "".concat(arrowPos.y || 0, "px")
          }, offsetStyle), miscStyle), motionStyle), {}, {
            boxSizing: "border-box",
            zIndex
          }, style2),
          onMouseEnter,
          onMouseLeave,
          onClick
        }, arrow && /* @__PURE__ */ React__namespace.createElement(Arrow, {
          prefixCls,
          arrow,
          arrowPos,
          align
        }), /* @__PURE__ */ React__namespace.createElement(PopupContent, {
          cache: !open
        }, childNode));
      });
    }));
  });
  var TriggerWrapper = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
    var children = props.children, getTriggerDOMNode = props.getTriggerDOMNode;
    var canUseRef = supportRef(children);
    var setRef = React__namespace.useCallback(function(node2) {
      fillRef(ref, getTriggerDOMNode ? getTriggerDOMNode(node2) : node2);
    }, [getTriggerDOMNode]);
    var mergedRef = useComposeRef(setRef, children.ref);
    return canUseRef ? /* @__PURE__ */ React__namespace.cloneElement(children, {
      ref: mergedRef
    }) : children;
  });
  var _excluded$1 = ["prefixCls", "children", "action", "showAction", "hideAction", "popupVisible", "defaultPopupVisible", "onPopupVisibleChange", "afterPopupVisibleChange", "mouseEnterDelay", "mouseLeaveDelay", "focusDelay", "blurDelay", "mask", "maskClosable", "getPopupContainer", "forceRender", "autoDestroy", "destroyPopupOnHide", "popup", "popupClassName", "popupStyle", "popupPlacement", "builtinPlacements", "popupAlign", "zIndex", "stretch", "getPopupClassNameFromAlign", "alignPoint", "onPopupClick", "onPopupAlign", "arrow", "popupMotion", "maskMotion", "popupTransitionName", "popupAnimation", "maskTransitionName", "maskAnimation", "className", "getTriggerDOMNode"];
  function generateTrigger() {
    var PortalComponent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Portal;
    var Trigger2 = /* @__PURE__ */ React__namespace.forwardRef(function(props, ref) {
      var _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-trigger-popup" : _props$prefixCls, children = props.children, _props$action = props.action, action2 = _props$action === void 0 ? "hover" : _props$action, showAction = props.showAction, hideAction = props.hideAction, popupVisible = props.popupVisible, defaultPopupVisible = props.defaultPopupVisible, onPopupVisibleChange = props.onPopupVisibleChange, afterPopupVisibleChange = props.afterPopupVisibleChange, mouseEnterDelay = props.mouseEnterDelay, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, focusDelay = props.focusDelay, blurDelay = props.blurDelay, mask = props.mask, _props$maskClosable = props.maskClosable, maskClosable = _props$maskClosable === void 0 ? true : _props$maskClosable, getPopupContainer = props.getPopupContainer, forceRender = props.forceRender, autoDestroy = props.autoDestroy, destroyPopupOnHide = props.destroyPopupOnHide, popup = props.popup, popupClassName = props.popupClassName, popupStyle = props.popupStyle, popupPlacement = props.popupPlacement, _props$builtinPlaceme = props.builtinPlacements, builtinPlacements = _props$builtinPlaceme === void 0 ? {} : _props$builtinPlaceme, popupAlign = props.popupAlign, zIndex = props.zIndex, stretch = props.stretch, getPopupClassNameFromAlign = props.getPopupClassNameFromAlign, alignPoint = props.alignPoint, onPopupClick = props.onPopupClick, onPopupAlign = props.onPopupAlign, arrow = props.arrow, popupMotion = props.popupMotion, maskMotion = props.maskMotion, popupTransitionName = props.popupTransitionName, popupAnimation = props.popupAnimation, maskTransitionName = props.maskTransitionName, maskAnimation = props.maskAnimation, className = props.className, getTriggerDOMNode = props.getTriggerDOMNode, restProps = _objectWithoutProperties(props, _excluded$1);
      var mergedAutoDestroy = autoDestroy || destroyPopupOnHide || false;
      var _React$useState = React__namespace.useState(false), _React$useState2 = _slicedToArray(_React$useState, 2), mobile = _React$useState2[0], setMobile = _React$useState2[1];
      useLayoutEffect(function() {
        setMobile(isMobile());
      }, []);
      var subPopupElements = React__namespace.useRef({});
      var parentContext = React__namespace.useContext(TriggerContext);
      var context = React__namespace.useMemo(function() {
        return {
          registerSubPopup: function registerSubPopup(id3, subPopupEle) {
            subPopupElements.current[id3] = subPopupEle;
            parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id3, subPopupEle);
          }
        };
      }, [parentContext]);
      var id2 = useId();
      var _React$useState3 = React__namespace.useState(null), _React$useState4 = _slicedToArray(_React$useState3, 2), popupEle = _React$useState4[0], setPopupEle = _React$useState4[1];
      var setPopupRef = useEvent(function(node2) {
        if (isDOM(node2) && popupEle !== node2) {
          setPopupEle(node2);
        }
        parentContext === null || parentContext === void 0 ? void 0 : parentContext.registerSubPopup(id2, node2);
      });
      var _React$useState5 = React__namespace.useState(null), _React$useState6 = _slicedToArray(_React$useState5, 2), targetEle = _React$useState6[0], setTargetEle = _React$useState6[1];
      var setTargetRef = useEvent(function(node2) {
        if (isDOM(node2) && targetEle !== node2) {
          setTargetEle(node2);
        }
      });
      var child = React__namespace.Children.only(children);
      var originChildProps = (child === null || child === void 0 ? void 0 : child.props) || {};
      var cloneProps = {};
      var inPopupOrChild = useEvent(function(ele) {
        var _getShadowRoot, _getShadowRoot2;
        var childDOM = targetEle;
        return (childDOM === null || childDOM === void 0 ? void 0 : childDOM.contains(ele)) || ((_getShadowRoot = getShadowRoot(childDOM)) === null || _getShadowRoot === void 0 ? void 0 : _getShadowRoot.host) === ele || ele === childDOM || (popupEle === null || popupEle === void 0 ? void 0 : popupEle.contains(ele)) || ((_getShadowRoot2 = getShadowRoot(popupEle)) === null || _getShadowRoot2 === void 0 ? void 0 : _getShadowRoot2.host) === ele || ele === popupEle || Object.values(subPopupElements.current).some(function(subPopupEle) {
          return (subPopupEle === null || subPopupEle === void 0 ? void 0 : subPopupEle.contains(ele)) || ele === subPopupEle;
        });
      });
      var mergePopupMotion = getMotion(prefixCls, popupMotion, popupAnimation, popupTransitionName);
      var mergeMaskMotion = getMotion(prefixCls, maskMotion, maskAnimation, maskTransitionName);
      var _React$useState7 = React__namespace.useState(defaultPopupVisible || false), _React$useState8 = _slicedToArray(_React$useState7, 2), internalOpen = _React$useState8[0], setInternalOpen = _React$useState8[1];
      var mergedOpen = popupVisible !== null && popupVisible !== void 0 ? popupVisible : internalOpen;
      var setMergedOpen = useEvent(function(nextOpen) {
        if (popupVisible === void 0) {
          setInternalOpen(nextOpen);
        }
      });
      useLayoutEffect(function() {
        setInternalOpen(popupVisible || false);
      }, [popupVisible]);
      var openRef = React__namespace.useRef(mergedOpen);
      openRef.current = mergedOpen;
      var internalTriggerOpen = useEvent(function(nextOpen) {
        if (mergedOpen !== nextOpen) {
          setMergedOpen(nextOpen);
          onPopupVisibleChange === null || onPopupVisibleChange === void 0 ? void 0 : onPopupVisibleChange(nextOpen);
        }
      });
      var delayRef = React__namespace.useRef();
      var clearDelay = function clearDelay2() {
        clearTimeout(delayRef.current);
      };
      var triggerOpen = function triggerOpen2(nextOpen) {
        var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
        clearDelay();
        if (delay === 0) {
          internalTriggerOpen(nextOpen);
        } else {
          delayRef.current = setTimeout(function() {
            internalTriggerOpen(nextOpen);
          }, delay * 1e3);
        }
      };
      React__namespace.useEffect(function() {
        return clearDelay;
      }, []);
      var _React$useState9 = React__namespace.useState(false), _React$useState10 = _slicedToArray(_React$useState9, 2), inMotion = _React$useState10[0], setInMotion = _React$useState10[1];
      useLayoutEffect(function(firstMount) {
        if (!firstMount || mergedOpen) {
          setInMotion(true);
        }
      }, [mergedOpen]);
      var _React$useState11 = React__namespace.useState(null), _React$useState12 = _slicedToArray(_React$useState11, 2), motionPrepareResolve = _React$useState12[0], setMotionPrepareResolve = _React$useState12[1];
      var _React$useState13 = React__namespace.useState([0, 0]), _React$useState14 = _slicedToArray(_React$useState13, 2), mousePos = _React$useState14[0], setMousePos = _React$useState14[1];
      var setMousePosByEvent = function setMousePosByEvent2(event) {
        setMousePos([event.clientX, event.clientY]);
      };
      var _useAlign = useAlign(mergedOpen, popupEle, alignPoint ? mousePos : targetEle, popupPlacement, builtinPlacements, popupAlign, onPopupAlign), _useAlign2 = _slicedToArray(_useAlign, 11), ready = _useAlign2[0], offsetX = _useAlign2[1], offsetY = _useAlign2[2], offsetR = _useAlign2[3], offsetB = _useAlign2[4], arrowX = _useAlign2[5], arrowY = _useAlign2[6], scaleX = _useAlign2[7], scaleY = _useAlign2[8], alignInfo = _useAlign2[9], onAlign = _useAlign2[10];
      var triggerAlign = useEvent(function() {
        if (!inMotion) {
          onAlign();
        }
      });
      useWatch(mergedOpen, targetEle, popupEle, triggerAlign);
      useLayoutEffect(function() {
        triggerAlign();
      }, [mousePos, popupPlacement]);
      useLayoutEffect(function() {
        if (mergedOpen && !(builtinPlacements !== null && builtinPlacements !== void 0 && builtinPlacements[popupPlacement])) {
          triggerAlign();
        }
      }, [JSON.stringify(popupAlign)]);
      var alignedClassName = React__namespace.useMemo(function() {
        var baseClassName = getAlignPopupClassName(builtinPlacements, prefixCls, alignInfo, alignPoint);
        return classNames(baseClassName, getPopupClassNameFromAlign === null || getPopupClassNameFromAlign === void 0 ? void 0 : getPopupClassNameFromAlign(alignInfo));
      }, [alignInfo, getPopupClassNameFromAlign, builtinPlacements, prefixCls, alignPoint]);
      React__namespace.useImperativeHandle(ref, function() {
        return {
          forceAlign: triggerAlign
        };
      });
      var onVisibleChanged = function onVisibleChanged2(visible) {
        setInMotion(false);
        onAlign();
        afterPopupVisibleChange === null || afterPopupVisibleChange === void 0 ? void 0 : afterPopupVisibleChange(visible);
      };
      var onPrepare = function onPrepare2() {
        return new Promise(function(resolve) {
          setMotionPrepareResolve(function() {
            return resolve;
          });
        });
      };
      useLayoutEffect(function() {
        if (motionPrepareResolve) {
          onAlign();
          motionPrepareResolve();
          setMotionPrepareResolve(null);
        }
      }, [motionPrepareResolve]);
      var _React$useState15 = React__namespace.useState(0), _React$useState16 = _slicedToArray(_React$useState15, 2), targetWidth = _React$useState16[0], setTargetWidth = _React$useState16[1];
      var _React$useState17 = React__namespace.useState(0), _React$useState18 = _slicedToArray(_React$useState17, 2), targetHeight = _React$useState18[0], setTargetHeight = _React$useState18[1];
      var onTargetResize = function onTargetResize2(_2, ele) {
        triggerAlign();
        if (stretch) {
          var rect = ele.getBoundingClientRect();
          setTargetWidth(rect.width);
          setTargetHeight(rect.height);
        }
      };
      var _useAction = useAction(mobile, action2, showAction, hideAction), _useAction2 = _slicedToArray(_useAction, 2), showActions = _useAction2[0], hideActions = _useAction2[1];
      var wrapperAction = function wrapperAction2(eventName, nextOpen, delay, preEvent) {
        cloneProps[eventName] = function(event) {
          var _originChildProps$eve;
          preEvent === null || preEvent === void 0 ? void 0 : preEvent(event);
          triggerOpen(nextOpen, delay);
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }
          (_originChildProps$eve = originChildProps[eventName]) === null || _originChildProps$eve === void 0 ? void 0 : _originChildProps$eve.call.apply(_originChildProps$eve, [originChildProps, event].concat(args));
        };
      };
      var clickToShow = showActions.has("click");
      var clickToHide = hideActions.has("click") || hideActions.has("contextMenu");
      if (clickToShow || clickToHide) {
        cloneProps.onClick = function(event) {
          var _originChildProps$onC;
          if (openRef.current && clickToHide) {
            triggerOpen(false);
          } else if (!openRef.current && clickToShow) {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
            args[_key2 - 1] = arguments[_key2];
          }
          (_originChildProps$onC = originChildProps.onClick) === null || _originChildProps$onC === void 0 ? void 0 : _originChildProps$onC.call.apply(_originChildProps$onC, [originChildProps, event].concat(args));
        };
      }
      useWinClick(mergedOpen, clickToHide, targetEle, popupEle, mask, maskClosable, inPopupOrChild, triggerOpen);
      var hoverToShow = showActions.has("hover");
      var hoverToHide = hideActions.has("hover");
      var onPopupMouseEnter;
      var onPopupMouseLeave;
      if (hoverToShow) {
        wrapperAction("onMouseEnter", true, mouseEnterDelay, function(event) {
          setMousePosByEvent(event);
        });
        onPopupMouseEnter = function onPopupMouseEnter2() {
          triggerOpen(true, mouseEnterDelay);
        };
        if (alignPoint) {
          cloneProps.onMouseMove = function(event) {
            var _originChildProps$onM;
            (_originChildProps$onM = originChildProps.onMouseMove) === null || _originChildProps$onM === void 0 ? void 0 : _originChildProps$onM.call(originChildProps, event);
          };
        }
      }
      if (hoverToHide) {
        wrapperAction("onMouseLeave", false, mouseLeaveDelay);
        onPopupMouseLeave = function onPopupMouseLeave2() {
          triggerOpen(false, mouseLeaveDelay);
        };
      }
      if (showActions.has("focus")) {
        wrapperAction("onFocus", true, focusDelay);
      }
      if (hideActions.has("focus")) {
        wrapperAction("onBlur", false, blurDelay);
      }
      if (showActions.has("contextMenu")) {
        cloneProps.onContextMenu = function(event) {
          var _originChildProps$onC2;
          if (openRef.current && hideActions.has("contextMenu")) {
            triggerOpen(false);
          } else {
            setMousePosByEvent(event);
            triggerOpen(true);
          }
          event.preventDefault();
          for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
            args[_key3 - 1] = arguments[_key3];
          }
          (_originChildProps$onC2 = originChildProps.onContextMenu) === null || _originChildProps$onC2 === void 0 ? void 0 : _originChildProps$onC2.call.apply(_originChildProps$onC2, [originChildProps, event].concat(args));
        };
      }
      if (className) {
        cloneProps.className = classNames(originChildProps.className, className);
      }
      var mergedChildrenProps = _objectSpread2(_objectSpread2({}, originChildProps), cloneProps);
      var passedProps = {};
      var passedEventList = ["onContextMenu", "onClick", "onMouseDown", "onTouchStart", "onMouseEnter", "onMouseLeave", "onFocus", "onBlur"];
      passedEventList.forEach(function(eventName) {
        if (restProps[eventName]) {
          passedProps[eventName] = function() {
            var _mergedChildrenProps$;
            for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }
            (_mergedChildrenProps$ = mergedChildrenProps[eventName]) === null || _mergedChildrenProps$ === void 0 ? void 0 : _mergedChildrenProps$.call.apply(_mergedChildrenProps$, [mergedChildrenProps].concat(args));
            restProps[eventName].apply(restProps, args);
          };
        }
      });
      var triggerNode = /* @__PURE__ */ React__namespace.cloneElement(child, _objectSpread2(_objectSpread2({}, mergedChildrenProps), passedProps));
      var arrowPos = {
        x: arrowX,
        y: arrowY
      };
      var innerArrow = arrow ? _objectSpread2({}, arrow !== true ? arrow : {}) : null;
      return /* @__PURE__ */ React__namespace.createElement(React__namespace.Fragment, null, /* @__PURE__ */ React__namespace.createElement(RefResizeObserver, {
        disabled: !mergedOpen,
        ref: setTargetRef,
        onResize: onTargetResize
      }, /* @__PURE__ */ React__namespace.createElement(TriggerWrapper, {
        getTriggerDOMNode
      }, triggerNode)), /* @__PURE__ */ React__namespace.createElement(TriggerContext.Provider, {
        value: context
      }, /* @__PURE__ */ React__namespace.createElement(Popup$1, {
        portal: PortalComponent,
        ref: setPopupRef,
        prefixCls,
        popup,
        className: classNames(popupClassName, alignedClassName),
        style: popupStyle,
        target: targetEle,
        onMouseEnter: onPopupMouseEnter,
        onMouseLeave: onPopupMouseLeave,
        zIndex,
        open: mergedOpen,
        keepDom: inMotion,
        onClick: onPopupClick,
        mask,
        motion: mergePopupMotion,
        maskMotion: mergeMaskMotion,
        onVisibleChanged,
        onPrepare,
        forceRender,
        autoDestroy: mergedAutoDestroy,
        getPopupContainer,
        align: alignInfo,
        arrow: innerArrow,
        arrowPos,
        ready,
        offsetX,
        offsetY,
        offsetR,
        offsetB,
        onAlign: triggerAlign,
        stretch,
        targetWidth: targetWidth / scaleX,
        targetHeight: targetHeight / scaleY
      })));
    });
    return Trigger2;
  }
  const Trigger = generateTrigger(Portal);
  const Empty$2 = () => {
    const [, token2] = useToken$2();
    const bgColor = new TinyColor(token2.colorBgBase);
    const themeStyle = bgColor.toHsl().l < 0.5 ? {
      opacity: 0.65
    } : {};
    return /* @__PURE__ */ React__namespace.createElement("svg", {
      style: themeStyle,
      width: "184",
      height: "152",
      viewBox: "0 0 184 152",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(24 31.67)"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      fillOpacity: ".8",
      fill: "#F5F5F7",
      cx: "67.797",
      cy: "106.89",
      rx: "67.797",
      ry: "12.668"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M122.034 69.674L98.109 40.229c-1.148-1.386-2.826-2.225-4.593-2.225h-51.44c-1.766 0-3.444.839-4.592 2.225L13.56 69.674v15.383h108.475V69.674z",
      fill: "#AEB8C2"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M101.537 86.214L80.63 61.102c-1.001-1.207-2.507-1.867-4.048-1.867H31.724c-1.54 0-3.047.66-4.048 1.867L6.769 86.214v13.792h94.768V86.214z",
      fill: "url(#linearGradient-1)",
      transform: "translate(13.56)"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M33.83 0h67.933a4 4 0 0 1 4 4v93.344a4 4 0 0 1-4 4H33.83a4 4 0 0 1-4-4V4a4 4 0 0 1 4-4z",
      fill: "#F5F5F7"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M42.678 9.953h50.237a2 2 0 0 1 2 2V36.91a2 2 0 0 1-2 2H42.678a2 2 0 0 1-2-2V11.953a2 2 0 0 1 2-2zM42.94 49.767h49.713a2.262 2.262 0 1 1 0 4.524H42.94a2.262 2.262 0 0 1 0-4.524zM42.94 61.53h49.713a2.262 2.262 0 1 1 0 4.525H42.94a2.262 2.262 0 0 1 0-4.525zM121.813 105.032c-.775 3.071-3.497 5.36-6.735 5.36H20.515c-3.238 0-5.96-2.29-6.734-5.36a7.309 7.309 0 0 1-.222-1.79V69.675h26.318c2.907 0 5.25 2.448 5.25 5.42v.04c0 2.971 2.37 5.37 5.277 5.37h34.785c2.907 0 5.277-2.421 5.277-5.393V75.1c0-2.972 2.343-5.426 5.25-5.426h26.318v33.569c0 .617-.077 1.216-.221 1.789z",
      fill: "#DCE0E6"
    })), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M149.121 33.292l-6.83 2.65a1 1 0 0 1-1.317-1.23l1.937-6.207c-2.589-2.944-4.109-6.534-4.109-10.408C138.802 8.102 148.92 0 161.402 0 173.881 0 184 8.102 184 18.097c0 9.995-10.118 18.097-22.599 18.097-4.528 0-8.744-1.066-12.28-2.902z",
      fill: "#DCE0E6"
    }), /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(149.65 15.383)",
      fill: "#FFF"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      cx: "20.654",
      cy: "3.167",
      rx: "2.849",
      ry: "2.815"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M5.698 5.63H0L2.898.704zM9.259.704h4.985V5.63H9.259z"
    }))));
  };
  const DefaultEmptyImg = Empty$2;
  const Simple = () => {
    const [, token2] = useToken$2();
    const {
      colorFill,
      colorFillTertiary,
      colorFillQuaternary,
      colorBgContainer
    } = token2;
    const {
      borderColor,
      shadowColor,
      contentColor
    } = React.useMemo(() => ({
      borderColor: new TinyColor(colorFill).onBackground(colorBgContainer).toHexShortString(),
      shadowColor: new TinyColor(colorFillTertiary).onBackground(colorBgContainer).toHexShortString(),
      contentColor: new TinyColor(colorFillQuaternary).onBackground(colorBgContainer).toHexShortString()
    }), [colorFill, colorFillTertiary, colorFillQuaternary, colorBgContainer]);
    return /* @__PURE__ */ React__namespace.createElement("svg", {
      width: "64",
      height: "41",
      viewBox: "0 0 64 41",
      xmlns: "http://www.w3.org/2000/svg"
    }, /* @__PURE__ */ React__namespace.createElement("g", {
      transform: "translate(0 1)",
      fill: "none",
      fillRule: "evenodd"
    }, /* @__PURE__ */ React__namespace.createElement("ellipse", {
      fill: shadowColor,
      cx: "32",
      cy: "33",
      rx: "32",
      ry: "7"
    }), /* @__PURE__ */ React__namespace.createElement("g", {
      fillRule: "nonzero",
      stroke: borderColor
    }, /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M55 12.76L44.854 1.258C44.367.474 43.656 0 42.907 0H21.093c-.749 0-1.46.474-1.947 1.257L9 12.761V22h46v-9.24z"
    }), /* @__PURE__ */ React__namespace.createElement("path", {
      d: "M41.613 15.931c0-1.605.994-2.93 2.227-2.931H55v18.137C55 33.26 53.68 35 52.05 35h-40.1C10.32 35 9 33.259 9 31.137V13h11.16c1.233 0 2.227 1.323 2.227 2.928v.022c0 1.605 1.005 2.901 2.237 2.901h14.752c1.232 0 2.237-1.308 2.237-2.913v-.007z",
      fill: contentColor
    }))));
  };
  const SimpleEmptyImg = Simple;
  const genSharedEmptyStyle = (token2) => {
    const {
      componentCls,
      margin,
      marginXS,
      marginXL,
      fontSize,
      lineHeight
    } = token2;
    return {
      [componentCls]: {
        marginInline: marginXS,
        fontSize,
        lineHeight,
        textAlign: "center",
        // 原来 &-image 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-image`]: {
          height: token2.emptyImgHeight,
          marginBottom: marginXS,
          opacity: token2.opacityImage,
          img: {
            height: "100%"
          },
          svg: {
            maxWidth: "100%",
            height: "100%",
            margin: "auto"
          }
        },
        [`${componentCls}-description`]: {
          color: token2.colorText
        },
        // 原来 &-footer 没有父子结构，现在为了外层承担我们的hashId，改成父子结果
        [`${componentCls}-footer`]: {
          marginTop: margin
        },
        "&-normal": {
          marginBlock: marginXL,
          color: token2.colorTextDisabled,
          [`${componentCls}-description`]: {
            color: token2.colorTextDisabled
          },
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightMD
          }
        },
        "&-small": {
          marginBlock: marginXS,
          color: token2.colorTextDisabled,
          [`${componentCls}-image`]: {
            height: token2.emptyImgHeightSM
          }
        }
      }
    };
  };
  const useStyle$4 = genComponentStyleHook("Empty", (token2) => {
    const {
      componentCls,
      controlHeightLG
    } = token2;
    const emptyToken = merge$1(token2, {
      emptyImgCls: `${componentCls}-img`,
      emptyImgHeight: controlHeightLG * 2.5,
      emptyImgHeightMD: controlHeightLG,
      emptyImgHeightSM: controlHeightLG * 0.875
    });
    return [genSharedEmptyStyle(emptyToken)];
  });
  var __rest$7 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const defaultEmptyImg = /* @__PURE__ */ React__namespace.createElement(DefaultEmptyImg, null);
  const simpleEmptyImg = /* @__PURE__ */ React__namespace.createElement(SimpleEmptyImg, null);
  const Empty = (_a2) => {
    var {
      className,
      rootClassName,
      prefixCls: customizePrefixCls,
      image = defaultEmptyImg,
      description,
      children,
      imageStyle
    } = _a2, restProps = __rest$7(_a2, ["className", "rootClassName", "prefixCls", "image", "description", "children", "imageStyle"]);
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("empty", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$4(prefixCls);
    const [locale2] = useLocale$1("Empty");
    const des = typeof description !== "undefined" ? description : locale2 === null || locale2 === void 0 ? void 0 : locale2.description;
    const alt = typeof des === "string" ? des : "empty";
    let imageNode = null;
    if (typeof image === "string") {
      imageNode = /* @__PURE__ */ React__namespace.createElement("img", {
        alt,
        src: image
      });
    } else {
      imageNode = image;
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", Object.assign({
      className: classNames(hashId, prefixCls, {
        [`${prefixCls}-normal`]: image === simpleEmptyImg,
        [`${prefixCls}-rtl`]: direction === "rtl"
      }, className, rootClassName)
    }, restProps), /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-image`,
      style: imageStyle
    }, imageNode), des && /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-description`
    }, des), children && /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-footer`
    }, children)));
  };
  Empty.PRESENTED_IMAGE_DEFAULT = defaultEmptyImg;
  Empty.PRESENTED_IMAGE_SIMPLE = simpleEmptyImg;
  const Empty$1 = Empty;
  var autoAdjustOverflowTopBottom = {
    shiftX: 64,
    adjustY: 1
  };
  var autoAdjustOverflowLeftRight = {
    adjustX: 1,
    shiftY: true
  };
  var targetOffset = [0, 0];
  var placements = {
    left: {
      points: ["cr", "cl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    },
    right: {
      points: ["cl", "cr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    top: {
      points: ["bc", "tc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    bottom: {
      points: ["tc", "bc"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    topLeft: {
      points: ["bl", "tl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    leftTop: {
      points: ["tr", "tl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    },
    topRight: {
      points: ["br", "tr"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, -4],
      targetOffset
    },
    rightTop: {
      points: ["tl", "tr"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    bottomRight: {
      points: ["tr", "br"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    rightBottom: {
      points: ["bl", "br"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [4, 0],
      targetOffset
    },
    bottomLeft: {
      points: ["tl", "bl"],
      overflow: autoAdjustOverflowTopBottom,
      offset: [0, 4],
      targetOffset
    },
    leftBottom: {
      points: ["br", "bl"],
      overflow: autoAdjustOverflowLeftRight,
      offset: [-4, 0],
      targetOffset
    }
  };
  function Popup(props) {
    var children = props.children, prefixCls = props.prefixCls, id2 = props.id, overlayInnerStyle = props.overlayInnerStyle, className = props.className, style2 = props.style;
    return /* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames("".concat(prefixCls, "-content"), className),
      style: style2
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: "".concat(prefixCls, "-inner"),
      id: id2,
      role: "tooltip",
      style: overlayInnerStyle
    }, typeof children === "function" ? children() : children));
  }
  var _excluded = ["overlayClassName", "trigger", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "prefixCls", "children", "onVisibleChange", "afterVisibleChange", "transitionName", "animation", "motion", "placement", "align", "destroyTooltipOnHide", "defaultVisible", "getTooltipContainer", "overlayInnerStyle", "arrowContent", "overlay", "id", "showArrow"];
  var Tooltip$2 = function Tooltip(props, ref) {
    var overlayClassName = props.overlayClassName, _props$trigger = props.trigger, trigger = _props$trigger === void 0 ? ["hover"] : _props$trigger, _props$mouseEnterDela = props.mouseEnterDelay, mouseEnterDelay = _props$mouseEnterDela === void 0 ? 0 : _props$mouseEnterDela, _props$mouseLeaveDela = props.mouseLeaveDelay, mouseLeaveDelay = _props$mouseLeaveDela === void 0 ? 0.1 : _props$mouseLeaveDela, overlayStyle = props.overlayStyle, _props$prefixCls = props.prefixCls, prefixCls = _props$prefixCls === void 0 ? "rc-tooltip" : _props$prefixCls, children = props.children, onVisibleChange = props.onVisibleChange, afterVisibleChange = props.afterVisibleChange, transitionName = props.transitionName, animation = props.animation, motion = props.motion, _props$placement = props.placement, placement = _props$placement === void 0 ? "right" : _props$placement, _props$align = props.align, align = _props$align === void 0 ? {} : _props$align, _props$destroyTooltip = props.destroyTooltipOnHide, destroyTooltipOnHide = _props$destroyTooltip === void 0 ? false : _props$destroyTooltip, defaultVisible = props.defaultVisible, getTooltipContainer = props.getTooltipContainer, overlayInnerStyle = props.overlayInnerStyle;
    props.arrowContent;
    var overlay = props.overlay, id2 = props.id, _props$showArrow = props.showArrow, showArrow = _props$showArrow === void 0 ? true : _props$showArrow, restProps = _objectWithoutProperties(props, _excluded);
    var triggerRef = React.useRef(null);
    React.useImperativeHandle(ref, function() {
      return triggerRef.current;
    });
    var extraProps = _objectSpread2({}, restProps);
    if ("visible" in props) {
      extraProps.popupVisible = props.visible;
    }
    var getPopupElement = function getPopupElement2() {
      return /* @__PURE__ */ React__namespace.createElement(Popup, {
        key: "content",
        prefixCls,
        id: id2,
        overlayInnerStyle
      }, overlay);
    };
    return /* @__PURE__ */ React__namespace.createElement(Trigger, _extends$2({
      popupClassName: overlayClassName,
      prefixCls,
      popup: getPopupElement,
      action: trigger,
      builtinPlacements: placements,
      popupPlacement: placement,
      ref: triggerRef,
      popupAlign: align,
      getPopupContainer: getTooltipContainer,
      onPopupVisibleChange: onVisibleChange,
      afterPopupVisibleChange: afterVisibleChange,
      popupTransitionName: transitionName,
      popupAnimation: animation,
      popupMotion: motion,
      defaultPopupVisible: defaultVisible,
      autoDestroy: destroyTooltipOnHide,
      mouseLeaveDelay,
      popupStyle: overlayStyle,
      mouseEnterDelay,
      arrow: showArrow
    }, extraProps), children);
  };
  const Tooltip$3 = /* @__PURE__ */ React.forwardRef(Tooltip$2);
  const MAX_VERTICAL_CONTENT_RADIUS = 8;
  function getArrowOffset(options) {
    const maxVerticalContentRadius = MAX_VERTICAL_CONTENT_RADIUS;
    const {
      contentRadius,
      limitVerticalRadius
    } = options;
    const dropdownArrowOffset = contentRadius > 12 ? contentRadius + 2 : 12;
    const dropdownArrowOffsetVertical = limitVerticalRadius ? maxVerticalContentRadius : dropdownArrowOffset;
    return {
      dropdownArrowOffset,
      dropdownArrowOffsetVertical
    };
  }
  function isInject(valid, code) {
    if (!valid)
      return {};
    return code;
  }
  function getArrowStyle(token2, options) {
    const {
      componentCls,
      sizePopupArrow,
      borderRadiusXS,
      borderRadiusOuter,
      boxShadowPopoverArrow
    } = token2;
    const {
      colorBg,
      contentRadius = token2.borderRadiusLG,
      limitVerticalRadius,
      arrowDistance = 0,
      arrowPlacement = {
        left: true,
        right: true,
        top: true,
        bottom: true
      }
    } = options;
    const {
      dropdownArrowOffsetVertical,
      dropdownArrowOffset
    } = getArrowOffset({
      contentRadius,
      limitVerticalRadius
    });
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({
        // ============================ Basic ============================
        [`${componentCls}-arrow`]: [Object.assign(Object.assign({
          position: "absolute",
          zIndex: 1,
          display: "block"
        }, roundedArrow(sizePopupArrow, borderRadiusXS, borderRadiusOuter, colorBg, boxShadowPopoverArrow)), {
          "&:before": {
            background: colorBg
          }
        })]
      }, isInject(!!arrowPlacement.top, {
        [[`&-placement-top ${componentCls}-arrow`, `&-placement-topLeft ${componentCls}-arrow`, `&-placement-topRight ${componentCls}-arrow`].join(",")]: {
          bottom: arrowDistance,
          transform: "translateY(100%) rotate(180deg)"
        },
        [`&-placement-top ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateX(-50%) translateY(100%) rotate(180deg)"
        },
        [`&-placement-topLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-topRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        }
      })), isInject(!!arrowPlacement.bottom, {
        [[`&-placement-bottom ${componentCls}-arrow`, `&-placement-bottomLeft ${componentCls}-arrow`, `&-placement-bottomRight ${componentCls}-arrow`].join(",")]: {
          top: arrowDistance,
          transform: `translateY(-100%)`
        },
        [`&-placement-bottom ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: "50%"
          },
          transform: `translateX(-50%) translateY(-100%)`
        },
        [`&-placement-bottomLeft ${componentCls}-arrow`]: {
          left: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        },
        [`&-placement-bottomRight ${componentCls}-arrow`]: {
          right: {
            _skip_check_: true,
            value: dropdownArrowOffset
          }
        }
      })), isInject(!!arrowPlacement.left, {
        [[`&-placement-left ${componentCls}-arrow`, `&-placement-leftTop ${componentCls}-arrow`, `&-placement-leftBottom ${componentCls}-arrow`].join(",")]: {
          right: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(100%) rotate(90deg)"
        },
        [`&-placement-left ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(100%) rotate(90deg)"
        },
        [`&-placement-leftTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-leftBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        }
      })), isInject(!!arrowPlacement.right, {
        [[`&-placement-right ${componentCls}-arrow`, `&-placement-rightTop ${componentCls}-arrow`, `&-placement-rightBottom ${componentCls}-arrow`].join(",")]: {
          left: {
            _skip_check_: true,
            value: arrowDistance
          },
          transform: "translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-right ${componentCls}-arrow`]: {
          top: {
            _skip_check_: true,
            value: "50%"
          },
          transform: "translateY(-50%) translateX(-100%) rotate(-90deg)"
        },
        [`&-placement-rightTop ${componentCls}-arrow`]: {
          top: dropdownArrowOffsetVertical
        },
        [`&-placement-rightBottom ${componentCls}-arrow`]: {
          bottom: dropdownArrowOffsetVertical
        }
      }))
    };
  }
  function getOverflowOptions(placement, arrowOffset, arrowWidth, autoAdjustOverflow) {
    if (autoAdjustOverflow === false) {
      return {
        adjustX: false,
        adjustY: false
      };
    }
    const overflow = autoAdjustOverflow && typeof autoAdjustOverflow === "object" ? autoAdjustOverflow : {};
    const baseOverflow = {};
    switch (placement) {
      case "top":
      case "bottom":
        baseOverflow.shiftX = arrowOffset.dropdownArrowOffset * 2 + arrowWidth;
        break;
      case "left":
      case "right":
        baseOverflow.shiftY = arrowOffset.dropdownArrowOffsetVertical * 2 + arrowWidth;
        break;
    }
    const mergedOverflow = Object.assign(Object.assign({}, baseOverflow), overflow);
    if (!mergedOverflow.shiftX) {
      mergedOverflow.adjustX = true;
    }
    if (!mergedOverflow.shiftY) {
      mergedOverflow.adjustY = true;
    }
    return mergedOverflow;
  }
  const PlacementAlignMap = {
    left: {
      points: ["cr", "cl"]
    },
    right: {
      points: ["cl", "cr"]
    },
    top: {
      points: ["bc", "tc"]
    },
    bottom: {
      points: ["tc", "bc"]
    },
    topLeft: {
      points: ["bl", "tl"]
    },
    leftTop: {
      points: ["tr", "tl"]
    },
    topRight: {
      points: ["br", "tr"]
    },
    rightTop: {
      points: ["tl", "tr"]
    },
    bottomRight: {
      points: ["tr", "br"]
    },
    rightBottom: {
      points: ["bl", "br"]
    },
    bottomLeft: {
      points: ["tl", "bl"]
    },
    leftBottom: {
      points: ["br", "bl"]
    }
  };
  const ArrowCenterPlacementAlignMap = {
    topLeft: {
      points: ["bl", "tc"]
    },
    leftTop: {
      points: ["tr", "cl"]
    },
    topRight: {
      points: ["br", "tc"]
    },
    rightTop: {
      points: ["tl", "cr"]
    },
    bottomRight: {
      points: ["tr", "bc"]
    },
    rightBottom: {
      points: ["bl", "cr"]
    },
    bottomLeft: {
      points: ["tl", "bc"]
    },
    leftBottom: {
      points: ["br", "cl"]
    }
  };
  const DisableAutoArrowList = /* @__PURE__ */ new Set(["topLeft", "topRight", "bottomLeft", "bottomRight", "leftTop", "leftBottom", "rightTop", "rightBottom"]);
  function getPlacements(config) {
    const {
      arrowWidth,
      autoAdjustOverflow,
      arrowPointAtCenter,
      offset: offset2,
      borderRadius,
      visibleFirst
    } = config;
    const halfArrowWidth = arrowWidth / 2;
    const placementMap = {};
    Object.keys(PlacementAlignMap).forEach((key) => {
      const template = arrowPointAtCenter && ArrowCenterPlacementAlignMap[key] || PlacementAlignMap[key];
      const placementInfo = Object.assign(Object.assign({}, template), {
        offset: [0, 0]
      });
      placementMap[key] = placementInfo;
      if (DisableAutoArrowList.has(key)) {
        placementInfo.autoArrow = false;
      }
      switch (key) {
        case "top":
        case "topLeft":
        case "topRight":
          placementInfo.offset[1] = -halfArrowWidth - offset2;
          break;
        case "bottom":
        case "bottomLeft":
        case "bottomRight":
          placementInfo.offset[1] = halfArrowWidth + offset2;
          break;
        case "left":
        case "leftTop":
        case "leftBottom":
          placementInfo.offset[0] = -halfArrowWidth - offset2;
          break;
        case "right":
        case "rightTop":
        case "rightBottom":
          placementInfo.offset[0] = halfArrowWidth + offset2;
          break;
      }
      const arrowOffset = getArrowOffset({
        contentRadius: borderRadius,
        limitVerticalRadius: true
      });
      if (arrowPointAtCenter) {
        switch (key) {
          case "topLeft":
          case "bottomLeft":
            placementInfo.offset[0] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
            break;
          case "topRight":
          case "bottomRight":
            placementInfo.offset[0] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
            break;
          case "leftTop":
          case "rightTop":
            placementInfo.offset[1] = -arrowOffset.dropdownArrowOffset - halfArrowWidth;
            break;
          case "leftBottom":
          case "rightBottom":
            placementInfo.offset[1] = arrowOffset.dropdownArrowOffset + halfArrowWidth;
            break;
        }
      }
      placementInfo.overflow = getOverflowOptions(key, arrowOffset, arrowWidth, autoAdjustOverflow);
      if (visibleFirst) {
        placementInfo.htmlRegion = "visibleFirst";
      }
    });
    return placementMap;
  }
  const getDesignToken = (config) => {
    const theme2 = (config === null || config === void 0 ? void 0 : config.algorithm) ? createTheme(config.algorithm) : createTheme(derivative$2);
    const mergedToken = Object.assign(Object.assign({}, seedToken$1), config === null || config === void 0 ? void 0 : config.token);
    return getComputedToken(mergedToken, {
      override: config === null || config === void 0 ? void 0 : config.token
    }, theme2, formatToken);
  };
  const getDesignToken$1 = getDesignToken;
  function genSizeMapToken(token2) {
    const {
      sizeUnit,
      sizeStep
    } = token2;
    const compactSizeStep = sizeStep - 2;
    return {
      sizeXXL: sizeUnit * (compactSizeStep + 10),
      sizeXL: sizeUnit * (compactSizeStep + 6),
      sizeLG: sizeUnit * (compactSizeStep + 2),
      sizeMD: sizeUnit * (compactSizeStep + 2),
      sizeMS: sizeUnit * (compactSizeStep + 1),
      size: sizeUnit * compactSizeStep,
      sizeSM: sizeUnit * compactSizeStep,
      sizeXS: sizeUnit * (compactSizeStep - 1),
      sizeXXS: sizeUnit * (compactSizeStep - 1)
    };
  }
  const derivative$1 = (token2, mapToken) => {
    const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
    const fontSize = mergedMapToken.fontSizeSM;
    const controlHeight = mergedMapToken.controlHeight - 4;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, mergedMapToken), genSizeMapToken(mapToken !== null && mapToken !== void 0 ? mapToken : token2)), genFontMapToken$1(fontSize)), {
      // controlHeight
      controlHeight
    }), genControlHeight$1(Object.assign(Object.assign({}, mergedMapToken), {
      controlHeight
    })));
  };
  const compactAlgorithm = derivative$1;
  const getAlphaColor = (baseColor, alpha) => new TinyColor(baseColor).setAlpha(alpha).toRgbString();
  const getSolidColor = (baseColor, brightness) => {
    const instance = new TinyColor(baseColor);
    return instance.lighten(brightness).toHexString();
  };
  const generateColorPalettes = (baseColor) => {
    const colors = generate$1(baseColor, {
      theme: "dark"
    });
    return {
      1: colors[0],
      2: colors[1],
      3: colors[2],
      4: colors[3],
      5: colors[6],
      6: colors[5],
      7: colors[4],
      8: colors[6],
      9: colors[5],
      10: colors[4]
      // 8: colors[9],
      // 9: colors[8],
      // 10: colors[7],
    };
  };
  const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
    const colorBgBase = bgBaseColor || "#000";
    const colorTextBase = textBaseColor || "#fff";
    return {
      colorBgBase,
      colorTextBase,
      colorText: getAlphaColor(colorTextBase, 0.85),
      colorTextSecondary: getAlphaColor(colorTextBase, 0.65),
      colorTextTertiary: getAlphaColor(colorTextBase, 0.45),
      colorTextQuaternary: getAlphaColor(colorTextBase, 0.25),
      colorFill: getAlphaColor(colorTextBase, 0.18),
      colorFillSecondary: getAlphaColor(colorTextBase, 0.12),
      colorFillTertiary: getAlphaColor(colorTextBase, 0.08),
      colorFillQuaternary: getAlphaColor(colorTextBase, 0.04),
      colorBgElevated: getSolidColor(colorBgBase, 12),
      colorBgContainer: getSolidColor(colorBgBase, 8),
      colorBgLayout: getSolidColor(colorBgBase, 0),
      colorBgSpotlight: getSolidColor(colorBgBase, 26),
      colorBorder: getSolidColor(colorBgBase, 26),
      colorBorderSecondary: getSolidColor(colorBgBase, 19)
    };
  };
  const derivative = (token2, mapToken) => {
    const colorPalettes = Object.keys(defaultPresetColors).map((colorKey) => {
      const colors = generate$1(token2[colorKey], {
        theme: "dark"
      });
      return new Array(10).fill(1).reduce((prev2, _2, i) => {
        prev2[`${colorKey}-${i + 1}`] = colors[i];
        prev2[`${colorKey}${i + 1}`] = colors[i];
        return prev2;
      }, {});
    }).reduce((prev2, cur) => {
      prev2 = Object.assign(Object.assign({}, prev2), cur);
      return prev2;
    }, {});
    const mergedMapToken = mapToken !== null && mapToken !== void 0 ? mapToken : derivative$2(token2);
    return Object.assign(Object.assign(Object.assign({}, mergedMapToken), colorPalettes), genColorMapToken(token2, {
      generateColorPalettes,
      generateNeutralColorPalettes
    }));
  };
  const darkAlgorithm = derivative;
  function useToken$1() {
    const [theme2, token2, hashId] = useToken$2();
    return {
      theme: theme2,
      token: token2,
      hashId
    };
  }
  const theme = {
    /** @private Test Usage. Do not use in production. */
    defaultConfig,
    /** Default seedToken */
    defaultSeed: defaultConfig.token,
    useToken: useToken$1,
    defaultAlgorithm: derivative$2,
    darkAlgorithm,
    compactAlgorithm,
    getDesignToken: getDesignToken$1
  };
  const genTooltipStyle = (token2) => {
    const {
      componentCls,
      // ant-tooltip
      tooltipMaxWidth,
      tooltipColor,
      tooltipBg,
      tooltipBorderRadius,
      zIndexPopup,
      controlHeight,
      boxShadowSecondary,
      paddingSM,
      paddingXS,
      tooltipRadiusOuter
    } = token2;
    return [
      {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
          position: "absolute",
          zIndex: zIndexPopup,
          display: "block",
          width: "max-content",
          maxWidth: tooltipMaxWidth,
          visibility: "visible",
          transformOrigin: `var(--arrow-x, 50%) var(--arrow-y, 50%)`,
          "&-hidden": {
            display: "none"
          },
          "--antd-arrow-background-color": tooltipBg,
          // Wrapper for the tooltip content
          [`${componentCls}-inner`]: {
            minWidth: controlHeight,
            minHeight: controlHeight,
            padding: `${paddingSM / 2}px ${paddingXS}px`,
            color: tooltipColor,
            textAlign: "start",
            textDecoration: "none",
            wordWrap: "break-word",
            backgroundColor: tooltipBg,
            borderRadius: tooltipBorderRadius,
            boxShadow: boxShadowSecondary,
            boxSizing: "border-box"
          },
          // Limit left and right placement radius
          [[`&-placement-left`, `&-placement-leftTop`, `&-placement-leftBottom`, `&-placement-right`, `&-placement-rightTop`, `&-placement-rightBottom`].join(",")]: {
            [`${componentCls}-inner`]: {
              borderRadius: Math.min(tooltipBorderRadius, MAX_VERTICAL_CONTENT_RADIUS)
            }
          },
          [`${componentCls}-content`]: {
            position: "relative"
          }
        }), genPresetColor(token2, (colorKey, _ref) => {
          let {
            darkColor
          } = _ref;
          return {
            [`&${componentCls}-${colorKey}`]: {
              [`${componentCls}-inner`]: {
                backgroundColor: darkColor
              },
              [`${componentCls}-arrow`]: {
                "--antd-arrow-background-color": darkColor
              }
            }
          };
        })), {
          // RTL
          "&-rtl": {
            direction: "rtl"
          }
        })
      },
      // Arrow Style
      getArrowStyle(merge$1(token2, {
        borderRadiusOuter: tooltipRadiusOuter
      }), {
        colorBg: "var(--antd-arrow-background-color)",
        contentRadius: tooltipBorderRadius,
        limitVerticalRadius: true
      }),
      // Pure Render
      {
        [`${componentCls}-pure`]: {
          position: "relative",
          maxWidth: "none",
          margin: token2.sizePopupArrow
        }
      }
    ];
  };
  const useStyle$3 = (prefixCls, injectStyle) => {
    const useOriginHook = genComponentStyleHook("Tooltip", (token2) => {
      if (injectStyle === false) {
        return [];
      }
      const {
        borderRadius,
        colorTextLightSolid,
        colorBgDefault,
        borderRadiusOuter
      } = token2;
      const TooltipToken = merge$1(token2, {
        // default variables
        tooltipMaxWidth: 250,
        tooltipColor: colorTextLightSolid,
        tooltipBorderRadius: borderRadius,
        tooltipBg: colorBgDefault,
        tooltipRadiusOuter: borderRadiusOuter > 4 ? 4 : borderRadiusOuter
      });
      return [genTooltipStyle(TooltipToken), initZoomMotion(token2, "zoom-big-fast")];
    }, (_ref2) => {
      let {
        zIndexPopupBase,
        colorBgSpotlight
      } = _ref2;
      return {
        zIndexPopup: zIndexPopupBase + 70,
        colorBgDefault: colorBgSpotlight
      };
    }, {
      resetStyle: false
    });
    return useOriginHook(prefixCls);
  };
  const inverseColors = PresetColors.map((color) => `${color}-inverse`);
  function isPresetColor(color) {
    let includeInverse = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
    if (includeInverse) {
      return [].concat(_toConsumableArray(inverseColors), _toConsumableArray(PresetColors)).includes(color);
    }
    return PresetColors.includes(color);
  }
  function parseColor(prefixCls, color) {
    const isInternalColor = isPresetColor(color);
    const className = classNames({
      [`${prefixCls}-${color}`]: color && isInternalColor
    });
    const overlayStyle = {};
    const arrowStyle = {};
    if (color && !isInternalColor) {
      overlayStyle.background = color;
      arrowStyle["--antd-arrow-background-color"] = color;
    }
    return {
      className,
      overlayStyle,
      arrowStyle
    };
  }
  function PurePanel$4(props) {
    const {
      prefixCls: customizePrefixCls,
      className,
      placement = "top",
      title,
      color,
      overlayInnerStyle
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$3(prefixCls, true);
    const colorInfo = parseColor(prefixCls, color);
    const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
    const arrowContentStyle = colorInfo.arrowStyle;
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames(hashId, prefixCls, `${prefixCls}-pure`, `${prefixCls}-placement-${placement}`, className, colorInfo.className),
      style: arrowContentStyle
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-arrow`
    }), /* @__PURE__ */ React__namespace.createElement(Popup, Object.assign({}, props, {
      className: hashId,
      prefixCls,
      overlayInnerStyle: formattedOverlayInnerStyle
    }), title)));
  }
  var __rest$6 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const {
    useToken
  } = theme;
  const splitObject = (obj, keys2) => {
    const picked = {};
    const omitted = Object.assign({}, obj);
    keys2.forEach((key) => {
      if (obj && key in obj) {
        picked[key] = obj[key];
        delete omitted[key];
      }
    });
    return {
      picked,
      omitted
    };
  };
  function getDisabledCompatibleChildren(element, prefixCls) {
    const elementType = element.type;
    if ((elementType.__ANT_BUTTON === true || element.type === "button") && element.props.disabled || elementType.__ANT_SWITCH === true && (element.props.disabled || element.props.loading) || elementType.__ANT_RADIO === true && element.props.disabled) {
      const {
        picked,
        omitted
      } = splitObject(element.props.style, ["position", "left", "right", "top", "bottom", "float", "display", "zIndex"]);
      const spanStyle = Object.assign(Object.assign({
        display: "inline-block"
      }, picked), {
        cursor: "not-allowed",
        width: element.props.block ? "100%" : void 0
      });
      const buttonStyle = Object.assign(Object.assign({}, omitted), {
        pointerEvents: "none"
      });
      const child = cloneElement(element, {
        style: buttonStyle,
        className: null
      });
      return /* @__PURE__ */ React__namespace.createElement("span", {
        style: spanStyle,
        className: classNames(element.props.className, `${prefixCls}-disabled-compatible-wrapper`)
      }, child);
    }
    return element;
  }
  const Tooltip2 = /* @__PURE__ */ React__namespace.forwardRef((props, ref) => {
    var _a2, _b;
    const {
      prefixCls: customizePrefixCls,
      openClassName,
      getTooltipContainer,
      overlayClassName,
      color,
      overlayInnerStyle,
      children,
      afterOpenChange,
      afterVisibleChange,
      destroyTooltipOnHide,
      arrow = true,
      title,
      overlay,
      builtinPlacements,
      arrowPointAtCenter = false,
      autoAdjustOverflow = true
    } = props;
    const mergedShowArrow = !!arrow;
    const {
      token: token2
    } = useToken();
    const {
      getPopupContainer: getContextPopupContainer,
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const tooltipRef = React__namespace.useRef(null);
    const forceAlign = () => {
      var _a3;
      (_a3 = tooltipRef.current) === null || _a3 === void 0 ? void 0 : _a3.forceAlign();
    };
    React__namespace.useImperativeHandle(ref, () => ({
      forceAlign,
      forcePopupAlign: () => {
        forceAlign();
      }
    }));
    const [open, setOpen] = useMergedState(false, {
      value: (_a2 = props.open) !== null && _a2 !== void 0 ? _a2 : props.visible,
      defaultValue: (_b = props.defaultOpen) !== null && _b !== void 0 ? _b : props.defaultVisible
    });
    const noTitle = !title && !overlay && title !== 0;
    const onOpenChange = (vis) => {
      var _a3, _b2;
      setOpen(noTitle ? false : vis);
      if (!noTitle) {
        (_a3 = props.onOpenChange) === null || _a3 === void 0 ? void 0 : _a3.call(props, vis);
        (_b2 = props.onVisibleChange) === null || _b2 === void 0 ? void 0 : _b2.call(props, vis);
      }
    };
    const tooltipPlacements = React__namespace.useMemo(() => {
      var _a3, _b2;
      let mergedArrowPointAtCenter = arrowPointAtCenter;
      if (typeof arrow === "object") {
        mergedArrowPointAtCenter = (_b2 = (_a3 = arrow.pointAtCenter) !== null && _a3 !== void 0 ? _a3 : arrow.arrowPointAtCenter) !== null && _b2 !== void 0 ? _b2 : arrowPointAtCenter;
      }
      return builtinPlacements || getPlacements({
        arrowPointAtCenter: mergedArrowPointAtCenter,
        autoAdjustOverflow,
        arrowWidth: mergedShowArrow ? token2.sizePopupArrow : 0,
        borderRadius: token2.borderRadius,
        offset: token2.marginXXS,
        visibleFirst: true
      });
    }, [arrowPointAtCenter, arrow, builtinPlacements, token2]);
    const memoOverlay = React__namespace.useMemo(() => {
      if (title === 0) {
        return title;
      }
      return overlay || title || "";
    }, [overlay, title]);
    const memoOverlayWrapper = /* @__PURE__ */ React__namespace.createElement(NoCompactStyle, null, typeof memoOverlay === "function" ? memoOverlay() : memoOverlay);
    const {
      getPopupContainer,
      placement = "top",
      mouseEnterDelay = 0.1,
      mouseLeaveDelay = 0.1,
      overlayStyle,
      rootClassName
    } = props, otherProps = __rest$6(props, ["getPopupContainer", "placement", "mouseEnterDelay", "mouseLeaveDelay", "overlayStyle", "rootClassName"]);
    const prefixCls = getPrefixCls("tooltip", customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const injectFromPopover = props["data-popover-inject"];
    let tempOpen = open;
    if (!("open" in props) && !("visible" in props) && noTitle) {
      tempOpen = false;
    }
    const child = getDisabledCompatibleChildren(isValidElement(children) && !isFragment(children) ? children : /* @__PURE__ */ React__namespace.createElement("span", null, children), prefixCls);
    const childProps = child.props;
    const childCls = !childProps.className || typeof childProps.className === "string" ? classNames(childProps.className, {
      [openClassName || `${prefixCls}-open`]: true
    }) : childProps.className;
    const [wrapSSR, hashId] = useStyle$3(prefixCls, !injectFromPopover);
    const colorInfo = parseColor(prefixCls, color);
    const formattedOverlayInnerStyle = Object.assign(Object.assign({}, overlayInnerStyle), colorInfo.overlayStyle);
    const arrowContentStyle = colorInfo.arrowStyle;
    const customOverlayClassName = classNames(overlayClassName, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, colorInfo.className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement(Tooltip$3, Object.assign({}, otherProps, {
      showArrow: mergedShowArrow,
      placement,
      mouseEnterDelay,
      mouseLeaveDelay,
      prefixCls,
      overlayClassName: customOverlayClassName,
      overlayStyle: Object.assign(Object.assign({}, arrowContentStyle), overlayStyle),
      getTooltipContainer: getPopupContainer || getTooltipContainer || getContextPopupContainer,
      ref: tooltipRef,
      builtinPlacements: tooltipPlacements,
      overlay: memoOverlayWrapper,
      visible: tempOpen,
      onVisibleChange: onOpenChange,
      afterVisibleChange: afterOpenChange !== null && afterOpenChange !== void 0 ? afterOpenChange : afterVisibleChange,
      overlayInnerStyle: formattedOverlayInnerStyle,
      arrowContent: /* @__PURE__ */ React__namespace.createElement("span", {
        className: `${prefixCls}-arrow-content`
      }),
      motion: {
        motionName: getTransitionName(rootPrefixCls, "zoom-big-fast", props.transitionName),
        motionDeadline: 1e3
      },
      destroyTooltipOnHide: !!destroyTooltipOnHide
    }), tempOpen ? cloneElement(child, {
      className: childCls
    }) : child));
  });
  Tooltip2._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$4;
  const Tooltip$1 = Tooltip2;
  var VerticalAlignTopOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M859.9 168H164.1c-4.5 0-8.1 3.6-8.1 8v60c0 4.4 3.6 8 8.1 8h695.8c4.5 0 8.1-3.6 8.1-8v-60c0-4.4-3.6-8-8.1-8zM518.3 355a8 8 0 00-12.6 0l-112 141.7a7.98 7.98 0 006.3 12.9h73.9V848c0 4.4 3.6 8 8 8h60c4.4 0 8-3.6 8-8V509.7H624c6.7 0 10.4-7.7 6.3-12.9L518.3 355z" } }] }, "name": "vertical-align-top", "theme": "outlined" };
  const VerticalAlignTopOutlinedSvg = VerticalAlignTopOutlined$2;
  var VerticalAlignTopOutlined = function VerticalAlignTopOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: VerticalAlignTopOutlinedSvg
    }));
  };
  const VerticalAlignTopOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(VerticalAlignTopOutlined);
  const antStatusProcessing = new Keyframe("antStatusProcessing", {
    "0%": {
      transform: "scale(0.8)",
      opacity: 0.5
    },
    "100%": {
      transform: "scale(2.4)",
      opacity: 0
    }
  });
  const antZoomBadgeIn = new Keyframe("antZoomBadgeIn", {
    "0%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1) translate(50%, -50%)"
    }
  });
  const antZoomBadgeOut = new Keyframe("antZoomBadgeOut", {
    "0%": {
      transform: "scale(1) translate(50%, -50%)"
    },
    "100%": {
      transform: "scale(0) translate(50%, -50%)",
      opacity: 0
    }
  });
  const antNoWrapperZoomBadgeIn = new Keyframe("antNoWrapperZoomBadgeIn", {
    "0%": {
      transform: "scale(0)",
      opacity: 0
    },
    "100%": {
      transform: "scale(1)"
    }
  });
  const antNoWrapperZoomBadgeOut = new Keyframe("antNoWrapperZoomBadgeOut", {
    "0%": {
      transform: "scale(1)"
    },
    "100%": {
      transform: "scale(0)",
      opacity: 0
    }
  });
  const antBadgeLoadingCircle = new Keyframe("antBadgeLoadingCircle", {
    "0%": {
      transformOrigin: "50%"
    },
    "100%": {
      transform: "translate(50%, -50%) rotate(360deg)",
      transformOrigin: "50%"
    }
  });
  const genSharedBadgeStyle = (token2) => {
    const {
      componentCls,
      iconCls,
      antCls,
      badgeFontHeight,
      badgeShadowSize,
      badgeHeightSm,
      motionDurationSlow,
      badgeStatusSize,
      marginXS,
      badgeRibbonOffset
    } = token2;
    const numberPrefixCls = `${antCls}-scroll-number`;
    const ribbonPrefixCls = `${antCls}-ribbon`;
    const ribbonWrapperPrefixCls = `${antCls}-ribbon-wrapper`;
    const colorPreset = genPresetColor(token2, (colorKey, _ref) => {
      let {
        darkColor
      } = _ref;
      return {
        [`${componentCls}-color-${colorKey}`]: {
          background: darkColor
        }
      };
    });
    const statusRibbonPreset = genPresetColor(token2, (colorKey, _ref2) => {
      let {
        darkColor
      } = _ref2;
      return {
        [`&${ribbonPrefixCls}-color-${colorKey}`]: {
          background: darkColor,
          color: darkColor
        }
      };
    });
    return {
      [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "relative",
        display: "inline-block",
        width: "fit-content",
        lineHeight: 1,
        [`${componentCls}-count`]: {
          zIndex: token2.badgeZIndex,
          minWidth: token2.badgeHeight,
          height: token2.badgeHeight,
          color: token2.badgeTextColor,
          fontWeight: token2.badgeFontWeight,
          fontSize: token2.badgeFontSize,
          lineHeight: `${token2.badgeHeight}px`,
          whiteSpace: "nowrap",
          textAlign: "center",
          background: token2.badgeColor,
          borderRadius: token2.badgeHeight / 2,
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`,
          transition: `background ${token2.motionDurationMid}`,
          a: {
            color: token2.badgeTextColor
          },
          "a:hover": {
            color: token2.badgeTextColor
          },
          "a:hover &": {
            background: token2.badgeColorHover
          }
        },
        [`${componentCls}-count-sm`]: {
          minWidth: badgeHeightSm,
          height: badgeHeightSm,
          fontSize: token2.badgeFontSizeSm,
          lineHeight: `${badgeHeightSm}px`,
          borderRadius: badgeHeightSm / 2
        },
        [`${componentCls}-multiple-words`]: {
          padding: `0 ${token2.paddingXS}px`
        },
        [`${componentCls}-dot`]: {
          zIndex: token2.badgeZIndex,
          width: token2.badgeDotSize,
          minWidth: token2.badgeDotSize,
          height: token2.badgeDotSize,
          background: token2.badgeColor,
          borderRadius: "100%",
          boxShadow: `0 0 0 ${badgeShadowSize}px ${token2.badgeShadowColor}`
        },
        [`${componentCls}-dot${numberPrefixCls}`]: {
          transition: `background ${motionDurationSlow}`
        },
        [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
          position: "absolute",
          top: 0,
          insetInlineEnd: 0,
          transform: "translate(50%, -50%)",
          transformOrigin: "100% 0%",
          [`&${iconCls}-spin`]: {
            animationName: antBadgeLoadingCircle,
            animationDuration: "1s",
            animationIterationCount: "infinite",
            animationTimingFunction: "linear"
          }
        },
        [`&${componentCls}-status`]: {
          lineHeight: "inherit",
          verticalAlign: "baseline",
          [`${componentCls}-status-dot`]: {
            position: "relative",
            top: -1,
            display: "inline-block",
            width: badgeStatusSize,
            height: badgeStatusSize,
            verticalAlign: "middle",
            borderRadius: "50%"
          },
          [`${componentCls}-status-success`]: {
            backgroundColor: token2.colorSuccess
          },
          [`${componentCls}-status-processing`]: {
            position: "relative",
            color: token2.colorPrimary,
            backgroundColor: token2.colorPrimary,
            "&::after": {
              position: "absolute",
              top: 0,
              insetInlineStart: 0,
              width: "100%",
              height: "100%",
              borderWidth: badgeShadowSize,
              borderStyle: "solid",
              borderColor: "inherit",
              borderRadius: "50%",
              animationName: antStatusProcessing,
              animationDuration: token2.badgeProcessingDuration,
              animationIterationCount: "infinite",
              animationTimingFunction: "ease-in-out",
              content: '""'
            }
          },
          [`${componentCls}-status-default`]: {
            backgroundColor: token2.colorTextPlaceholder
          },
          [`${componentCls}-status-error`]: {
            backgroundColor: token2.colorError
          },
          [`${componentCls}-status-warning`]: {
            backgroundColor: token2.colorWarning
          },
          [`${componentCls}-status-text`]: {
            marginInlineStart: marginXS,
            color: token2.colorText,
            fontSize: token2.fontSize
          }
        }
      }), colorPreset), {
        [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
          animationName: antZoomBadgeIn,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`${componentCls}-zoom-leave`]: {
          animationName: antZoomBadgeOut,
          animationDuration: token2.motionDurationSlow,
          animationTimingFunction: token2.motionEaseOutBack,
          animationFillMode: "both"
        },
        [`&${componentCls}-not-a-wrapper`]: {
          [`${componentCls}-zoom-appear, ${componentCls}-zoom-enter`]: {
            animationName: antNoWrapperZoomBadgeIn,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`${componentCls}-zoom-leave`]: {
            animationName: antNoWrapperZoomBadgeOut,
            animationDuration: token2.motionDurationSlow,
            animationTimingFunction: token2.motionEaseOutBack
          },
          [`&:not(${componentCls}-status)`]: {
            verticalAlign: "middle"
          },
          [`${numberPrefixCls}-custom-component, ${componentCls}-count`]: {
            transform: "none"
          },
          [`${numberPrefixCls}-custom-component, ${numberPrefixCls}`]: {
            position: "relative",
            top: "auto",
            display: "block",
            transformOrigin: "50% 50%"
          }
        },
        [`${numberPrefixCls}`]: {
          overflow: "hidden",
          [`${numberPrefixCls}-only`]: {
            position: "relative",
            display: "inline-block",
            height: token2.badgeHeight,
            transition: `all ${token2.motionDurationSlow} ${token2.motionEaseOutBack}`,
            WebkitTransformStyle: "preserve-3d",
            WebkitBackfaceVisibility: "hidden",
            [`> p${numberPrefixCls}-only-unit`]: {
              height: token2.badgeHeight,
              margin: 0,
              WebkitTransformStyle: "preserve-3d",
              WebkitBackfaceVisibility: "hidden"
            }
          },
          [`${numberPrefixCls}-symbol`]: {
            verticalAlign: "top"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl",
          [`${componentCls}-count, ${componentCls}-dot, ${numberPrefixCls}-custom-component`]: {
            transform: "translate(-50%, -50%)"
          }
        }
      }),
      [`${ribbonWrapperPrefixCls}`]: {
        position: "relative"
      },
      [`${ribbonPrefixCls}`]: Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token2)), {
        position: "absolute",
        top: marginXS,
        padding: `0 ${token2.paddingXS}px`,
        color: token2.colorPrimary,
        lineHeight: `${badgeFontHeight}px`,
        whiteSpace: "nowrap",
        backgroundColor: token2.colorPrimary,
        borderRadius: token2.borderRadiusSM,
        [`${ribbonPrefixCls}-text`]: {
          color: token2.colorTextLightSolid
        },
        [`${ribbonPrefixCls}-corner`]: {
          position: "absolute",
          top: "100%",
          width: badgeRibbonOffset,
          height: badgeRibbonOffset,
          color: "currentcolor",
          border: `${badgeRibbonOffset / 2}px solid`,
          transform: token2.badgeRibbonCornerTransform,
          transformOrigin: "top",
          filter: token2.badgeRibbonCornerFilter
        }
      }), statusRibbonPreset), {
        [`&${ribbonPrefixCls}-placement-end`]: {
          insetInlineEnd: -badgeRibbonOffset,
          borderEndEndRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineEnd: 0,
            borderInlineEndColor: "transparent",
            borderBlockEndColor: "transparent"
          }
        },
        [`&${ribbonPrefixCls}-placement-start`]: {
          insetInlineStart: -badgeRibbonOffset,
          borderEndStartRadius: 0,
          [`${ribbonPrefixCls}-corner`]: {
            insetInlineStart: 0,
            borderBlockEndColor: "transparent",
            borderInlineStartColor: "transparent"
          }
        },
        // ====================== RTL =======================
        "&-rtl": {
          direction: "rtl"
        }
      })
    };
  };
  const useStyle$2 = genComponentStyleHook("Badge", (token2) => {
    const {
      fontSize,
      lineHeight,
      fontSizeSM,
      lineWidth,
      marginXS,
      colorBorderBg
    } = token2;
    const badgeFontHeight = Math.round(fontSize * lineHeight);
    const badgeShadowSize = lineWidth;
    const badgeZIndex = "auto";
    const badgeHeight = badgeFontHeight - 2 * badgeShadowSize;
    const badgeTextColor = token2.colorBgContainer;
    const badgeFontWeight = "normal";
    const badgeFontSize = fontSizeSM;
    const badgeColor = token2.colorError;
    const badgeColorHover = token2.colorErrorHover;
    const badgeHeightSm = fontSize;
    const badgeDotSize = fontSizeSM / 2;
    const badgeFontSizeSm = fontSizeSM;
    const badgeStatusSize = fontSizeSM / 2;
    const badgeToken = merge$1(token2, {
      badgeFontHeight,
      badgeShadowSize,
      badgeZIndex,
      badgeHeight,
      badgeTextColor,
      badgeFontWeight,
      badgeFontSize,
      badgeColor,
      badgeColorHover,
      badgeShadowColor: colorBorderBg,
      badgeHeightSm,
      badgeDotSize,
      badgeFontSizeSm,
      badgeStatusSize,
      badgeProcessingDuration: "1.2s",
      badgeRibbonOffset: marginXS,
      // Follow token just by Design. Not related with token
      badgeRibbonCornerTransform: "scaleY(0.75)",
      badgeRibbonCornerFilter: `brightness(75%)`
    });
    return [genSharedBadgeStyle(badgeToken)];
  });
  const Ribbon = (_ref) => {
    let {
      className,
      prefixCls: customizePrefixCls,
      style: style2,
      color,
      children,
      text,
      placement = "end"
    } = _ref;
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("ribbon", customizePrefixCls);
    const colorInPreset = isPresetColor(color, false);
    const ribbonCls = classNames(prefixCls, `${prefixCls}-placement-${placement}`, {
      [`${prefixCls}-rtl`]: direction === "rtl",
      [`${prefixCls}-color-${color}`]: colorInPreset
    }, className);
    const [wrapSSR, hashId] = useStyle$2(prefixCls);
    const colorStyle = {};
    const cornerColorStyle = {};
    if (color && !colorInPreset) {
      colorStyle.background = color;
      cornerColorStyle.color = color;
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames(`${prefixCls}-wrapper`, hashId)
    }, children, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames(ribbonCls, hashId),
      style: Object.assign(Object.assign({}, colorStyle), style2)
    }, /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-text`
    }, text), /* @__PURE__ */ React__namespace.createElement("div", {
      className: `${prefixCls}-corner`,
      style: cornerColorStyle
    }))));
  };
  const Ribbon$1 = Ribbon;
  function UnitNumber(_ref) {
    let {
      prefixCls,
      value,
      current,
      offset: offset2 = 0
    } = _ref;
    let style2;
    if (offset2) {
      style2 = {
        position: "absolute",
        top: `${offset2}00%`,
        left: 0
      };
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      style: style2,
      className: classNames(`${prefixCls}-only-unit`, {
        current
      })
    }, value);
  }
  function getOffset$2(start, end, unit) {
    let index2 = start;
    let offset2 = 0;
    while ((index2 + 10) % 10 !== end) {
      index2 += unit;
      offset2 += unit;
    }
    return offset2;
  }
  function SingleNumber(props) {
    const {
      prefixCls,
      count: originCount,
      value: originValue
    } = props;
    const value = Number(originValue);
    const count = Math.abs(originCount);
    const [prevValue, setPrevValue] = React__namespace.useState(value);
    const [prevCount, setPrevCount] = React__namespace.useState(count);
    const onTransitionEnd = () => {
      setPrevValue(value);
      setPrevCount(count);
    };
    React__namespace.useEffect(() => {
      const timeout = setTimeout(() => {
        onTransitionEnd();
      }, 1e3);
      return () => {
        clearTimeout(timeout);
      };
    }, [value]);
    let unitNodes;
    let offsetStyle;
    if (prevValue === value || Number.isNaN(value) || Number.isNaN(prevValue)) {
      unitNodes = [/* @__PURE__ */ React__namespace.createElement(UnitNumber, Object.assign({}, props, {
        key: value,
        current: true
      }))];
      offsetStyle = {
        transition: "none"
      };
    } else {
      unitNodes = [];
      const end = value + 10;
      const unitNumberList = [];
      for (let index2 = value; index2 <= end; index2 += 1) {
        unitNumberList.push(index2);
      }
      const prevIndex = unitNumberList.findIndex((n2) => n2 % 10 === prevValue);
      unitNodes = unitNumberList.map((n2, index2) => {
        const singleUnit = n2 % 10;
        return /* @__PURE__ */ React__namespace.createElement(UnitNumber, Object.assign({}, props, {
          key: n2,
          value: singleUnit,
          offset: index2 - prevIndex,
          current: index2 === prevIndex
        }));
      });
      const unit = prevCount < count ? 1 : -1;
      offsetStyle = {
        transform: `translateY(${-getOffset$2(prevValue, value, unit)}00%)`
      };
    }
    return /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-only`,
      style: offsetStyle,
      onTransitionEnd
    }, unitNodes);
  }
  var __rest$5 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const ScrollNumber = /* @__PURE__ */ React__namespace.forwardRef((_a2, ref) => {
    var {
      prefixCls: customizePrefixCls,
      count,
      className,
      motionClassName,
      style: style2,
      title,
      show,
      component: Component2 = "sup",
      children
    } = _a2, restProps = __rest$5(_a2, ["prefixCls", "count", "className", "motionClassName", "style", "title", "show", "component", "children"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("scroll-number", customizePrefixCls);
    const newProps = Object.assign(Object.assign({}, restProps), {
      "data-show": show,
      style: style2,
      className: classNames(prefixCls, className, motionClassName),
      title
    });
    let numberNodes = count;
    if (count && Number(count) % 1 === 0) {
      const numberList = String(count).split("");
      numberNodes = numberList.map((num, i) => /* @__PURE__ */ React__namespace.createElement(SingleNumber, {
        prefixCls,
        count: Number(count),
        value: num,
        // eslint-disable-next-line react/no-array-index-key
        key: numberList.length - i
      }));
    }
    if (style2 && style2.borderColor) {
      newProps.style = Object.assign(Object.assign({}, style2), {
        boxShadow: `0 0 0 1px ${style2.borderColor} inset`
      });
    }
    if (children) {
      return cloneElement(children, (oriProps) => ({
        className: classNames(`${prefixCls}-custom-component`, oriProps === null || oriProps === void 0 ? void 0 : oriProps.className, motionClassName)
      }));
    }
    return /* @__PURE__ */ React__namespace.createElement(Component2, Object.assign({}, newProps, {
      ref
    }), numberNodes);
  });
  const ScrollNumber$1 = ScrollNumber;
  var __rest$4 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const InternalBadge = (props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      scrollNumberPrefixCls: customizeScrollNumberPrefixCls,
      children,
      status,
      text,
      color,
      count = null,
      overflowCount = 99,
      dot = false,
      size = "default",
      title,
      offset: offset2,
      style: style2,
      className,
      rootClassName,
      showZero = false
    } = props, restProps = __rest$4(props, ["prefixCls", "scrollNumberPrefixCls", "children", "status", "text", "color", "count", "overflowCount", "dot", "size", "title", "offset", "style", "className", "rootClassName", "showZero"]);
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("badge", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$2(prefixCls);
    const numberedDisplayCount = count > overflowCount ? `${overflowCount}+` : count;
    const isZero = numberedDisplayCount === "0" || numberedDisplayCount === 0;
    const ignoreCount = count === null || isZero && !showZero;
    const hasStatus = (status !== null && status !== void 0 || color !== null && color !== void 0) && ignoreCount;
    const showAsDot = dot && !isZero;
    const mergedCount = showAsDot ? "" : numberedDisplayCount;
    const isHidden = React.useMemo(() => {
      const isEmpty = mergedCount === null || mergedCount === void 0 || mergedCount === "";
      return (isEmpty || isZero && !showZero) && !showAsDot;
    }, [mergedCount, isZero, showZero, showAsDot]);
    const countRef = React.useRef(count);
    if (!isHidden) {
      countRef.current = count;
    }
    const livingCount = countRef.current;
    const displayCountRef = React.useRef(mergedCount);
    if (!isHidden) {
      displayCountRef.current = mergedCount;
    }
    const displayCount = displayCountRef.current;
    const isDotRef = React.useRef(showAsDot);
    if (!isHidden) {
      isDotRef.current = showAsDot;
    }
    const mergedStyle = React.useMemo(() => {
      if (!offset2) {
        return Object.assign({}, style2);
      }
      const offsetStyle = {
        marginTop: offset2[1]
      };
      if (direction === "rtl") {
        offsetStyle.left = parseInt(offset2[0], 10);
      } else {
        offsetStyle.right = -parseInt(offset2[0], 10);
      }
      return Object.assign(Object.assign({}, offsetStyle), style2);
    }, [direction, offset2, style2]);
    const titleNode = title !== null && title !== void 0 ? title : typeof livingCount === "string" || typeof livingCount === "number" ? livingCount : void 0;
    const statusTextNode = isHidden || !text ? null : /* @__PURE__ */ React__namespace.createElement("span", {
      className: `${prefixCls}-status-text`
    }, text);
    const displayNode = !livingCount || typeof livingCount !== "object" ? void 0 : cloneElement(livingCount, (oriProps) => ({
      style: Object.assign(Object.assign({}, mergedStyle), oriProps.style)
    }));
    const isInternalColor = isPresetColor(color, false);
    const statusCls = classNames({
      [`${prefixCls}-status-dot`]: hasStatus,
      [`${prefixCls}-status-${status}`]: !!status,
      [`${prefixCls}-color-${color}`]: isInternalColor
    });
    const statusStyle = {};
    if (color && !isInternalColor) {
      statusStyle.color = color;
      statusStyle.background = color;
    }
    const badgeClassName = classNames(prefixCls, {
      [`${prefixCls}-status`]: hasStatus,
      [`${prefixCls}-not-a-wrapper`]: !children,
      [`${prefixCls}-rtl`]: direction === "rtl"
    }, className, rootClassName, hashId);
    if (!children && hasStatus) {
      const statusTextColor = mergedStyle.color;
      return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", Object.assign({}, restProps, {
        className: badgeClassName,
        style: mergedStyle
      }), /* @__PURE__ */ React__namespace.createElement("span", {
        className: statusCls,
        style: statusStyle
      }), text && /* @__PURE__ */ React__namespace.createElement("span", {
        style: {
          color: statusTextColor
        },
        className: `${prefixCls}-status-text`
      }, text)));
    }
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("span", Object.assign({
      ref
    }, restProps, {
      className: badgeClassName
    }), children, /* @__PURE__ */ React__namespace.createElement(CSSMotion, {
      visible: !isHidden,
      motionName: `${prefixCls}-zoom`,
      motionAppear: false,
      motionDeadline: 1e3
    }, (_ref) => {
      let {
        className: motionClassName,
        ref: scrollNumberRef
      } = _ref;
      const scrollNumberPrefixCls = getPrefixCls("scroll-number", customizeScrollNumberPrefixCls);
      const isDot = isDotRef.current;
      const scrollNumberCls = classNames({
        [`${prefixCls}-dot`]: isDot,
        [`${prefixCls}-count`]: !isDot,
        [`${prefixCls}-count-sm`]: size === "small",
        [`${prefixCls}-multiple-words`]: !isDot && displayCount && displayCount.toString().length > 1,
        [`${prefixCls}-status-${status}`]: !!status,
        [`${prefixCls}-color-${color}`]: isInternalColor
      });
      let scrollNumberStyle = Object.assign({}, mergedStyle);
      if (color && !isInternalColor) {
        scrollNumberStyle = scrollNumberStyle || {};
        scrollNumberStyle.background = color;
      }
      return /* @__PURE__ */ React__namespace.createElement(ScrollNumber$1, {
        prefixCls: scrollNumberPrefixCls,
        show: !isHidden,
        motionClassName,
        className: scrollNumberCls,
        count: displayCount,
        title: titleNode,
        style: scrollNumberStyle,
        key: "scrollNumber",
        ref: scrollNumberRef
      }, displayNode);
    }), statusTextNode));
  };
  const Badge = /* @__PURE__ */ React__namespace.forwardRef(InternalBadge);
  Badge.Ribbon = Ribbon$1;
  const Badge$1 = Badge;
  const Element$1 = (props) => {
    const {
      prefixCls,
      className,
      style: style2,
      size,
      shape
    } = props;
    const sizeCls = classNames({
      [`${prefixCls}-lg`]: size === "large",
      [`${prefixCls}-sm`]: size === "small"
    });
    const shapeCls = classNames({
      [`${prefixCls}-circle`]: shape === "circle",
      [`${prefixCls}-square`]: shape === "square",
      [`${prefixCls}-round`]: shape === "round"
    });
    const sizeStyle = React__namespace.useMemo(() => typeof size === "number" ? {
      width: size,
      height: size,
      lineHeight: `${size}px`
    } : {}, [size]);
    return /* @__PURE__ */ React__namespace.createElement("span", {
      className: classNames(prefixCls, sizeCls, shapeCls, className),
      style: Object.assign(Object.assign({}, sizeStyle), style2)
    });
  };
  const Element$2 = Element$1;
  const skeletonClsLoading = new Keyframe(`ant-skeleton-loading`, {
    "0%": {
      backgroundPosition: "100% 50%"
    },
    "100%": {
      backgroundPosition: "0 50%"
    }
  });
  const genSkeletonElementCommonSize = (size) => ({
    height: size,
    lineHeight: `${size}px`
  });
  const genSkeletonElementAvatarSize = (size) => Object.assign({
    width: size
  }, genSkeletonElementCommonSize(size));
  const genSkeletonColor = (token2) => ({
    background: token2.skeletonLoadingBackground,
    backgroundSize: "400% 100%",
    animationName: skeletonClsLoading,
    animationDuration: token2.skeletonLoadingMotionDuration,
    animationTimingFunction: "ease",
    animationIterationCount: "infinite"
  });
  const genSkeletonElementInputSize = (size) => Object.assign({
    width: size * 5,
    minWidth: size * 5
  }, genSkeletonElementCommonSize(size));
  const genSkeletonElementAvatar = (token2) => {
    const {
      skeletonAvatarCls,
      gradientFromColor,
      controlHeight,
      controlHeightLG,
      controlHeightSM
    } = token2;
    return {
      [`${skeletonAvatarCls}`]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor
      }, genSkeletonElementAvatarSize(controlHeight)),
      [`${skeletonAvatarCls}${skeletonAvatarCls}-circle`]: {
        borderRadius: "50%"
      },
      [`${skeletonAvatarCls}${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
      [`${skeletonAvatarCls}${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
    };
  };
  const genSkeletonElementInput = (token2) => {
    const {
      controlHeight,
      borderRadiusSM,
      skeletonInputCls,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor
    } = token2;
    return {
      [`${skeletonInputCls}`]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM
      }, genSkeletonElementInputSize(controlHeight)),
      [`${skeletonInputCls}-lg`]: Object.assign({}, genSkeletonElementInputSize(controlHeightLG)),
      [`${skeletonInputCls}-sm`]: Object.assign({}, genSkeletonElementInputSize(controlHeightSM))
    };
  };
  const genSkeletonElementImageSize = (size) => Object.assign({
    width: size
  }, genSkeletonElementCommonSize(size));
  const genSkeletonElementImage = (token2) => {
    const {
      skeletonImageCls,
      imageSizeBase,
      gradientFromColor,
      borderRadiusSM
    } = token2;
    return {
      [`${skeletonImageCls}`]: Object.assign(Object.assign({
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM
      }, genSkeletonElementImageSize(imageSizeBase * 2)), {
        [`${skeletonImageCls}-path`]: {
          fill: "#bfbfbf"
        },
        [`${skeletonImageCls}-svg`]: Object.assign(Object.assign({}, genSkeletonElementImageSize(imageSizeBase)), {
          maxWidth: imageSizeBase * 4,
          maxHeight: imageSizeBase * 4
        }),
        [`${skeletonImageCls}-svg${skeletonImageCls}-svg-circle`]: {
          borderRadius: "50%"
        }
      }),
      [`${skeletonImageCls}${skeletonImageCls}-circle`]: {
        borderRadius: "50%"
      }
    };
  };
  const genSkeletonElementButtonShape = (token2, size, buttonCls) => {
    const {
      skeletonButtonCls
    } = token2;
    return {
      [`${buttonCls}${skeletonButtonCls}-circle`]: {
        width: size,
        minWidth: size,
        borderRadius: "50%"
      },
      [`${buttonCls}${skeletonButtonCls}-round`]: {
        borderRadius: size
      }
    };
  };
  const genSkeletonElementButtonSize = (size) => Object.assign({
    width: size * 2,
    minWidth: size * 2
  }, genSkeletonElementCommonSize(size));
  const genSkeletonElementButton = (token2) => {
    const {
      borderRadiusSM,
      skeletonButtonCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor
    } = token2;
    return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      [`${skeletonButtonCls}`]: Object.assign({
        display: "inline-block",
        verticalAlign: "top",
        background: gradientFromColor,
        borderRadius: borderRadiusSM,
        width: controlHeight * 2,
        minWidth: controlHeight * 2
      }, genSkeletonElementButtonSize(controlHeight))
    }, genSkeletonElementButtonShape(token2, controlHeight, skeletonButtonCls)), {
      [`${skeletonButtonCls}-lg`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightLG))
    }), genSkeletonElementButtonShape(token2, controlHeightLG, `${skeletonButtonCls}-lg`)), {
      [`${skeletonButtonCls}-sm`]: Object.assign({}, genSkeletonElementButtonSize(controlHeightSM))
    }), genSkeletonElementButtonShape(token2, controlHeightSM, `${skeletonButtonCls}-sm`));
  };
  const genBaseStyle = (token2) => {
    const {
      componentCls,
      skeletonAvatarCls,
      skeletonTitleCls,
      skeletonParagraphCls,
      skeletonButtonCls,
      skeletonInputCls,
      skeletonImageCls,
      controlHeight,
      controlHeightLG,
      controlHeightSM,
      gradientFromColor,
      padding,
      marginSM,
      borderRadius,
      titleHeight,
      blockRadius,
      paragraphLiHeight,
      controlHeightXS,
      paragraphMarginTop
    } = token2;
    return {
      [`${componentCls}`]: {
        display: "table",
        width: "100%",
        [`${componentCls}-header`]: {
          display: "table-cell",
          paddingInlineEnd: padding,
          verticalAlign: "top",
          // Avatar
          [`${skeletonAvatarCls}`]: Object.assign({
            display: "inline-block",
            verticalAlign: "top",
            background: gradientFromColor
          }, genSkeletonElementAvatarSize(controlHeight)),
          [`${skeletonAvatarCls}-circle`]: {
            borderRadius: "50%"
          },
          [`${skeletonAvatarCls}-lg`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightLG)),
          [`${skeletonAvatarCls}-sm`]: Object.assign({}, genSkeletonElementAvatarSize(controlHeightSM))
        },
        [`${componentCls}-content`]: {
          display: "table-cell",
          width: "100%",
          verticalAlign: "top",
          // Title
          [`${skeletonTitleCls}`]: {
            width: "100%",
            height: titleHeight,
            background: gradientFromColor,
            borderRadius: blockRadius,
            [`+ ${skeletonParagraphCls}`]: {
              marginBlockStart: controlHeightSM
            }
          },
          // paragraph
          [`${skeletonParagraphCls}`]: {
            padding: 0,
            "> li": {
              width: "100%",
              height: paragraphLiHeight,
              listStyle: "none",
              background: gradientFromColor,
              borderRadius: blockRadius,
              "+ li": {
                marginBlockStart: controlHeightXS
              }
            }
          },
          [`${skeletonParagraphCls}> li:last-child:not(:first-child):not(:nth-child(2))`]: {
            width: "61%"
          }
        },
        [`&-round ${componentCls}-content`]: {
          [`${skeletonTitleCls}, ${skeletonParagraphCls} > li`]: {
            borderRadius
          }
        }
      },
      [`${componentCls}-with-avatar ${componentCls}-content`]: {
        // Title
        [`${skeletonTitleCls}`]: {
          marginBlockStart: marginSM,
          [`+ ${skeletonParagraphCls}`]: {
            marginBlockStart: paragraphMarginTop
          }
        }
      },
      // Skeleton element
      [`${componentCls}${componentCls}-element`]: Object.assign(Object.assign(Object.assign(Object.assign({
        display: "inline-block",
        width: "auto"
      }, genSkeletonElementButton(token2)), genSkeletonElementAvatar(token2)), genSkeletonElementInput(token2)), genSkeletonElementImage(token2)),
      // Skeleton Block Button, Input
      [`${componentCls}${componentCls}-block`]: {
        width: "100%",
        [`${skeletonButtonCls}`]: {
          width: "100%"
        },
        [`${skeletonInputCls}`]: {
          width: "100%"
        }
      },
      // With active animation
      [`${componentCls}${componentCls}-active`]: {
        [`
        ${skeletonTitleCls},
        ${skeletonParagraphCls} > li,
        ${skeletonAvatarCls},
        ${skeletonButtonCls},
        ${skeletonInputCls},
        ${skeletonImageCls}
      `]: Object.assign({}, genSkeletonColor(token2))
      }
    };
  };
  const useStyle$1 = genComponentStyleHook("Skeleton", (token2) => {
    const {
      componentCls
    } = token2;
    const skeletonToken = merge$1(token2, {
      skeletonAvatarCls: `${componentCls}-avatar`,
      skeletonTitleCls: `${componentCls}-title`,
      skeletonParagraphCls: `${componentCls}-paragraph`,
      skeletonButtonCls: `${componentCls}-button`,
      skeletonInputCls: `${componentCls}-input`,
      skeletonImageCls: `${componentCls}-image`,
      imageSizeBase: token2.controlHeight * 1.5,
      borderRadius: 100,
      skeletonLoadingBackground: `linear-gradient(90deg, ${token2.gradientFromColor} 25%, ${token2.gradientToColor} 37%, ${token2.gradientFromColor} 63%)`,
      skeletonLoadingMotionDuration: "1.4s"
    });
    return [genBaseStyle(skeletonToken)];
  }, (token2) => {
    const {
      colorFillContent,
      colorFill
    } = token2;
    const gradientFromColor = colorFillContent;
    const gradientToColor = colorFill;
    return {
      color: gradientFromColor,
      colorGradientEnd: gradientToColor,
      gradientFromColor,
      gradientToColor,
      titleHeight: token2.controlHeight / 2,
      blockRadius: token2.borderRadiusSM,
      paragraphMarginTop: token2.marginLG + token2.marginXXS,
      paragraphLiHeight: token2.controlHeight / 2
    };
  }, {
    deprecatedTokens: [["color", "gradientFromColor"], ["colorGradientEnd", "gradientToColor"]]
  });
  const SkeletonAvatar = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      shape = "circle",
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const otherProps = omit(props, ["prefixCls", "className"]);
    const cls = classNames(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls
    }, /* @__PURE__ */ React__namespace.createElement(Element$2, Object.assign({
      prefixCls: `${prefixCls}-avatar`,
      shape,
      size
    }, otherProps))));
  };
  const SkeletonAvatar$1 = SkeletonAvatar;
  const SkeletonButton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      block = false,
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const otherProps = omit(props, ["prefixCls"]);
    const cls = classNames(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls
    }, /* @__PURE__ */ React__namespace.createElement(Element$2, Object.assign({
      prefixCls: `${prefixCls}-button`,
      size
    }, otherProps))));
  };
  const SkeletonButton$1 = SkeletonButton;
  var DotChartOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M888 792H200V168c0-4.4-3.6-8-8-8h-56c-4.4 0-8 3.6-8 8v688c0 4.4 3.6 8 8 8h752c4.4 0 8-3.6 8-8v-56c0-4.4-3.6-8-8-8zM288 604a64 64 0 10128 0 64 64 0 10-128 0zm118-224a48 48 0 1096 0 48 48 0 10-96 0zm158 228a96 96 0 10192 0 96 96 0 10-192 0zm148-314a56 56 0 10112 0 56 56 0 10-112 0z" } }] }, "name": "dot-chart", "theme": "outlined" };
  const DotChartOutlinedSvg = DotChartOutlined$2;
  var DotChartOutlined = function DotChartOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: DotChartOutlinedSvg
    }));
  };
  const DotChartOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(DotChartOutlined);
  const SkeletonNode = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      active,
      children
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const cls = classNames(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, hashId, className, rootClassName);
    const content = children !== null && children !== void 0 ? children : /* @__PURE__ */ React__namespace.createElement(DotChartOutlined$1, null);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames(`${prefixCls}-image`, className),
      style: style2
    }, content)));
  };
  const SkeletonNode$1 = SkeletonNode;
  const path = "M365.714286 329.142857q0 45.714286-32.036571 77.677714t-77.677714 32.036571-77.677714-32.036571-32.036571-77.677714 32.036571-77.677714 77.677714-32.036571 77.677714 32.036571 32.036571 77.677714zM950.857143 548.571429l0 256-804.571429 0 0-109.714286 182.857143-182.857143 91.428571 91.428571 292.571429-292.571429zM1005.714286 146.285714l-914.285714 0q-7.460571 0-12.873143 5.412571t-5.412571 12.873143l0 694.857143q0 7.460571 5.412571 12.873143t12.873143 5.412571l914.285714 0q7.460571 0 12.873143-5.412571t5.412571-12.873143l0-694.857143q0-7.460571-5.412571-12.873143t-12.873143-5.412571zM1097.142857 164.571429l0 694.857143q0 37.741714-26.843429 64.585143t-64.585143 26.843429l-914.285714 0q-37.741714 0-64.585143-26.843429t-26.843429-64.585143l0-694.857143q0-37.741714 26.843429-64.585143t64.585143-26.843429l914.285714 0q37.741714 0 64.585143 26.843429t26.843429 64.585143z";
  const SkeletonImage = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      style: style2,
      active
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const cls = classNames(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active
    }, className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls
    }, /* @__PURE__ */ React__namespace.createElement("div", {
      className: classNames(`${prefixCls}-image`, className),
      style: style2
    }, /* @__PURE__ */ React__namespace.createElement("svg", {
      viewBox: "0 0 1098 1024",
      xmlns: "http://www.w3.org/2000/svg",
      className: `${prefixCls}-image-svg`
    }, /* @__PURE__ */ React__namespace.createElement("path", {
      d: path,
      className: `${prefixCls}-image-path`
    })))));
  };
  const SkeletonImage$1 = SkeletonImage;
  const SkeletonInput = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      active,
      block,
      size = "default"
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    const otherProps = omit(props, ["prefixCls"]);
    const cls = classNames(prefixCls, `${prefixCls}-element`, {
      [`${prefixCls}-active`]: active,
      [`${prefixCls}-block`]: block
    }, className, rootClassName, hashId);
    return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
      className: cls
    }, /* @__PURE__ */ React__namespace.createElement(Element$2, Object.assign({
      prefixCls: `${prefixCls}-input`,
      size
    }, otherProps))));
  };
  const SkeletonInput$1 = SkeletonInput;
  const Paragraph = (props) => {
    const getWidth = (index2) => {
      const {
        width,
        rows: rows2 = 2
      } = props;
      if (Array.isArray(width)) {
        return width[index2];
      }
      if (rows2 - 1 === index2) {
        return width;
      }
      return void 0;
    };
    const {
      prefixCls,
      className,
      style: style2,
      rows
    } = props;
    const rowList = _toConsumableArray(Array(rows)).map((_2, index2) => (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React__namespace.createElement("li", {
        key: index2,
        style: {
          width: getWidth(index2)
        }
      })
    ));
    return /* @__PURE__ */ React__namespace.createElement("ul", {
      className: classNames(prefixCls, className),
      style: style2
    }, rowList);
  };
  const Paragraph$1 = Paragraph;
  const Title = (_ref) => {
    let {
      prefixCls,
      className,
      width,
      style: style2
    } = _ref;
    return /* @__PURE__ */ React__namespace.createElement("h3", {
      className: classNames(prefixCls, className),
      style: Object.assign({
        width
      }, style2)
    });
  };
  const Title$1 = Title;
  function getComponentProps(prop) {
    if (prop && typeof prop === "object") {
      return prop;
    }
    return {};
  }
  function getAvatarBasicProps(hasTitle, hasParagraph) {
    if (hasTitle && !hasParagraph) {
      return {
        size: "large",
        shape: "square"
      };
    }
    return {
      size: "large",
      shape: "circle"
    };
  }
  function getTitleBasicProps(hasAvatar, hasParagraph) {
    if (!hasAvatar && hasParagraph) {
      return {
        width: "38%"
      };
    }
    if (hasAvatar && hasParagraph) {
      return {
        width: "50%"
      };
    }
    return {};
  }
  function getParagraphBasicProps(hasAvatar, hasTitle) {
    const basicProps = {};
    if (!hasAvatar || !hasTitle) {
      basicProps.width = "61%";
    }
    if (!hasAvatar && hasTitle) {
      basicProps.rows = 3;
    } else {
      basicProps.rows = 2;
    }
    return basicProps;
  }
  const Skeleton = (props) => {
    const {
      prefixCls: customizePrefixCls,
      loading,
      className,
      rootClassName,
      style: style2,
      children,
      avatar = false,
      title = true,
      paragraph = true,
      active,
      round
    } = props;
    const {
      getPrefixCls,
      direction
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls("skeleton", customizePrefixCls);
    const [wrapSSR, hashId] = useStyle$1(prefixCls);
    if (loading || !("loading" in props)) {
      const hasAvatar = !!avatar;
      const hasTitle = !!title;
      const hasParagraph = !!paragraph;
      let avatarNode;
      if (hasAvatar) {
        const avatarProps = Object.assign(Object.assign({
          prefixCls: `${prefixCls}-avatar`
        }, getAvatarBasicProps(hasTitle, hasParagraph)), getComponentProps(avatar));
        avatarNode = /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${prefixCls}-header`
        }, /* @__PURE__ */ React__namespace.createElement(Element$2, Object.assign({}, avatarProps)));
      }
      let contentNode;
      if (hasTitle || hasParagraph) {
        let $title;
        if (hasTitle) {
          const titleProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-title`
          }, getTitleBasicProps(hasAvatar, hasParagraph)), getComponentProps(title));
          $title = /* @__PURE__ */ React__namespace.createElement(Title$1, Object.assign({}, titleProps));
        }
        let paragraphNode;
        if (hasParagraph) {
          const paragraphProps = Object.assign(Object.assign({
            prefixCls: `${prefixCls}-paragraph`
          }, getParagraphBasicProps(hasAvatar, hasTitle)), getComponentProps(paragraph));
          paragraphNode = /* @__PURE__ */ React__namespace.createElement(Paragraph$1, Object.assign({}, paragraphProps));
        }
        contentNode = /* @__PURE__ */ React__namespace.createElement("div", {
          className: `${prefixCls}-content`
        }, $title, paragraphNode);
      }
      const cls = classNames(prefixCls, {
        [`${prefixCls}-with-avatar`]: hasAvatar,
        [`${prefixCls}-active`]: active,
        [`${prefixCls}-rtl`]: direction === "rtl",
        [`${prefixCls}-round`]: round
      }, className, rootClassName, hashId);
      return wrapSSR(/* @__PURE__ */ React__namespace.createElement("div", {
        className: cls,
        style: style2
      }, avatarNode, contentNode));
    }
    return typeof children !== "undefined" ? children : null;
  };
  Skeleton.Button = SkeletonButton$1;
  Skeleton.Avatar = SkeletonAvatar$1;
  Skeleton.Input = SkeletonInput$1;
  Skeleton.Image = SkeletonImage$1;
  Skeleton.Node = SkeletonNode$1;
  const Skeleton$1 = Skeleton;
  var FileTextOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M854.6 288.6L639.4 73.4c-6-6-14.1-9.4-22.6-9.4H192c-17.7 0-32 14.3-32 32v832c0 17.7 14.3 32 32 32h640c17.7 0 32-14.3 32-32V311.3c0-8.5-3.4-16.7-9.4-22.7zM790.2 326H602V137.8L790.2 326zm1.8 562H232V136h302v216a42 42 0 0042 42h216v494zM504 618H320c-4.4 0-8 3.6-8 8v48c0 4.4 3.6 8 8 8h184c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8zM312 490v48c0 4.4 3.6 8 8 8h384c4.4 0 8-3.6 8-8v-48c0-4.4-3.6-8-8-8H320c-4.4 0-8 3.6-8 8z" } }] }, "name": "file-text", "theme": "outlined" };
  const FileTextOutlinedSvg = FileTextOutlined$2;
  var FileTextOutlined = function FileTextOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: FileTextOutlinedSvg
    }));
  };
  const FileTextOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(FileTextOutlined);
  const FloatButtonContent = (props) => {
    const {
      icon,
      description,
      prefixCls,
      className
    } = props;
    const defaultElement = /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-icon`
    }, /* @__PURE__ */ React.createElement(FileTextOutlined$1, null));
    return /* @__PURE__ */ React.createElement("div", {
      onClick: props.onClick,
      onFocus: props.onFocus,
      onMouseEnter: props.onMouseEnter,
      onMouseLeave: props.onMouseLeave,
      className: classNames(className, `${prefixCls}-content`)
    }, icon || description ? /* @__PURE__ */ React.createElement(React.Fragment, null, icon && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-icon`
    }, icon), description && /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-description`
    }, description)) : defaultElement);
  };
  const Content = /* @__PURE__ */ React.memo(FloatButtonContent);
  const FloatButtonGroupContext = /* @__PURE__ */ React.createContext(void 0);
  const {
    Provider: FloatButtonGroupProvider
  } = FloatButtonGroupContext;
  const FloatButtonGroupContext$1 = FloatButtonGroupContext;
  const getOffset = (radius) => {
    if (radius === 0) {
      return 0;
    }
    return radius - Math.sqrt(Math.pow(radius, 2) / 2);
  };
  const getOffset$1 = getOffset;
  const initFloatButtonGroupMotion = (token2) => {
    const {
      componentCls,
      floatButtonSize,
      motionDurationSlow,
      motionEaseInOutCirc
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    const moveDownIn = new Keyframe("antFloatButtonMoveDownIn", {
      "0%": {
        transform: `translate3d(0, ${floatButtonSize}px, 0)`,
        transformOrigin: "0 0",
        opacity: 0
      },
      "100%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      }
    });
    const moveDownOut = new Keyframe("antFloatButtonMoveDownOut", {
      "0%": {
        transform: "translate3d(0, 0, 0)",
        transformOrigin: "0 0",
        opacity: 1
      },
      "100%": {
        transform: `translate3d(0, ${floatButtonSize}px, 0)`,
        transformOrigin: "0 0",
        opacity: 0
      }
    });
    return [{
      [`${groupPrefixCls}-wrap`]: Object.assign({}, initMotion(`${groupPrefixCls}-wrap`, moveDownIn, moveDownOut, motionDurationSlow, true))
    }, {
      [`${groupPrefixCls}-wrap`]: {
        [`
          &${groupPrefixCls}-wrap-enter,
          &${groupPrefixCls}-wrap-appear
        `]: {
          opacity: 0,
          animationTimingFunction: motionEaseInOutCirc
        },
        [`&${groupPrefixCls}-wrap-leave`]: {
          animationTimingFunction: motionEaseInOutCirc
        }
      }
    }];
  };
  const floatButtonGroupStyle = (token2) => {
    const {
      antCls,
      componentCls,
      floatButtonSize,
      margin,
      borderRadiusLG,
      borderRadiusSM,
      badgeOffset,
      floatButtonBodyPadding
    } = token2;
    const groupPrefixCls = `${componentCls}-group`;
    return {
      [groupPrefixCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        zIndex: 99,
        display: "block",
        border: "none",
        position: "fixed",
        width: floatButtonSize,
        height: "auto",
        boxShadow: "none",
        minHeight: floatButtonSize,
        insetInlineEnd: token2.floatButtonInsetInlineEnd,
        insetBlockEnd: token2.floatButtonInsetBlockEnd,
        borderRadius: borderRadiusLG,
        [`${groupPrefixCls}-wrap`]: {
          zIndex: -1,
          display: "block",
          position: "relative",
          marginBottom: margin
        },
        [`&${groupPrefixCls}-rtl`]: {
          direction: "rtl"
        },
        [componentCls]: {
          position: "static"
        }
      }),
      [`${groupPrefixCls}-circle`]: {
        [`${componentCls}-circle:not(:last-child)`]: {
          marginBottom: token2.margin,
          [`${componentCls}-body`]: {
            width: floatButtonSize,
            height: floatButtonSize,
            borderRadius: "50%"
          }
        }
      },
      [`${groupPrefixCls}-square`]: {
        [`${componentCls}-square`]: {
          borderRadius: 0,
          padding: 0,
          "&:first-child": {
            borderStartStartRadius: borderRadiusLG,
            borderStartEndRadius: borderRadiusLG
          },
          "&:last-child": {
            borderEndStartRadius: borderRadiusLG,
            borderEndEndRadius: borderRadiusLG
          },
          "&:not(:last-child)": {
            borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
          },
          [`${antCls}-badge`]: {
            [`${antCls}-badge-count`]: {
              top: -(floatButtonBodyPadding + badgeOffset),
              insetInlineEnd: -(floatButtonBodyPadding + badgeOffset)
            }
          }
        },
        [`${groupPrefixCls}-wrap`]: {
          display: "block",
          borderRadius: borderRadiusLG,
          boxShadow: token2.boxShadowSecondary,
          [`${componentCls}-square`]: {
            boxShadow: "none",
            marginTop: 0,
            borderRadius: 0,
            padding: floatButtonBodyPadding,
            "&:first-child": {
              borderStartStartRadius: borderRadiusLG,
              borderStartEndRadius: borderRadiusLG
            },
            "&:last-child": {
              borderEndStartRadius: borderRadiusLG,
              borderEndEndRadius: borderRadiusLG
            },
            "&:not(:last-child)": {
              borderBottom: `${token2.lineWidth}px ${token2.lineType} ${token2.colorSplit}`
            },
            [`${componentCls}-body`]: {
              width: token2.floatButtonBodySize,
              height: token2.floatButtonBodySize
            }
          }
        }
      },
      [`${groupPrefixCls}-circle-shadow`]: {
        boxShadow: "none"
      },
      [`${groupPrefixCls}-square-shadow`]: {
        boxShadow: token2.boxShadowSecondary,
        [`${componentCls}-square`]: {
          boxShadow: "none",
          padding: floatButtonBodyPadding,
          [`${componentCls}-body`]: {
            width: token2.floatButtonBodySize,
            height: token2.floatButtonBodySize,
            borderRadius: borderRadiusSM
          }
        }
      }
    };
  };
  const sharedFloatButtonStyle = (token2) => {
    const {
      antCls,
      componentCls,
      floatButtonBodyPadding,
      floatButtonIconSize,
      floatButtonSize,
      borderRadiusLG,
      badgeOffset,
      dotOffsetInSquare,
      dotOffsetInCircle
    } = token2;
    return {
      [componentCls]: Object.assign(Object.assign({}, resetComponent(token2)), {
        border: "none",
        position: "fixed",
        cursor: "pointer",
        zIndex: 99,
        display: "block",
        justifyContent: "center",
        alignItems: "center",
        width: floatButtonSize,
        height: floatButtonSize,
        insetInlineEnd: token2.floatButtonInsetInlineEnd,
        insetBlockEnd: token2.floatButtonInsetBlockEnd,
        boxShadow: token2.boxShadowSecondary,
        // Pure Panel
        "&-pure": {
          position: "relative",
          inset: "auto"
        },
        "&:empty": {
          display: "none"
        },
        [`${antCls}-badge`]: {
          width: "100%",
          height: "100%",
          [`${antCls}-badge-count`]: {
            transform: "translate(0, 0)",
            transformOrigin: "center",
            top: -badgeOffset,
            insetInlineEnd: -badgeOffset
          }
        },
        [`${componentCls}-body`]: {
          width: "100%",
          height: "100%",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          transition: `all ${token2.motionDurationMid}`,
          [`${componentCls}-content`]: {
            overflow: "hidden",
            textAlign: "center",
            minHeight: floatButtonSize,
            display: "flex",
            flexDirection: "column",
            justifyContent: "center",
            alignItems: "center",
            padding: `${floatButtonBodyPadding / 2}px ${floatButtonBodyPadding}px`,
            [`${componentCls}-icon`]: {
              textAlign: "center",
              margin: "auto",
              width: floatButtonIconSize,
              fontSize: floatButtonIconSize,
              lineHeight: 1
            }
          }
        }
      }),
      [`${componentCls}-rtl`]: {
        direction: "rtl"
      },
      [`${componentCls}-circle`]: {
        height: floatButtonSize,
        borderRadius: "50%",
        [`${antCls}-badge`]: {
          [`${antCls}-badge-dot`]: {
            top: dotOffsetInCircle,
            insetInlineEnd: dotOffsetInCircle
          }
        },
        [`${componentCls}-body`]: {
          borderRadius: "50%"
        }
      },
      [`${componentCls}-square`]: {
        height: "auto",
        minHeight: floatButtonSize,
        borderRadius: borderRadiusLG,
        [`${antCls}-badge`]: {
          [`${antCls}-badge-dot`]: {
            top: dotOffsetInSquare,
            insetInlineEnd: dotOffsetInSquare
          }
        },
        [`${componentCls}-body`]: {
          height: "auto",
          borderRadius: borderRadiusLG
        }
      },
      [`${componentCls}-default`]: {
        backgroundColor: token2.floatButtonBackgroundColor,
        transition: `background-color ${token2.motionDurationMid}`,
        [`${componentCls}-body`]: {
          backgroundColor: token2.floatButtonBackgroundColor,
          transition: `background-color ${token2.motionDurationMid}`,
          "&:hover": {
            backgroundColor: token2.colorFillContent
          },
          [`${componentCls}-content`]: {
            [`${componentCls}-icon`]: {
              color: token2.colorText
            },
            [`${componentCls}-description`]: {
              display: "flex",
              alignItems: "center",
              lineHeight: `${token2.fontSizeLG}px`,
              color: token2.colorText,
              fontSize: token2.fontSizeSM
            }
          }
        }
      },
      [`${componentCls}-primary`]: {
        backgroundColor: token2.colorPrimary,
        [`${componentCls}-body`]: {
          backgroundColor: token2.colorPrimary,
          transition: `background-color ${token2.motionDurationMid}`,
          "&:hover": {
            backgroundColor: token2.colorPrimaryHover
          },
          [`${componentCls}-content`]: {
            [`${componentCls}-icon`]: {
              color: token2.colorTextLightSolid
            },
            [`${componentCls}-description`]: {
              display: "flex",
              alignItems: "center",
              lineHeight: `${token2.fontSizeLG}px`,
              color: token2.colorTextLightSolid,
              fontSize: token2.fontSizeSM
            }
          }
        }
      }
    };
  };
  const useStyle = genComponentStyleHook("FloatButton", (token2) => {
    const {
      colorTextLightSolid,
      colorBgElevated,
      controlHeightLG,
      marginXXL,
      marginLG,
      fontSize,
      fontSizeIcon,
      controlItemBgHover,
      paddingXXS,
      borderRadiusLG
    } = token2;
    const floatButtonToken = merge$1(token2, {
      floatButtonBackgroundColor: colorBgElevated,
      floatButtonColor: colorTextLightSolid,
      floatButtonHoverBackgroundColor: controlItemBgHover,
      floatButtonFontSize: fontSize,
      floatButtonIconSize: fontSizeIcon * 1.5,
      floatButtonSize: controlHeightLG,
      floatButtonInsetBlockEnd: marginXXL,
      floatButtonInsetInlineEnd: marginLG,
      floatButtonBodySize: controlHeightLG - paddingXXS * 2,
      // 这里的 paddingXXS 是简写，完整逻辑是 (controlHeightLG - (controlHeightLG - paddingXXS * 2)) / 2,
      floatButtonBodyPadding: paddingXXS,
      badgeOffset: paddingXXS * 1.5,
      dotOffsetInCircle: getOffset$1(controlHeightLG / 2),
      dotOffsetInSquare: getOffset$1(borderRadiusLG)
    });
    return [floatButtonGroupStyle(floatButtonToken), sharedFloatButtonStyle(floatButtonToken), initFadeMotion(token2), initFloatButtonGroupMotion(floatButtonToken)];
  });
  var __rest$3 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const floatButtonPrefixCls = "float-btn";
  const FloatButton = (props, ref) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      rootClassName,
      type: type4 = "default",
      shape = "circle",
      icon,
      description,
      tooltip,
      badge = {}
    } = props, restProps = __rest$3(props, ["prefixCls", "className", "rootClassName", "type", "shape", "icon", "description", "tooltip", "badge"]);
    const {
      getPrefixCls,
      direction
    } = React.useContext(ConfigContext);
    const groupShape = React.useContext(FloatButtonGroupContext$1);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const [wrapSSR, hashId] = useStyle(prefixCls);
    const mergeShape = groupShape || shape;
    const classString = classNames(hashId, prefixCls, className, rootClassName, `${prefixCls}-${type4}`, `${prefixCls}-${mergeShape}`, {
      [`${prefixCls}-rtl`]: direction === "rtl"
    });
    const badgeProps = React.useMemo(() => omit(badge, ["title", "children", "status", "text"]), [badge]);
    const contentProps = React.useMemo(() => ({
      prefixCls,
      description,
      icon,
      type: type4
    }), [prefixCls, description, icon, type4]);
    const buttonNode = /* @__PURE__ */ React.createElement(Tooltip$1, {
      title: tooltip,
      placement: direction === "rtl" ? "right" : "left"
    }, /* @__PURE__ */ React.createElement(Badge$1, Object.assign({}, badgeProps), /* @__PURE__ */ React.createElement("div", {
      className: `${prefixCls}-body`
    }, /* @__PURE__ */ React.createElement(Content, Object.assign({}, contentProps)))));
    return wrapSSR(props.href ? /* @__PURE__ */ React.createElement("a", Object.assign({
      ref
    }, restProps, {
      className: classString
    }), buttonNode) : /* @__PURE__ */ React.createElement("button", Object.assign({
      ref
    }, restProps, {
      className: classString,
      type: "button"
    }), buttonNode));
  };
  const ForwardFloatButton = /* @__PURE__ */ React.forwardRef(FloatButton);
  const FloatButton$1 = ForwardFloatButton;
  const FloatButtonGroup = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      style: style2,
      shape = "circle",
      type: type4 = "default",
      icon = /* @__PURE__ */ React.createElement(FileTextOutlined$1, null),
      closeIcon = /* @__PURE__ */ React.createElement(CloseOutlined$1, null),
      description,
      trigger,
      children,
      onOpenChange
    } = props;
    const {
      direction,
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const [wrapSSR, hashId] = useStyle(prefixCls);
    const groupPrefixCls = `${prefixCls}-group`;
    const groupCls = classNames(groupPrefixCls, hashId, className, {
      [`${groupPrefixCls}-rtl`]: direction === "rtl",
      [`${groupPrefixCls}-${shape}`]: shape,
      [`${groupPrefixCls}-${shape}-shadow`]: !trigger
    });
    const wrapperCls = classNames(hashId, `${groupPrefixCls}-wrap`);
    const [open, setOpen] = useMergedState(false, {
      value: props.open
    });
    const floatButtonGroupRef = React.useRef(null);
    const floatButtonRef = React.useRef(null);
    const hoverAction = React.useMemo(() => {
      const hoverTypeAction = {
        onMouseEnter() {
          setOpen(true);
          onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(true);
        },
        onMouseLeave() {
          setOpen(false);
          onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
        }
      };
      return trigger === "hover" ? hoverTypeAction : {};
    }, [trigger]);
    const handleOpenChange = () => {
      setOpen((prevState) => {
        onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(!prevState);
        return !prevState;
      });
    };
    const onClick = React.useCallback((e2) => {
      var _a2, _b;
      if ((_a2 = floatButtonGroupRef.current) === null || _a2 === void 0 ? void 0 : _a2.contains(e2.target)) {
        if ((_b = floatButtonRef.current) === null || _b === void 0 ? void 0 : _b.contains(e2.target)) {
          handleOpenChange();
        }
        return;
      }
      setOpen(false);
      onOpenChange === null || onOpenChange === void 0 ? void 0 : onOpenChange(false);
    }, [trigger]);
    React.useEffect(() => {
      if (trigger === "click") {
        document.addEventListener("click", onClick);
        return () => {
          document.removeEventListener("click", onClick);
        };
      }
    }, [trigger]);
    return wrapSSR(/* @__PURE__ */ React.createElement(FloatButtonGroupProvider, {
      value: shape
    }, /* @__PURE__ */ React.createElement("div", Object.assign({
      ref: floatButtonGroupRef,
      className: groupCls,
      style: style2
    }, hoverAction), trigger && ["click", "hover"].includes(trigger) ? /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement(CSSMotion, {
      visible: open,
      motionName: `${groupPrefixCls}-wrap`
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React.createElement("div", {
        className: classNames(motionClassName, wrapperCls)
      }, children);
    }), /* @__PURE__ */ React.createElement(FloatButton$1, {
      ref: floatButtonRef,
      type: type4,
      shape,
      icon: open ? closeIcon : icon,
      description
    })) : children)));
  };
  const FloatButtonGroup$1 = /* @__PURE__ */ React.memo(FloatButtonGroup);
  var __rest$2 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const BackTop = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      type: type4 = "default",
      shape = "circle",
      visibilityHeight = 400,
      icon = /* @__PURE__ */ React.createElement(VerticalAlignTopOutlined$1, null),
      target,
      onClick,
      duration = 450
    } = props, restProps = __rest$2(props, ["prefixCls", "className", "type", "shape", "visibilityHeight", "icon", "target", "onClick", "duration"]);
    const [visible, setVisible] = React.useState(visibilityHeight === 0);
    const ref = React.useRef(null);
    const getDefaultTarget = () => ref.current && ref.current.ownerDocument ? ref.current.ownerDocument : window;
    const handleScroll = throttleByAnimationFrame((e2) => {
      const scrollTop = getScroll$1(e2.target, true);
      setVisible(scrollTop >= visibilityHeight);
    });
    React.useEffect(() => {
      const getTarget = target || getDefaultTarget;
      const container = getTarget();
      handleScroll({
        target: container
      });
      container === null || container === void 0 ? void 0 : container.addEventListener("scroll", handleScroll);
      return () => {
        handleScroll.cancel();
        container === null || container === void 0 ? void 0 : container.removeEventListener("scroll", handleScroll);
      };
    }, [target]);
    const scrollToTop = (e2) => {
      scrollTo(0, {
        getContainer: target || getDefaultTarget,
        duration
      });
      onClick === null || onClick === void 0 ? void 0 : onClick(e2);
    };
    const {
      getPrefixCls
    } = React.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const rootPrefixCls = getPrefixCls();
    const [wrapSSR] = useStyle(prefixCls);
    const groupShape = React.useContext(FloatButtonGroupContext$1);
    const mergeShape = groupShape || shape;
    const contentProps = Object.assign({
      prefixCls,
      icon,
      type: type4,
      shape: mergeShape
    }, restProps);
    return wrapSSR(/* @__PURE__ */ React.createElement(CSSMotion, {
      visible,
      motionName: `${rootPrefixCls}-fade`
    }, (_ref) => {
      let {
        className: motionClassName
      } = _ref;
      return /* @__PURE__ */ React.createElement(FloatButton$1, Object.assign({
        ref
      }, contentProps, {
        onClick: scrollToTop,
        className: classNames(className, motionClassName)
      }));
    }));
  };
  const BackTop$1 = /* @__PURE__ */ React.memo(BackTop);
  var __rest$1 = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const PureFloatButton = (_a2) => {
    var {
      backTop
    } = _a2, props = __rest$1(_a2, ["backTop"]);
    return backTop ? /* @__PURE__ */ React__namespace.createElement(BackTop$1, Object.assign({}, props, {
      visibilityHeight: 0
    })) : /* @__PURE__ */ React__namespace.createElement(FloatButton$1, Object.assign({}, props));
  };
  function PurePanel$2(_a2) {
    var {
      className,
      items
    } = _a2, props = __rest$1(_a2, ["className", "items"]);
    const {
      prefixCls: customizePrefixCls
    } = props;
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const prefixCls = getPrefixCls(floatButtonPrefixCls, customizePrefixCls);
    const pureCls = `${prefixCls}-pure`;
    if (items) {
      return /* @__PURE__ */ React__namespace.createElement(FloatButtonGroup$1, Object.assign({
        className: classNames(className, pureCls)
      }, props), items.map((item, index2) => /* @__PURE__ */ React__namespace.createElement(PureFloatButton, Object.assign({
        key: index2
      }, item))));
    }
    return /* @__PURE__ */ React__namespace.createElement(PureFloatButton, Object.assign({
      className: classNames(className, pureCls)
    }, props));
  }
  const PurePanel$3 = /* @__PURE__ */ React__namespace.memo(PurePanel$2);
  FloatButton$1.BackTop = BackTop$1;
  FloatButton$1.Group = FloatButtonGroup$1;
  FloatButton$1._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$3;
  var __rest = globalThis && globalThis.__rest || function(s, e2) {
    var t2 = {};
    for (var p2 in s)
      if (Object.prototype.hasOwnProperty.call(s, p2) && e2.indexOf(p2) < 0)
        t2[p2] = s[p2];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
        if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
          t2[p2[i]] = s[p2[i]];
      }
    return t2;
  };
  const PurePanel = (props) => {
    const {
      prefixCls: customizePrefixCls,
      className,
      closeIcon,
      closable,
      type: type4,
      title,
      children
    } = props, restProps = __rest(props, ["prefixCls", "className", "closeIcon", "closable", "type", "title", "children"]);
    const {
      getPrefixCls
    } = React__namespace.useContext(ConfigContext);
    const rootPrefixCls = getPrefixCls();
    const prefixCls = customizePrefixCls || getPrefixCls("modal");
    const [, hashId] = useStyle$5(prefixCls);
    const confirmPrefixCls = `${prefixCls}-confirm`;
    let additionalProps = {};
    if (type4) {
      additionalProps = {
        closable: closable !== null && closable !== void 0 ? closable : false,
        title: "",
        footer: "",
        children: /* @__PURE__ */ React__namespace.createElement(ConfirmContent, Object.assign({}, props, {
          confirmPrefixCls,
          rootPrefixCls,
          content: children
        }))
      };
    } else {
      additionalProps = {
        closable: closable !== null && closable !== void 0 ? closable : true,
        title,
        footer: props.footer === void 0 ? /* @__PURE__ */ React__namespace.createElement(Footer, Object.assign({}, props)) : props.footer,
        children
      };
    }
    return /* @__PURE__ */ React__namespace.createElement(Panel, Object.assign({
      prefixCls,
      className: classNames(hashId, `${prefixCls}-pure-panel`, type4 && confirmPrefixCls, type4 && `${confirmPrefixCls}-${type4}`, className)
    }, restProps, {
      closeIcon: renderCloseIcon(prefixCls, closeIcon),
      closable
    }, additionalProps));
  };
  const PurePanel$1 = PurePanel;
  function modalWarn(props) {
    return confirm(withWarn(props));
  }
  const Modal = OriginModal;
  Modal.useModal = useModal;
  Modal.info = function infoFn(props) {
    return confirm(withInfo(props));
  };
  Modal.success = function successFn(props) {
    return confirm(withSuccess(props));
  };
  Modal.error = function errorFn(props) {
    return confirm(withError(props));
  };
  Modal.warning = modalWarn;
  Modal.warn = modalWarn;
  Modal.confirm = function confirmFn(props) {
    return confirm(withConfirm(props));
  };
  Modal.destroyAll = function destroyAllFn() {
    while (destroyFns$1.length) {
      const close = destroyFns$1.pop();
      if (close) {
        close();
      }
    }
  };
  Modal.config = modalGlobalConfig;
  Modal._InternalPanelDoNotUseOrYouWillBeFired = PurePanel$1;
  const Modal$1 = Modal;
  var SlidersOutlined$2 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M320 224h-66v-56c0-4.4-3.6-8-8-8h-52c-4.4 0-8 3.6-8 8v56h-66c-4.4 0-8 3.6-8 8v560c0 4.4 3.6 8 8 8h66v56c0 4.4 3.6 8 8 8h52c4.4 0 8-3.6 8-8v-56h66c4.4 0 8-3.6 8-8V232c0-4.4-3.6-8-8-8zm-60 508h-80V292h80v440zm644-436h-66v-96c0-4.4-3.6-8-8-8h-52c-4.4 0-8 3.6-8 8v96h-66c-4.4 0-8 3.6-8 8v416c0 4.4 3.6 8 8 8h66v96c0 4.4 3.6 8 8 8h52c4.4 0 8-3.6 8-8v-96h66c4.4 0 8-3.6 8-8V304c0-4.4-3.6-8-8-8zm-60 364h-80V364h80v296zM612 404h-66V232c0-4.4-3.6-8-8-8h-52c-4.4 0-8 3.6-8 8v172h-66c-4.4 0-8 3.6-8 8v200c0 4.4 3.6 8 8 8h66v172c0 4.4 3.6 8 8 8h52c4.4 0 8-3.6 8-8V620h66c4.4 0 8-3.6 8-8V412c0-4.4-3.6-8-8-8zm-60 145a3 3 0 01-3 3h-74a3 3 0 01-3-3v-74a3 3 0 013-3h74a3 3 0 013 3v74z" } }] }, "name": "sliders", "theme": "outlined" };
  const SlidersOutlinedSvg = SlidersOutlined$2;
  var SlidersOutlined = function SlidersOutlined2(props, ref) {
    return /* @__PURE__ */ React__namespace.createElement(AntdIcon, _extends$2({}, props, {
      ref,
      icon: SlidersOutlinedSvg
    }));
  };
  const SlidersOutlined$1 = /* @__PURE__ */ React__namespace.forwardRef(SlidersOutlined);
  function die(error) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    throw new Error(typeof error === "number" ? "[MobX] minified error nr: " + error + (args.length ? " " + args.map(String).join(",") : "") + ". Find the full error at: https://github.com/mobxjs/mobx/blob/main/packages/mobx/src/errors.ts" : "[MobX] " + error);
  }
  var mockGlobal = {};
  function getGlobal() {
    if (typeof globalThis !== "undefined") {
      return globalThis;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    if (typeof self !== "undefined") {
      return self;
    }
    return mockGlobal;
  }
  var assign = Object.assign;
  var getDescriptor = Object.getOwnPropertyDescriptor;
  var defineProperty = Object.defineProperty;
  var objectPrototype = Object.prototype;
  var EMPTY_ARRAY = [];
  Object.freeze(EMPTY_ARRAY);
  var EMPTY_OBJECT = {};
  Object.freeze(EMPTY_OBJECT);
  var hasProxy = typeof Proxy !== "undefined";
  var plainObjectString = /* @__PURE__ */ Object.toString();
  function assertProxies() {
    if (!hasProxy) {
      die("Proxy not available");
    }
  }
  function once(func) {
    var invoked = false;
    return function() {
      if (invoked) {
        return;
      }
      invoked = true;
      return func.apply(this, arguments);
    };
  }
  var noop$1 = function noop() {
  };
  function isFunction$2(fn) {
    return typeof fn === "function";
  }
  function isStringish(value) {
    var t2 = typeof value;
    switch (t2) {
      case "string":
      case "symbol":
      case "number":
        return true;
    }
    return false;
  }
  function isObject$1(value) {
    return value !== null && typeof value === "object";
  }
  function isPlainObject$1(value) {
    if (!isObject$1(value)) {
      return false;
    }
    var proto = Object.getPrototypeOf(value);
    if (proto == null) {
      return true;
    }
    var protoConstructor = Object.hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof protoConstructor === "function" && protoConstructor.toString() === plainObjectString;
  }
  function isGenerator(obj) {
    var constructor = obj == null ? void 0 : obj.constructor;
    if (!constructor) {
      return false;
    }
    if ("GeneratorFunction" === constructor.name || "GeneratorFunction" === constructor.displayName) {
      return true;
    }
    return false;
  }
  function addHiddenProp(object5, propName, value) {
    defineProperty(object5, propName, {
      enumerable: false,
      writable: true,
      configurable: true,
      value
    });
  }
  function addHiddenFinalProp(object5, propName, value) {
    defineProperty(object5, propName, {
      enumerable: false,
      writable: false,
      configurable: true,
      value
    });
  }
  function createInstanceofPredicate(name, theClass) {
    var propName = "isMobX" + name;
    theClass.prototype[propName] = true;
    return function(x2) {
      return isObject$1(x2) && x2[propName] === true;
    };
  }
  function isES6Map(thing) {
    return thing instanceof Map;
  }
  function isES6Set(thing) {
    return thing instanceof Set;
  }
  var hasGetOwnPropertySymbols = typeof Object.getOwnPropertySymbols !== "undefined";
  function getPlainObjectKeys(object5) {
    var keys2 = Object.keys(object5);
    if (!hasGetOwnPropertySymbols) {
      return keys2;
    }
    var symbols = Object.getOwnPropertySymbols(object5);
    if (!symbols.length) {
      return keys2;
    }
    return [].concat(keys2, symbols.filter(function(s) {
      return objectPrototype.propertyIsEnumerable.call(object5, s);
    }));
  }
  var ownKeys = typeof Reflect !== "undefined" && Reflect.ownKeys ? Reflect.ownKeys : hasGetOwnPropertySymbols ? function(obj) {
    return Object.getOwnPropertyNames(obj).concat(Object.getOwnPropertySymbols(obj));
  } : (
    /* istanbul ignore next */
    Object.getOwnPropertyNames
  );
  function toPrimitive(value) {
    return value === null ? null : typeof value === "object" ? "" + value : value;
  }
  function hasProp(target, prop) {
    return objectPrototype.hasOwnProperty.call(target, prop);
  }
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(target) {
    var res = {};
    ownKeys(target).forEach(function(key) {
      res[key] = getDescriptor(target, key);
    });
    return res;
  };
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
      writable: false
    });
    return Constructor;
  }
  function _extends() {
    _extends = Object.assign ? Object.assign.bind() : function(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    return _extends.apply(this, arguments);
  }
  function _inheritsLoose(subClass, superClass) {
    subClass.prototype = Object.create(superClass.prototype);
    subClass.prototype.constructor = subClass;
    _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p2) {
    _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
      o2.__proto__ = p3;
      return o2;
    };
    return _setPrototypeOf(o, p2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _unsupportedIterableToArray(o, minLen) {
    if (!o)
      return;
    if (typeof o === "string")
      return _arrayLikeToArray(o, minLen);
    var n2 = Object.prototype.toString.call(o).slice(8, -1);
    if (n2 === "Object" && o.constructor)
      n2 = o.constructor.name;
    if (n2 === "Map" || n2 === "Set")
      return Array.from(o);
    if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
      return _arrayLikeToArray(o, minLen);
  }
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i = 0, arr2 = new Array(len); i < len; i++)
      arr2[i] = arr[i];
    return arr2;
  }
  function _createForOfIteratorHelperLoose(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it)
      return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i = 0;
      return function() {
        if (i >= o.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _toPrimitive(input, hint) {
    if (typeof input !== "object" || input === null)
      return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== void 0) {
      var res = prim.call(input, hint || "default");
      if (typeof res !== "object")
        return res;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
  }
  function _toPropertyKey(arg) {
    var key = _toPrimitive(arg, "string");
    return typeof key === "symbol" ? key : String(key);
  }
  var storedAnnotationsSymbol = /* @__PURE__ */ Symbol("mobx-stored-annotations");
  function createDecoratorAnnotation(annotation) {
    function decorator(target, property) {
      storeAnnotation(target, property, annotation);
    }
    return Object.assign(decorator, annotation);
  }
  function storeAnnotation(prototype2, key, annotation) {
    if (!hasProp(prototype2, storedAnnotationsSymbol)) {
      addHiddenProp(prototype2, storedAnnotationsSymbol, _extends({}, prototype2[storedAnnotationsSymbol]));
    }
    if (!isOverride(annotation)) {
      prototype2[storedAnnotationsSymbol][key] = annotation;
    }
  }
  function collectStoredAnnotations(target) {
    if (!hasProp(target, storedAnnotationsSymbol)) {
      addHiddenProp(target, storedAnnotationsSymbol, _extends({}, target[storedAnnotationsSymbol]));
    }
    return target[storedAnnotationsSymbol];
  }
  var $mobx = /* @__PURE__ */ Symbol("mobx administration");
  var Atom = /* @__PURE__ */ function() {
    function Atom2(name_) {
      if (name_ === void 0) {
        name_ = "Atom";
      }
      this.name_ = void 0;
      this.isPendingUnobservation_ = false;
      this.isBeingObserved_ = false;
      this.observers_ = /* @__PURE__ */ new Set();
      this.diffValue_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.NOT_TRACKING_;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      this.name_ = name_;
    }
    var _proto = Atom2.prototype;
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.reportObserved = function reportObserved$1() {
      return reportObserved(this);
    };
    _proto.reportChanged = function reportChanged() {
      startBatch();
      propagateChanged(this);
      globalState.stateVersion = globalState.stateVersion < Number.MAX_SAFE_INTEGER ? globalState.stateVersion + 1 : Number.MIN_SAFE_INTEGER;
      endBatch();
    };
    _proto.toString = function toString3() {
      return this.name_;
    };
    return Atom2;
  }();
  var isAtom = /* @__PURE__ */ createInstanceofPredicate("Atom", Atom);
  function createAtom(name, onBecomeObservedHandler, onBecomeUnobservedHandler) {
    if (onBecomeObservedHandler === void 0) {
      onBecomeObservedHandler = noop$1;
    }
    if (onBecomeUnobservedHandler === void 0) {
      onBecomeUnobservedHandler = noop$1;
    }
    var atom = new Atom(name);
    if (onBecomeObservedHandler !== noop$1) {
      onBecomeObserved(atom, onBecomeObservedHandler);
    }
    if (onBecomeUnobservedHandler !== noop$1) {
      onBecomeUnobserved(atom, onBecomeUnobservedHandler);
    }
    return atom;
  }
  function identityComparer(a, b2) {
    return a === b2;
  }
  function structuralComparer(a, b2) {
    return deepEqual(a, b2);
  }
  function shallowComparer(a, b2) {
    return deepEqual(a, b2, 1);
  }
  function defaultComparer(a, b2) {
    if (Object.is) {
      return Object.is(a, b2);
    }
    return a === b2 ? a !== 0 || 1 / a === 1 / b2 : a !== a && b2 !== b2;
  }
  var comparer = {
    identity: identityComparer,
    structural: structuralComparer,
    "default": defaultComparer,
    shallow: shallowComparer
  };
  function deepEnhancer(v2, _2, name) {
    if (isObservable(v2)) {
      return v2;
    }
    if (Array.isArray(v2)) {
      return observable.array(v2, {
        name
      });
    }
    if (isPlainObject$1(v2)) {
      return observable.object(v2, void 0, {
        name
      });
    }
    if (isES6Map(v2)) {
      return observable.map(v2, {
        name
      });
    }
    if (isES6Set(v2)) {
      return observable.set(v2, {
        name
      });
    }
    if (typeof v2 === "function" && !isAction(v2) && !isFlow(v2)) {
      if (isGenerator(v2)) {
        return flow(v2);
      } else {
        return autoAction(name, v2);
      }
    }
    return v2;
  }
  function shallowEnhancer(v2, _2, name) {
    if (v2 === void 0 || v2 === null) {
      return v2;
    }
    if (isObservableObject(v2) || isObservableArray(v2) || isObservableMap(v2) || isObservableSet(v2)) {
      return v2;
    }
    if (Array.isArray(v2)) {
      return observable.array(v2, {
        name,
        deep: false
      });
    }
    if (isPlainObject$1(v2)) {
      return observable.object(v2, void 0, {
        name,
        deep: false
      });
    }
    if (isES6Map(v2)) {
      return observable.map(v2, {
        name,
        deep: false
      });
    }
    if (isES6Set(v2)) {
      return observable.set(v2, {
        name,
        deep: false
      });
    }
  }
  function referenceEnhancer(newValue) {
    return newValue;
  }
  function refStructEnhancer(v2, oldValue) {
    if (deepEqual(v2, oldValue)) {
      return oldValue;
    }
    return v2;
  }
  var OVERRIDE = "override";
  function isOverride(annotation) {
    return annotation.annotationType_ === OVERRIDE;
  }
  function createActionAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$1,
      extend_: extend_$1
    };
  }
  function make_$1(adm, key, descriptor, source) {
    var _this$options_;
    if ((_this$options_ = this.options_) != null && _this$options_.bound) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
    }
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if (isAction(descriptor.value)) {
      return 1;
    }
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor, false);
    defineProperty(source, key, actionDescriptor);
    return 2;
  }
  function extend_$1(adm, key, descriptor, proxyTrap) {
    var actionDescriptor = createActionDescriptor(adm, this, key, descriptor);
    return adm.defineProperty_(key, actionDescriptor, proxyTrap);
  }
  function assertActionDescriptor(adm, _ref, key, _ref2) {
    _ref.annotationType_;
    _ref2.value;
  }
  function createActionDescriptor(adm, annotation, key, descriptor, safeDescriptors) {
    var _annotation$options_, _annotation$options_$, _annotation$options_2, _annotation$options_$2, _annotation$options_3, _annotation$options_4, _adm$proxy_2;
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertActionDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if ((_annotation$options_ = annotation.options_) != null && _annotation$options_.bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return {
      value: createAction(
        (_annotation$options_$ = (_annotation$options_2 = annotation.options_) == null ? void 0 : _annotation$options_2.name) != null ? _annotation$options_$ : key.toString(),
        value,
        (_annotation$options_$2 = (_annotation$options_3 = annotation.options_) == null ? void 0 : _annotation$options_3.autoAction) != null ? _annotation$options_$2 : false,
        // https://github.com/mobxjs/mobx/discussions/3140
        (_annotation$options_4 = annotation.options_) != null && _annotation$options_4.bound ? (_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_ : void 0
      ),
      // Non-configurable for classes
      // prevents accidental field redefinition in subclass
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
      enumerable: false,
      // Non-obsevable, therefore non-writable
      // Also prevents rewriting in subclass constructor
      writable: safeDescriptors ? false : true
    };
  }
  function createFlowAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$2,
      extend_: extend_$2
    };
  }
  function make_$2(adm, key, descriptor, source) {
    var _this$options_;
    if (source === adm.target_) {
      return this.extend_(adm, key, descriptor, false) === null ? 0 : 2;
    }
    if ((_this$options_ = this.options_) != null && _this$options_.bound && (!hasProp(adm.target_, key) || !isFlow(adm.target_[key]))) {
      if (this.extend_(adm, key, descriptor, false) === null) {
        return 0;
      }
    }
    if (isFlow(descriptor.value)) {
      return 1;
    }
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, false, false);
    defineProperty(source, key, flowDescriptor);
    return 2;
  }
  function extend_$2(adm, key, descriptor, proxyTrap) {
    var _this$options_2;
    var flowDescriptor = createFlowDescriptor(adm, this, key, descriptor, (_this$options_2 = this.options_) == null ? void 0 : _this$options_2.bound);
    return adm.defineProperty_(key, flowDescriptor, proxyTrap);
  }
  function assertFlowDescriptor(adm, _ref, key, _ref2) {
    _ref.annotationType_;
    _ref2.value;
  }
  function createFlowDescriptor(adm, annotation, key, descriptor, bound, safeDescriptors) {
    if (safeDescriptors === void 0) {
      safeDescriptors = globalState.safeDescriptors;
    }
    assertFlowDescriptor(adm, annotation, key, descriptor);
    var value = descriptor.value;
    if (!isFlow(value)) {
      value = flow(value);
    }
    if (bound) {
      var _adm$proxy_;
      value = value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
      value.isMobXFlow = true;
    }
    return {
      value,
      // Non-configurable for classes
      // prevents accidental field redefinition in subclass
      configurable: safeDescriptors ? adm.isPlainObject_ : true,
      // https://github.com/mobxjs/mobx/pull/2641#issuecomment-737292058
      enumerable: false,
      // Non-obsevable, therefore non-writable
      // Also prevents rewriting in subclass constructor
      writable: safeDescriptors ? false : true
    };
  }
  function createComputedAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$3,
      extend_: extend_$3
    };
  }
  function make_$3(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$3(adm, key, descriptor, proxyTrap) {
    assertComputedDescriptor(adm, this, key, descriptor);
    return adm.defineComputedProperty_(key, _extends({}, this.options_, {
      get: descriptor.get,
      set: descriptor.set
    }), proxyTrap);
  }
  function assertComputedDescriptor(adm, _ref, key, _ref2) {
    _ref.annotationType_;
    _ref2.get;
  }
  function createObservableAnnotation(name, options) {
    return {
      annotationType_: name,
      options_: options,
      make_: make_$4,
      extend_: extend_$4
    };
  }
  function make_$4(adm, key, descriptor) {
    return this.extend_(adm, key, descriptor, false) === null ? 0 : 1;
  }
  function extend_$4(adm, key, descriptor, proxyTrap) {
    var _this$options_$enhanc, _this$options_;
    assertObservableDescriptor(adm, this);
    return adm.defineObservableProperty_(key, descriptor.value, (_this$options_$enhanc = (_this$options_ = this.options_) == null ? void 0 : _this$options_.enhancer) != null ? _this$options_$enhanc : deepEnhancer, proxyTrap);
  }
  function assertObservableDescriptor(adm, _ref, key, descriptor) {
    _ref.annotationType_;
  }
  var AUTO = "true";
  var autoAnnotation = /* @__PURE__ */ createAutoAnnotation();
  function createAutoAnnotation(options) {
    return {
      annotationType_: AUTO,
      options_: options,
      make_: make_$5,
      extend_: extend_$5
    };
  }
  function make_$5(adm, key, descriptor, source) {
    var _this$options_3, _this$options_4;
    if (descriptor.get) {
      return computed.make_(adm, key, descriptor, source);
    }
    if (descriptor.set) {
      var set5 = createAction(key.toString(), descriptor.set);
      if (source === adm.target_) {
        return adm.defineProperty_(key, {
          configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
          set: set5
        }) === null ? 0 : 2;
      }
      defineProperty(source, key, {
        configurable: true,
        set: set5
      });
      return 2;
    }
    if (source !== adm.target_ && typeof descriptor.value === "function") {
      var _this$options_2;
      if (isGenerator(descriptor.value)) {
        var _this$options_;
        var flowAnnotation2 = (_this$options_ = this.options_) != null && _this$options_.autoBind ? flow.bound : flow;
        return flowAnnotation2.make_(adm, key, descriptor, source);
      }
      var actionAnnotation2 = (_this$options_2 = this.options_) != null && _this$options_2.autoBind ? autoAction.bound : autoAction;
      return actionAnnotation2.make_(adm, key, descriptor, source);
    }
    var observableAnnotation2 = ((_this$options_3 = this.options_) == null ? void 0 : _this$options_3.deep) === false ? observable.ref : observable;
    if (typeof descriptor.value === "function" && (_this$options_4 = this.options_) != null && _this$options_4.autoBind) {
      var _adm$proxy_;
      descriptor.value = descriptor.value.bind((_adm$proxy_ = adm.proxy_) != null ? _adm$proxy_ : adm.target_);
    }
    return observableAnnotation2.make_(adm, key, descriptor, source);
  }
  function extend_$5(adm, key, descriptor, proxyTrap) {
    var _this$options_5, _this$options_6;
    if (descriptor.get) {
      return computed.extend_(adm, key, descriptor, proxyTrap);
    }
    if (descriptor.set) {
      return adm.defineProperty_(key, {
        configurable: globalState.safeDescriptors ? adm.isPlainObject_ : true,
        set: createAction(key.toString(), descriptor.set)
      }, proxyTrap);
    }
    if (typeof descriptor.value === "function" && (_this$options_5 = this.options_) != null && _this$options_5.autoBind) {
      var _adm$proxy_2;
      descriptor.value = descriptor.value.bind((_adm$proxy_2 = adm.proxy_) != null ? _adm$proxy_2 : adm.target_);
    }
    var observableAnnotation2 = ((_this$options_6 = this.options_) == null ? void 0 : _this$options_6.deep) === false ? observable.ref : observable;
    return observableAnnotation2.extend_(adm, key, descriptor, proxyTrap);
  }
  var OBSERVABLE = "observable";
  var OBSERVABLE_REF = "observable.ref";
  var OBSERVABLE_SHALLOW = "observable.shallow";
  var OBSERVABLE_STRUCT = "observable.struct";
  var defaultCreateObservableOptions = {
    deep: true,
    name: void 0,
    defaultDecorator: void 0,
    proxy: true
  };
  Object.freeze(defaultCreateObservableOptions);
  function asCreateObservableOptions(thing) {
    return thing || defaultCreateObservableOptions;
  }
  var observableAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE);
  var observableRefAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_REF, {
    enhancer: referenceEnhancer
  });
  var observableShallowAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_SHALLOW, {
    enhancer: shallowEnhancer
  });
  var observableStructAnnotation = /* @__PURE__ */ createObservableAnnotation(OBSERVABLE_STRUCT, {
    enhancer: refStructEnhancer
  });
  var observableDecoratorAnnotation = /* @__PURE__ */ createDecoratorAnnotation(observableAnnotation);
  function getEnhancerFromOptions(options) {
    return options.deep === true ? deepEnhancer : options.deep === false ? referenceEnhancer : getEnhancerFromAnnotation(options.defaultDecorator);
  }
  function getAnnotationFromOptions(options) {
    var _options$defaultDecor;
    return options ? (_options$defaultDecor = options.defaultDecorator) != null ? _options$defaultDecor : createAutoAnnotation(options) : void 0;
  }
  function getEnhancerFromAnnotation(annotation) {
    var _annotation$options_$, _annotation$options_;
    return !annotation ? deepEnhancer : (_annotation$options_$ = (_annotation$options_ = annotation.options_) == null ? void 0 : _annotation$options_.enhancer) != null ? _annotation$options_$ : deepEnhancer;
  }
  function createObservable(v2, arg2, arg3) {
    if (isStringish(arg2)) {
      storeAnnotation(v2, arg2, observableAnnotation);
      return;
    }
    if (isObservable(v2)) {
      return v2;
    }
    if (isPlainObject$1(v2)) {
      return observable.object(v2, arg2, arg3);
    }
    if (Array.isArray(v2)) {
      return observable.array(v2, arg2);
    }
    if (isES6Map(v2)) {
      return observable.map(v2, arg2);
    }
    if (isES6Set(v2)) {
      return observable.set(v2, arg2);
    }
    if (typeof v2 === "object" && v2 !== null) {
      return v2;
    }
    return observable.box(v2, arg2);
  }
  assign(createObservable, observableDecoratorAnnotation);
  var observableFactories = {
    box: function box2(value, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableValue(value, getEnhancerFromOptions(o), o.name, true, o.equals);
    },
    array: function array4(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return (globalState.useProxies === false || o.proxy === false ? createLegacyArray : createObservableArray)(initialValues, getEnhancerFromOptions(o), o.name);
    },
    map: function map(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableMap(initialValues, getEnhancerFromOptions(o), o.name);
    },
    set: function set2(initialValues, options) {
      var o = asCreateObservableOptions(options);
      return new ObservableSet(initialValues, getEnhancerFromOptions(o), o.name);
    },
    object: function object3(props, decorators, options) {
      return extendObservable(globalState.useProxies === false || (options == null ? void 0 : options.proxy) === false ? asObservableObject({}, options) : asDynamicObservableObject({}, options), props, decorators);
    },
    ref: /* @__PURE__ */ createDecoratorAnnotation(observableRefAnnotation),
    shallow: /* @__PURE__ */ createDecoratorAnnotation(observableShallowAnnotation),
    deep: observableDecoratorAnnotation,
    struct: /* @__PURE__ */ createDecoratorAnnotation(observableStructAnnotation)
  };
  var observable = /* @__PURE__ */ assign(createObservable, observableFactories);
  var COMPUTED = "computed";
  var COMPUTED_STRUCT = "computed.struct";
  var computedAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED);
  var computedStructAnnotation = /* @__PURE__ */ createComputedAnnotation(COMPUTED_STRUCT, {
    equals: comparer.structural
  });
  var computed = function computed2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, computedAnnotation);
    }
    if (isPlainObject$1(arg1)) {
      return createDecoratorAnnotation(createComputedAnnotation(COMPUTED, arg1));
    }
    var opts = isPlainObject$1(arg2) ? arg2 : {};
    opts.get = arg1;
    opts.name || (opts.name = arg1.name || "");
    return new ComputedValue(opts);
  };
  Object.assign(computed, computedAnnotation);
  computed.struct = /* @__PURE__ */ createDecoratorAnnotation(computedStructAnnotation);
  var _getDescriptor$config, _getDescriptor;
  var currentActionId = 0;
  var nextActionId = 1;
  var isFunctionNameConfigurable = (_getDescriptor$config = (_getDescriptor = /* @__PURE__ */ getDescriptor(function() {
  }, "name")) == null ? void 0 : _getDescriptor.configurable) != null ? _getDescriptor$config : false;
  var tmpNameDescriptor = {
    value: "action",
    configurable: true,
    writable: false,
    enumerable: false
  };
  function createAction(actionName, fn, autoAction2, ref) {
    if (autoAction2 === void 0) {
      autoAction2 = false;
    }
    function res() {
      return executeAction(actionName, autoAction2, fn, ref || this, arguments);
    }
    res.isMobxAction = true;
    if (isFunctionNameConfigurable) {
      tmpNameDescriptor.value = actionName;
      defineProperty(res, "name", tmpNameDescriptor);
    }
    return res;
  }
  function executeAction(actionName, canRunAsDerivation, fn, scope, args) {
    var runInfo = _startAction(actionName, canRunAsDerivation);
    try {
      return fn.apply(scope, args);
    } catch (err) {
      runInfo.error_ = err;
      throw err;
    } finally {
      _endAction(runInfo);
    }
  }
  function _startAction(actionName, canRunAsDerivation, scope, args) {
    var notifySpy_ = false;
    var startTime_ = 0;
    var prevDerivation_ = globalState.trackingDerivation;
    var runAsAction = !canRunAsDerivation || !prevDerivation_;
    startBatch();
    var prevAllowStateChanges_ = globalState.allowStateChanges;
    if (runAsAction) {
      untrackedStart();
      prevAllowStateChanges_ = allowStateChangesStart(true);
    }
    var prevAllowStateReads_ = allowStateReadsStart(true);
    var runInfo = {
      runAsAction_: runAsAction,
      prevDerivation_,
      prevAllowStateChanges_,
      prevAllowStateReads_,
      notifySpy_,
      startTime_,
      actionId_: nextActionId++,
      parentActionId_: currentActionId
    };
    currentActionId = runInfo.actionId_;
    return runInfo;
  }
  function _endAction(runInfo) {
    if (currentActionId !== runInfo.actionId_) {
      die(30);
    }
    currentActionId = runInfo.parentActionId_;
    if (runInfo.error_ !== void 0) {
      globalState.suppressReactionErrors = true;
    }
    allowStateChangesEnd(runInfo.prevAllowStateChanges_);
    allowStateReadsEnd(runInfo.prevAllowStateReads_);
    endBatch();
    if (runInfo.runAsAction_) {
      untrackedEnd(runInfo.prevDerivation_);
    }
    globalState.suppressReactionErrors = false;
  }
  function allowStateChanges(allowStateChanges2, func) {
    var prev2 = allowStateChangesStart(allowStateChanges2);
    try {
      return func();
    } finally {
      allowStateChangesEnd(prev2);
    }
  }
  function allowStateChangesStart(allowStateChanges2) {
    var prev2 = globalState.allowStateChanges;
    globalState.allowStateChanges = allowStateChanges2;
    return prev2;
  }
  function allowStateChangesEnd(prev2) {
    globalState.allowStateChanges = prev2;
  }
  var _Symbol$toPrimitive;
  _Symbol$toPrimitive = Symbol.toPrimitive;
  var ObservableValue = /* @__PURE__ */ function(_Atom) {
    _inheritsLoose(ObservableValue2, _Atom);
    function ObservableValue2(value, enhancer, name_, notifySpy, equals) {
      var _this;
      if (name_ === void 0) {
        name_ = "ObservableValue";
      }
      if (equals === void 0) {
        equals = comparer["default"];
      }
      _this = _Atom.call(this, name_) || this;
      _this.enhancer = void 0;
      _this.name_ = void 0;
      _this.equals = void 0;
      _this.hasUnreportedChange_ = false;
      _this.interceptors_ = void 0;
      _this.changeListeners_ = void 0;
      _this.value_ = void 0;
      _this.dehancer = void 0;
      _this.enhancer = enhancer;
      _this.name_ = name_;
      _this.equals = equals;
      _this.value_ = enhancer(value, void 0, name_);
      return _this;
    }
    var _proto = ObservableValue2.prototype;
    _proto.dehanceValue = function dehanceValue(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.set = function set5(newValue) {
      this.value_;
      newValue = this.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        this.setNewValue_(newValue);
      }
    };
    _proto.prepareNewValue_ = function prepareNewValue_(newValue) {
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this,
          type: UPDATE,
          newValue
        });
        if (!change) {
          return globalState.UNCHANGED;
        }
        newValue = change.newValue;
      }
      newValue = this.enhancer(newValue, this.value_, this.name_);
      return this.equals(this.value_, newValue) ? globalState.UNCHANGED : newValue;
    };
    _proto.setNewValue_ = function setNewValue_(newValue) {
      var oldValue = this.value_;
      this.value_ = newValue;
      this.reportChanged();
      if (hasListeners(this)) {
        notifyListeners(this, {
          type: UPDATE,
          object: this,
          newValue,
          oldValue
        });
      }
    };
    _proto.get = function get4() {
      this.reportObserved();
      return this.dehanceValue(this.value_);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately) {
        listener({
          observableKind: "value",
          debugObjectName: this.name_,
          object: this,
          type: UPDATE,
          newValue: this.value_,
          oldValue: void 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.raw = function raw() {
      return this.value_;
    };
    _proto.toJSON = function toJSON3() {
      return this.get();
    };
    _proto.toString = function toString3() {
      return this.name_ + "[" + this.value_ + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive] = function() {
      return this.valueOf();
    };
    return ObservableValue2;
  }(Atom);
  var _Symbol$toPrimitive$1;
  _Symbol$toPrimitive$1 = Symbol.toPrimitive;
  var ComputedValue = /* @__PURE__ */ function() {
    function ComputedValue2(options) {
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.observing_ = [];
      this.newObserving_ = null;
      this.isBeingObserved_ = false;
      this.isPendingUnobservation_ = false;
      this.observers_ = /* @__PURE__ */ new Set();
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.lastAccessedBy_ = 0;
      this.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      this.unboundDepsCount_ = 0;
      this.value_ = new CaughtException(null);
      this.name_ = void 0;
      this.triggeredBy_ = void 0;
      this.isComputing_ = false;
      this.isRunningSetter_ = false;
      this.derivation = void 0;
      this.setter_ = void 0;
      this.isTracing_ = TraceMode.NONE;
      this.scope_ = void 0;
      this.equals_ = void 0;
      this.requiresReaction_ = void 0;
      this.keepAlive_ = void 0;
      this.onBOL = void 0;
      this.onBUOL = void 0;
      if (!options.get) {
        die(31);
      }
      this.derivation = options.get;
      this.name_ = options.name || "ComputedValue";
      if (options.set) {
        this.setter_ = createAction("ComputedValue-setter", options.set);
      }
      this.equals_ = options.equals || (options.compareStructural || options.struct ? comparer.structural : comparer["default"]);
      this.scope_ = options.context;
      this.requiresReaction_ = options.requiresReaction;
      this.keepAlive_ = !!options.keepAlive;
    }
    var _proto = ComputedValue2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      propagateMaybeChanged(this);
    };
    _proto.onBO = function onBO() {
      if (this.onBOL) {
        this.onBOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.onBUO = function onBUO() {
      if (this.onBUOL) {
        this.onBUOL.forEach(function(listener) {
          return listener();
        });
      }
    };
    _proto.get = function get4() {
      if (this.isComputing_) {
        die(32, this.name_, this.derivation);
      }
      if (globalState.inBatch === 0 && // !globalState.trackingDerivatpion &&
      this.observers_.size === 0 && !this.keepAlive_) {
        if (shouldCompute(this)) {
          this.warnAboutUntrackedRead_();
          startBatch();
          this.value_ = this.computeValue_(false);
          endBatch();
        }
      } else {
        reportObserved(this);
        if (shouldCompute(this)) {
          var prevTrackingContext = globalState.trackingContext;
          if (this.keepAlive_ && !prevTrackingContext) {
            globalState.trackingContext = this;
          }
          if (this.trackAndCompute()) {
            propagateChangeConfirmed(this);
          }
          globalState.trackingContext = prevTrackingContext;
        }
      }
      var result = this.value_;
      if (isCaughtException(result)) {
        throw result.cause;
      }
      return result;
    };
    _proto.set = function set5(value) {
      if (this.setter_) {
        if (this.isRunningSetter_) {
          die(33, this.name_);
        }
        this.isRunningSetter_ = true;
        try {
          this.setter_.call(this.scope_, value);
        } finally {
          this.isRunningSetter_ = false;
        }
      } else {
        die(34, this.name_);
      }
    };
    _proto.trackAndCompute = function trackAndCompute() {
      var oldValue = this.value_;
      var wasSuspended = (
        /* see #1208 */
        this.dependenciesState_ === IDerivationState_.NOT_TRACKING_
      );
      var newValue = this.computeValue_(true);
      var changed = wasSuspended || isCaughtException(oldValue) || isCaughtException(newValue) || !this.equals_(oldValue, newValue);
      if (changed) {
        this.value_ = newValue;
      }
      return changed;
    };
    _proto.computeValue_ = function computeValue_(track) {
      this.isComputing_ = true;
      var prev2 = allowStateChangesStart(false);
      var res;
      if (track) {
        res = trackDerivedFunction(this, this.derivation, this.scope_);
      } else {
        if (globalState.disableErrorBoundaries === true) {
          res = this.derivation.call(this.scope_);
        } else {
          try {
            res = this.derivation.call(this.scope_);
          } catch (e2) {
            res = new CaughtException(e2);
          }
        }
      }
      allowStateChangesEnd(prev2);
      this.isComputing_ = false;
      return res;
    };
    _proto.suspend_ = function suspend_() {
      if (!this.keepAlive_) {
        clearObserving(this);
        this.value_ = void 0;
      }
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      var _this = this;
      var firstTime = true;
      var prevValue = void 0;
      return autorun(function() {
        var newValue = _this.get();
        if (!firstTime || fireImmediately) {
          var prevU = untrackedStart();
          listener({
            observableKind: "computed",
            debugObjectName: _this.name_,
            type: UPDATE,
            object: _this,
            newValue,
            oldValue: prevValue
          });
          untrackedEnd(prevU);
        }
        firstTime = false;
        prevValue = newValue;
      });
    };
    _proto.warnAboutUntrackedRead_ = function warnAboutUntrackedRead_() {
      {
        return;
      }
    };
    _proto.toString = function toString3() {
      return this.name_ + "[" + this.derivation.toString() + "]";
    };
    _proto.valueOf = function valueOf() {
      return toPrimitive(this.get());
    };
    _proto[_Symbol$toPrimitive$1] = function() {
      return this.valueOf();
    };
    return ComputedValue2;
  }();
  var isComputedValue = /* @__PURE__ */ createInstanceofPredicate("ComputedValue", ComputedValue);
  var IDerivationState_;
  (function(IDerivationState_2) {
    IDerivationState_2[IDerivationState_2["NOT_TRACKING_"] = -1] = "NOT_TRACKING_";
    IDerivationState_2[IDerivationState_2["UP_TO_DATE_"] = 0] = "UP_TO_DATE_";
    IDerivationState_2[IDerivationState_2["POSSIBLY_STALE_"] = 1] = "POSSIBLY_STALE_";
    IDerivationState_2[IDerivationState_2["STALE_"] = 2] = "STALE_";
  })(IDerivationState_ || (IDerivationState_ = {}));
  var TraceMode;
  (function(TraceMode2) {
    TraceMode2[TraceMode2["NONE"] = 0] = "NONE";
    TraceMode2[TraceMode2["LOG"] = 1] = "LOG";
    TraceMode2[TraceMode2["BREAK"] = 2] = "BREAK";
  })(TraceMode || (TraceMode = {}));
  var CaughtException = function CaughtException2(cause) {
    this.cause = void 0;
    this.cause = cause;
  };
  function isCaughtException(e2) {
    return e2 instanceof CaughtException;
  }
  function shouldCompute(derivation) {
    switch (derivation.dependenciesState_) {
      case IDerivationState_.UP_TO_DATE_:
        return false;
      case IDerivationState_.NOT_TRACKING_:
      case IDerivationState_.STALE_:
        return true;
      case IDerivationState_.POSSIBLY_STALE_: {
        var prevAllowStateReads = allowStateReadsStart(true);
        var prevUntracked = untrackedStart();
        var obs = derivation.observing_, l2 = obs.length;
        for (var i = 0; i < l2; i++) {
          var obj = obs[i];
          if (isComputedValue(obj)) {
            if (globalState.disableErrorBoundaries) {
              obj.get();
            } else {
              try {
                obj.get();
              } catch (e2) {
                untrackedEnd(prevUntracked);
                allowStateReadsEnd(prevAllowStateReads);
                return true;
              }
            }
            if (derivation.dependenciesState_ === IDerivationState_.STALE_) {
              untrackedEnd(prevUntracked);
              allowStateReadsEnd(prevAllowStateReads);
              return true;
            }
          }
        }
        changeDependenciesStateTo0(derivation);
        untrackedEnd(prevUntracked);
        allowStateReadsEnd(prevAllowStateReads);
        return false;
      }
    }
  }
  function checkIfStateModificationsAreAllowed(atom) {
    {
      return;
    }
  }
  function trackDerivedFunction(derivation, f2, context) {
    var prevAllowStateReads = allowStateReadsStart(true);
    changeDependenciesStateTo0(derivation);
    derivation.newObserving_ = new Array(derivation.observing_.length + 100);
    derivation.unboundDepsCount_ = 0;
    derivation.runId_ = ++globalState.runId;
    var prevTracking = globalState.trackingDerivation;
    globalState.trackingDerivation = derivation;
    globalState.inBatch++;
    var result;
    if (globalState.disableErrorBoundaries === true) {
      result = f2.call(context);
    } else {
      try {
        result = f2.call(context);
      } catch (e2) {
        result = new CaughtException(e2);
      }
    }
    globalState.inBatch--;
    globalState.trackingDerivation = prevTracking;
    bindDependencies(derivation);
    allowStateReadsEnd(prevAllowStateReads);
    return result;
  }
  function bindDependencies(derivation) {
    var prevObserving = derivation.observing_;
    var observing = derivation.observing_ = derivation.newObserving_;
    var lowestNewObservingDerivationState = IDerivationState_.UP_TO_DATE_;
    var i0 = 0, l2 = derivation.unboundDepsCount_;
    for (var i = 0; i < l2; i++) {
      var dep = observing[i];
      if (dep.diffValue_ === 0) {
        dep.diffValue_ = 1;
        if (i0 !== i) {
          observing[i0] = dep;
        }
        i0++;
      }
      if (dep.dependenciesState_ > lowestNewObservingDerivationState) {
        lowestNewObservingDerivationState = dep.dependenciesState_;
      }
    }
    observing.length = i0;
    derivation.newObserving_ = null;
    l2 = prevObserving.length;
    while (l2--) {
      var _dep = prevObserving[l2];
      if (_dep.diffValue_ === 0) {
        removeObserver(_dep, derivation);
      }
      _dep.diffValue_ = 0;
    }
    while (i0--) {
      var _dep2 = observing[i0];
      if (_dep2.diffValue_ === 1) {
        _dep2.diffValue_ = 0;
        addObserver(_dep2, derivation);
      }
    }
    if (lowestNewObservingDerivationState !== IDerivationState_.UP_TO_DATE_) {
      derivation.dependenciesState_ = lowestNewObservingDerivationState;
      derivation.onBecomeStale_();
    }
  }
  function clearObserving(derivation) {
    var obs = derivation.observing_;
    derivation.observing_ = [];
    var i = obs.length;
    while (i--) {
      removeObserver(obs[i], derivation);
    }
    derivation.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
  }
  function untracked(action2) {
    var prev2 = untrackedStart();
    try {
      return action2();
    } finally {
      untrackedEnd(prev2);
    }
  }
  function untrackedStart() {
    var prev2 = globalState.trackingDerivation;
    globalState.trackingDerivation = null;
    return prev2;
  }
  function untrackedEnd(prev2) {
    globalState.trackingDerivation = prev2;
  }
  function allowStateReadsStart(allowStateReads) {
    var prev2 = globalState.allowStateReads;
    globalState.allowStateReads = allowStateReads;
    return prev2;
  }
  function allowStateReadsEnd(prev2) {
    globalState.allowStateReads = prev2;
  }
  function changeDependenciesStateTo0(derivation) {
    if (derivation.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
      return;
    }
    derivation.dependenciesState_ = IDerivationState_.UP_TO_DATE_;
    var obs = derivation.observing_;
    var i = obs.length;
    while (i--) {
      obs[i].lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
    }
  }
  var MobXGlobals = function MobXGlobals2() {
    this.version = 6;
    this.UNCHANGED = {};
    this.trackingDerivation = null;
    this.trackingContext = null;
    this.runId = 0;
    this.mobxGuid = 0;
    this.inBatch = 0;
    this.pendingUnobservations = [];
    this.pendingReactions = [];
    this.isRunningReactions = false;
    this.allowStateChanges = false;
    this.allowStateReads = true;
    this.enforceActions = true;
    this.spyListeners = [];
    this.globalReactionErrorHandlers = [];
    this.computedRequiresReaction = false;
    this.reactionRequiresObservable = false;
    this.observableRequiresReaction = false;
    this.disableErrorBoundaries = false;
    this.suppressReactionErrors = false;
    this.useProxies = true;
    this.verifyProxies = false;
    this.safeDescriptors = true;
    this.stateVersion = Number.MIN_SAFE_INTEGER;
  };
  var canMergeGlobalState = true;
  var isolateCalled = false;
  var globalState = /* @__PURE__ */ function() {
    var global2 = /* @__PURE__ */ getGlobal();
    if (global2.__mobxInstanceCount > 0 && !global2.__mobxGlobals) {
      canMergeGlobalState = false;
    }
    if (global2.__mobxGlobals && global2.__mobxGlobals.version !== new MobXGlobals().version) {
      canMergeGlobalState = false;
    }
    if (!canMergeGlobalState) {
      setTimeout(function() {
        if (!isolateCalled) {
          die(35);
        }
      }, 1);
      return new MobXGlobals();
    } else if (global2.__mobxGlobals) {
      global2.__mobxInstanceCount += 1;
      if (!global2.__mobxGlobals.UNCHANGED) {
        global2.__mobxGlobals.UNCHANGED = {};
      }
      return global2.__mobxGlobals;
    } else {
      global2.__mobxInstanceCount = 1;
      return global2.__mobxGlobals = /* @__PURE__ */ new MobXGlobals();
    }
  }();
  function isolateGlobalState() {
    if (globalState.pendingReactions.length || globalState.inBatch || globalState.isRunningReactions) {
      die(36);
    }
    isolateCalled = true;
    if (canMergeGlobalState) {
      var global2 = getGlobal();
      if (--global2.__mobxInstanceCount === 0) {
        global2.__mobxGlobals = void 0;
      }
      globalState = new MobXGlobals();
    }
  }
  function addObserver(observable2, node2) {
    observable2.observers_.add(node2);
    if (observable2.lowestObserverState_ > node2.dependenciesState_) {
      observable2.lowestObserverState_ = node2.dependenciesState_;
    }
  }
  function removeObserver(observable2, node2) {
    observable2.observers_["delete"](node2);
    if (observable2.observers_.size === 0) {
      queueForUnobservation(observable2);
    }
  }
  function queueForUnobservation(observable2) {
    if (observable2.isPendingUnobservation_ === false) {
      observable2.isPendingUnobservation_ = true;
      globalState.pendingUnobservations.push(observable2);
    }
  }
  function startBatch() {
    globalState.inBatch++;
  }
  function endBatch() {
    if (--globalState.inBatch === 0) {
      runReactions();
      var list = globalState.pendingUnobservations;
      for (var i = 0; i < list.length; i++) {
        var observable2 = list[i];
        observable2.isPendingUnobservation_ = false;
        if (observable2.observers_.size === 0) {
          if (observable2.isBeingObserved_) {
            observable2.isBeingObserved_ = false;
            observable2.onBUO();
          }
          if (observable2 instanceof ComputedValue) {
            observable2.suspend_();
          }
        }
      }
      globalState.pendingUnobservations = [];
    }
  }
  function reportObserved(observable2) {
    var derivation = globalState.trackingDerivation;
    if (derivation !== null) {
      if (derivation.runId_ !== observable2.lastAccessedBy_) {
        observable2.lastAccessedBy_ = derivation.runId_;
        derivation.newObserving_[derivation.unboundDepsCount_++] = observable2;
        if (!observable2.isBeingObserved_ && globalState.trackingContext) {
          observable2.isBeingObserved_ = true;
          observable2.onBO();
        }
      }
      return observable2.isBeingObserved_;
    } else if (observable2.observers_.size === 0 && globalState.inBatch > 0) {
      queueForUnobservation(observable2);
    }
    return false;
  }
  function propagateChanged(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d2) {
      if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        d2.onBecomeStale_();
      }
      d2.dependenciesState_ = IDerivationState_.STALE_;
    });
  }
  function propagateChangeConfirmed(observable2) {
    if (observable2.lowestObserverState_ === IDerivationState_.STALE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.STALE_;
    observable2.observers_.forEach(function(d2) {
      if (d2.dependenciesState_ === IDerivationState_.POSSIBLY_STALE_) {
        d2.dependenciesState_ = IDerivationState_.STALE_;
      } else if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        observable2.lowestObserverState_ = IDerivationState_.UP_TO_DATE_;
      }
    });
  }
  function propagateMaybeChanged(observable2) {
    if (observable2.lowestObserverState_ !== IDerivationState_.UP_TO_DATE_) {
      return;
    }
    observable2.lowestObserverState_ = IDerivationState_.POSSIBLY_STALE_;
    observable2.observers_.forEach(function(d2) {
      if (d2.dependenciesState_ === IDerivationState_.UP_TO_DATE_) {
        d2.dependenciesState_ = IDerivationState_.POSSIBLY_STALE_;
        d2.onBecomeStale_();
      }
    });
  }
  var Reaction = /* @__PURE__ */ function() {
    function Reaction2(name_, onInvalidate_, errorHandler_, requiresObservable_) {
      if (name_ === void 0) {
        name_ = "Reaction";
      }
      this.name_ = void 0;
      this.onInvalidate_ = void 0;
      this.errorHandler_ = void 0;
      this.requiresObservable_ = void 0;
      this.observing_ = [];
      this.newObserving_ = [];
      this.dependenciesState_ = IDerivationState_.NOT_TRACKING_;
      this.diffValue_ = 0;
      this.runId_ = 0;
      this.unboundDepsCount_ = 0;
      this.isDisposed_ = false;
      this.isScheduled_ = false;
      this.isTrackPending_ = false;
      this.isRunning_ = false;
      this.isTracing_ = TraceMode.NONE;
      this.name_ = name_;
      this.onInvalidate_ = onInvalidate_;
      this.errorHandler_ = errorHandler_;
      this.requiresObservable_ = requiresObservable_;
    }
    var _proto = Reaction2.prototype;
    _proto.onBecomeStale_ = function onBecomeStale_() {
      this.schedule_();
    };
    _proto.schedule_ = function schedule_() {
      if (!this.isScheduled_) {
        this.isScheduled_ = true;
        globalState.pendingReactions.push(this);
        runReactions();
      }
    };
    _proto.isScheduled = function isScheduled() {
      return this.isScheduled_;
    };
    _proto.runReaction_ = function runReaction_() {
      if (!this.isDisposed_) {
        startBatch();
        this.isScheduled_ = false;
        var prev2 = globalState.trackingContext;
        globalState.trackingContext = this;
        if (shouldCompute(this)) {
          this.isTrackPending_ = true;
          try {
            this.onInvalidate_();
            if (false)
              ;
          } catch (e2) {
            this.reportExceptionInDerivation_(e2);
          }
        }
        globalState.trackingContext = prev2;
        endBatch();
      }
    };
    _proto.track = function track(fn) {
      if (this.isDisposed_) {
        return;
      }
      startBatch();
      this.isRunning_ = true;
      var prevReaction = globalState.trackingContext;
      globalState.trackingContext = this;
      var result = trackDerivedFunction(this, fn, void 0);
      globalState.trackingContext = prevReaction;
      this.isRunning_ = false;
      this.isTrackPending_ = false;
      if (this.isDisposed_) {
        clearObserving(this);
      }
      if (isCaughtException(result)) {
        this.reportExceptionInDerivation_(result.cause);
      }
      endBatch();
    };
    _proto.reportExceptionInDerivation_ = function reportExceptionInDerivation_(error) {
      var _this = this;
      if (this.errorHandler_) {
        this.errorHandler_(error, this);
        return;
      }
      if (globalState.disableErrorBoundaries) {
        throw error;
      }
      var message = "[mobx] uncaught error in '" + this + "'";
      if (!globalState.suppressReactionErrors) {
        console.error(message, error);
      }
      globalState.globalReactionErrorHandlers.forEach(function(f2) {
        return f2(error, _this);
      });
    };
    _proto.dispose = function dispose() {
      if (!this.isDisposed_) {
        this.isDisposed_ = true;
        if (!this.isRunning_) {
          startBatch();
          clearObserving(this);
          endBatch();
        }
      }
    };
    _proto.getDisposer_ = function getDisposer_() {
      var r2 = this.dispose.bind(this);
      r2[$mobx] = this;
      return r2;
    };
    _proto.toString = function toString3() {
      return "Reaction[" + this.name_ + "]";
    };
    _proto.trace = function trace$1(enterBreakPoint) {
      if (enterBreakPoint === void 0) {
        enterBreakPoint = false;
      }
      trace(this, enterBreakPoint);
    };
    return Reaction2;
  }();
  var MAX_REACTION_ITERATIONS = 100;
  var reactionScheduler = function reactionScheduler2(f2) {
    return f2();
  };
  function runReactions() {
    if (globalState.inBatch > 0 || globalState.isRunningReactions) {
      return;
    }
    reactionScheduler(runReactionsHelper);
  }
  function runReactionsHelper() {
    globalState.isRunningReactions = true;
    var allReactions = globalState.pendingReactions;
    var iterations = 0;
    while (allReactions.length > 0) {
      if (++iterations === MAX_REACTION_ITERATIONS) {
        console.error("[mobx] cycle in reaction: " + allReactions[0]);
        allReactions.splice(0);
      }
      var remainingReactions = allReactions.splice(0);
      for (var i = 0, l2 = remainingReactions.length; i < l2; i++) {
        remainingReactions[i].runReaction_();
      }
    }
    globalState.isRunningReactions = false;
  }
  var isReaction = /* @__PURE__ */ createInstanceofPredicate("Reaction", Reaction);
  function setReactionScheduler(fn) {
    var baseScheduler = reactionScheduler;
    reactionScheduler = function reactionScheduler3(f2) {
      return fn(function() {
        return baseScheduler(f2);
      });
    };
  }
  function isSpyEnabled() {
    return false;
  }
  function spy(listener) {
    {
      console.warn("[mobx.spy] Is a no-op in production builds");
      return function() {
      };
    }
  }
  var ACTION = "action";
  var ACTION_BOUND = "action.bound";
  var AUTOACTION = "autoAction";
  var AUTOACTION_BOUND = "autoAction.bound";
  var DEFAULT_ACTION_NAME = "<unnamed action>";
  var actionAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION);
  var actionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(ACTION_BOUND, {
    bound: true
  });
  var autoActionAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION, {
    autoAction: true
  });
  var autoActionBoundAnnotation = /* @__PURE__ */ createActionAnnotation(AUTOACTION_BOUND, {
    autoAction: true,
    bound: true
  });
  function createActionFactory(autoAction2) {
    var res = function action2(arg1, arg2) {
      if (isFunction$2(arg1)) {
        return createAction(arg1.name || DEFAULT_ACTION_NAME, arg1, autoAction2);
      }
      if (isFunction$2(arg2)) {
        return createAction(arg1, arg2, autoAction2);
      }
      if (isStringish(arg2)) {
        return storeAnnotation(arg1, arg2, autoAction2 ? autoActionAnnotation : actionAnnotation);
      }
      if (isStringish(arg1)) {
        return createDecoratorAnnotation(createActionAnnotation(autoAction2 ? AUTOACTION : ACTION, {
          name: arg1,
          autoAction: autoAction2
        }));
      }
    };
    return res;
  }
  var action = /* @__PURE__ */ createActionFactory(false);
  Object.assign(action, actionAnnotation);
  var autoAction = /* @__PURE__ */ createActionFactory(true);
  Object.assign(autoAction, autoActionAnnotation);
  action.bound = /* @__PURE__ */ createDecoratorAnnotation(actionBoundAnnotation);
  autoAction.bound = /* @__PURE__ */ createDecoratorAnnotation(autoActionBoundAnnotation);
  function isAction(thing) {
    return isFunction$2(thing) && thing.isMobxAction === true;
  }
  function autorun(view, opts) {
    var _opts$name, _opts;
    if (opts === void 0) {
      opts = EMPTY_OBJECT;
    }
    var name = (_opts$name = (_opts = opts) == null ? void 0 : _opts.name) != null ? _opts$name : "Autorun";
    var runSync = !opts.scheduler && !opts.delay;
    var reaction;
    if (runSync) {
      reaction = new Reaction(name, function() {
        this.track(reactionRunner);
      }, opts.onError, opts.requiresObservable);
    } else {
      var scheduler = createSchedulerFromOptions(opts);
      var isScheduled = false;
      reaction = new Reaction(name, function() {
        if (!isScheduled) {
          isScheduled = true;
          scheduler(function() {
            isScheduled = false;
            if (!reaction.isDisposed_) {
              reaction.track(reactionRunner);
            }
          });
        }
      }, opts.onError, opts.requiresObservable);
    }
    function reactionRunner() {
      view(reaction);
    }
    reaction.schedule_();
    return reaction.getDisposer_();
  }
  var run = function run2(f2) {
    return f2();
  };
  function createSchedulerFromOptions(opts) {
    return opts.scheduler ? opts.scheduler : opts.delay ? function(f2) {
      return setTimeout(f2, opts.delay);
    } : run;
  }
  var ON_BECOME_OBSERVED = "onBO";
  var ON_BECOME_UNOBSERVED = "onBUO";
  function onBecomeObserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_OBSERVED, thing, arg2, arg3);
  }
  function onBecomeUnobserved(thing, arg2, arg3) {
    return interceptHook(ON_BECOME_UNOBSERVED, thing, arg2, arg3);
  }
  function interceptHook(hook, thing, arg2, arg3) {
    var atom = typeof arg3 === "function" ? getAtom(thing, arg2) : getAtom(thing);
    var cb = isFunction$2(arg3) ? arg3 : arg2;
    var listenersKey = hook + "L";
    if (atom[listenersKey]) {
      atom[listenersKey].add(cb);
    } else {
      atom[listenersKey] = /* @__PURE__ */ new Set([cb]);
    }
    return function() {
      var hookListeners = atom[listenersKey];
      if (hookListeners) {
        hookListeners["delete"](cb);
        if (hookListeners.size === 0) {
          delete atom[listenersKey];
        }
      }
    };
  }
  var NEVER = "never";
  var ALWAYS = "always";
  var OBSERVED = "observed";
  function configure(options) {
    if (options.isolateGlobalState === true) {
      isolateGlobalState();
    }
    var useProxies = options.useProxies, enforceActions = options.enforceActions;
    if (useProxies !== void 0) {
      globalState.useProxies = useProxies === ALWAYS ? true : useProxies === NEVER ? false : typeof Proxy !== "undefined";
    }
    if (useProxies === "ifavailable") {
      globalState.verifyProxies = true;
    }
    if (enforceActions !== void 0) {
      var ea = enforceActions === ALWAYS ? ALWAYS : enforceActions === OBSERVED;
      globalState.enforceActions = ea;
      globalState.allowStateChanges = ea === true || ea === ALWAYS ? false : true;
    }
    ["computedRequiresReaction", "reactionRequiresObservable", "observableRequiresReaction", "disableErrorBoundaries", "safeDescriptors"].forEach(function(key) {
      if (key in options) {
        globalState[key] = !!options[key];
      }
    });
    globalState.allowStateReads = !globalState.observableRequiresReaction;
    if (options.reactionScheduler) {
      setReactionScheduler(options.reactionScheduler);
    }
  }
  function extendObservable(target, properties, annotations, options) {
    var descriptors2 = getOwnPropertyDescriptors(properties);
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      ownKeys(descriptors2).forEach(function(key) {
        adm.extend_(
          key,
          descriptors2[key],
          // must pass "undefined" for { key: undefined }
          !annotations ? true : key in annotations ? annotations[key] : true
        );
      });
    } finally {
      endBatch();
    }
    return target;
  }
  function getDependencyTree(thing, property) {
    return nodeToDependencyTree(getAtom(thing, property));
  }
  function nodeToDependencyTree(node2) {
    var result = {
      name: node2.name_
    };
    if (node2.observing_ && node2.observing_.length > 0) {
      result.dependencies = unique(node2.observing_).map(nodeToDependencyTree);
    }
    return result;
  }
  function unique(list) {
    return Array.from(new Set(list));
  }
  var generatorId = 0;
  function FlowCancellationError() {
    this.message = "FLOW_CANCELLED";
  }
  FlowCancellationError.prototype = /* @__PURE__ */ Object.create(Error.prototype);
  var flowAnnotation = /* @__PURE__ */ createFlowAnnotation("flow");
  var flowBoundAnnotation = /* @__PURE__ */ createFlowAnnotation("flow.bound", {
    bound: true
  });
  var flow = /* @__PURE__ */ Object.assign(function flow2(arg1, arg2) {
    if (isStringish(arg2)) {
      return storeAnnotation(arg1, arg2, flowAnnotation);
    }
    var generator = arg1;
    var name = generator.name || "<unnamed flow>";
    var res = function res2() {
      var ctx = this;
      var args = arguments;
      var runId = ++generatorId;
      var gen = action(name + " - runid: " + runId + " - init", generator).apply(ctx, args);
      var rejector;
      var pendingPromise = void 0;
      var promise = new Promise(function(resolve, reject) {
        var stepId = 0;
        rejector = reject;
        function onFulfilled(res3) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen.next).call(gen, res3);
          } catch (e2) {
            return reject(e2);
          }
          next2(ret);
        }
        function onRejected(err) {
          pendingPromise = void 0;
          var ret;
          try {
            ret = action(name + " - runid: " + runId + " - yield " + stepId++, gen["throw"]).call(gen, err);
          } catch (e2) {
            return reject(e2);
          }
          next2(ret);
        }
        function next2(ret) {
          if (isFunction$2(ret == null ? void 0 : ret.then)) {
            ret.then(next2, reject);
            return;
          }
          if (ret.done) {
            return resolve(ret.value);
          }
          pendingPromise = Promise.resolve(ret.value);
          return pendingPromise.then(onFulfilled, onRejected);
        }
        onFulfilled(void 0);
      });
      promise.cancel = action(name + " - runid: " + runId + " - cancel", function() {
        try {
          if (pendingPromise) {
            cancelPromise(pendingPromise);
          }
          var _res = gen["return"](void 0);
          var yieldedPromise = Promise.resolve(_res.value);
          yieldedPromise.then(noop$1, noop$1);
          cancelPromise(yieldedPromise);
          rejector(new FlowCancellationError());
        } catch (e2) {
          rejector(e2);
        }
      });
      return promise;
    };
    res.isMobXFlow = true;
    return res;
  }, flowAnnotation);
  flow.bound = /* @__PURE__ */ createDecoratorAnnotation(flowBoundAnnotation);
  function cancelPromise(promise) {
    if (isFunction$2(promise.cancel)) {
      promise.cancel();
    }
  }
  function isFlow(fn) {
    return (fn == null ? void 0 : fn.isMobXFlow) === true;
  }
  function _isObservable(value, property) {
    if (!value) {
      return false;
    }
    if (property !== void 0) {
      if (isObservableObject(value)) {
        return value[$mobx].values_.has(property);
      }
      return false;
    }
    return isObservableObject(value) || !!value[$mobx] || isAtom(value) || isReaction(value) || isComputedValue(value);
  }
  function isObservable(value) {
    return _isObservable(value);
  }
  function trace() {
    {
      die("trace() is not available in production builds");
    }
    var enterBreakPoint = false;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (typeof args[args.length - 1] === "boolean") {
      enterBreakPoint = args.pop();
    }
    var derivation = getAtomFromArgs(args);
    if (!derivation) {
      return die("'trace(break?)' can only be used inside a tracked computed value or a Reaction. Consider passing in the computed value or reaction explicitly");
    }
    if (derivation.isTracing_ === TraceMode.NONE) {
      console.log("[mobx.trace] '" + derivation.name_ + "' tracing enabled");
    }
    derivation.isTracing_ = enterBreakPoint ? TraceMode.BREAK : TraceMode.LOG;
  }
  function getAtomFromArgs(args) {
    switch (args.length) {
      case 0:
        return globalState.trackingDerivation;
      case 1:
        return getAtom(args[0]);
      case 2:
        return getAtom(args[0], args[1]);
    }
  }
  function transaction(action2, thisArg) {
    if (thisArg === void 0) {
      thisArg = void 0;
    }
    startBatch();
    try {
      return action2.apply(thisArg);
    } finally {
      endBatch();
    }
  }
  function getAdm(target) {
    return target[$mobx];
  }
  var objectProxyTraps = {
    has: function has(target, name) {
      return getAdm(target).has_(name);
    },
    get: function get2(target, name) {
      return getAdm(target).get_(name);
    },
    set: function set3(target, name, value) {
      var _getAdm$set_;
      if (!isStringish(name)) {
        return false;
      }
      return (_getAdm$set_ = getAdm(target).set_(name, value, true)) != null ? _getAdm$set_ : true;
    },
    deleteProperty: function deleteProperty(target, name) {
      var _getAdm$delete_;
      if (!isStringish(name)) {
        return false;
      }
      return (_getAdm$delete_ = getAdm(target).delete_(name, true)) != null ? _getAdm$delete_ : true;
    },
    defineProperty: function defineProperty2(target, name, descriptor) {
      var _getAdm$definePropert;
      return (_getAdm$definePropert = getAdm(target).defineProperty_(name, descriptor)) != null ? _getAdm$definePropert : true;
    },
    ownKeys: function ownKeys2(target) {
      return getAdm(target).ownKeys_();
    },
    preventExtensions: function preventExtensions(target) {
      die(13);
    }
  };
  function asDynamicObservableObject(target, options) {
    var _target$$mobx, _target$$mobx$proxy_;
    assertProxies();
    target = asObservableObject(target, options);
    return (_target$$mobx$proxy_ = (_target$$mobx = target[$mobx]).proxy_) != null ? _target$$mobx$proxy_ : _target$$mobx.proxy_ = new Proxy(target, objectProxyTraps);
  }
  function hasInterceptors(interceptable) {
    return interceptable.interceptors_ !== void 0 && interceptable.interceptors_.length > 0;
  }
  function registerInterceptor(interceptable, handler) {
    var interceptors = interceptable.interceptors_ || (interceptable.interceptors_ = []);
    interceptors.push(handler);
    return once(function() {
      var idx = interceptors.indexOf(handler);
      if (idx !== -1) {
        interceptors.splice(idx, 1);
      }
    });
  }
  function interceptChange(interceptable, change) {
    var prevU = untrackedStart();
    try {
      var interceptors = [].concat(interceptable.interceptors_ || []);
      for (var i = 0, l2 = interceptors.length; i < l2; i++) {
        change = interceptors[i](change);
        if (change && !change.type) {
          die(14);
        }
        if (!change) {
          break;
        }
      }
      return change;
    } finally {
      untrackedEnd(prevU);
    }
  }
  function hasListeners(listenable) {
    return listenable.changeListeners_ !== void 0 && listenable.changeListeners_.length > 0;
  }
  function registerListener(listenable, handler) {
    var listeners = listenable.changeListeners_ || (listenable.changeListeners_ = []);
    listeners.push(handler);
    return once(function() {
      var idx = listeners.indexOf(handler);
      if (idx !== -1) {
        listeners.splice(idx, 1);
      }
    });
  }
  function notifyListeners(listenable, change) {
    var prevU = untrackedStart();
    var listeners = listenable.changeListeners_;
    if (!listeners) {
      return;
    }
    listeners = listeners.slice();
    for (var i = 0, l2 = listeners.length; i < l2; i++) {
      listeners[i](change);
    }
    untrackedEnd(prevU);
  }
  function makeObservable(target, annotations, options) {
    var adm = asObservableObject(target, options)[$mobx];
    startBatch();
    try {
      var _annotations;
      if (false)
        ;
      (_annotations = annotations) != null ? _annotations : annotations = collectStoredAnnotations(target);
      ownKeys(annotations).forEach(function(key) {
        return adm.make_(key, annotations[key]);
      });
    } finally {
      endBatch();
    }
    return target;
  }
  var keysSymbol = /* @__PURE__ */ Symbol("mobx-keys");
  function makeAutoObservable(target, overrides, options) {
    if (isPlainObject$1(target)) {
      return extendObservable(target, target, overrides, options);
    }
    var adm = asObservableObject(target, options)[$mobx];
    if (!target[keysSymbol]) {
      var proto = Object.getPrototypeOf(target);
      var keys2 = new Set([].concat(ownKeys(target), ownKeys(proto)));
      keys2["delete"]("constructor");
      keys2["delete"]($mobx);
      addHiddenProp(proto, keysSymbol, keys2);
    }
    startBatch();
    try {
      target[keysSymbol].forEach(function(key) {
        return adm.make_(
          key,
          // must pass "undefined" for { key: undefined }
          !overrides ? true : key in overrides ? overrides[key] : true
        );
      });
    } finally {
      endBatch();
    }
    return target;
  }
  var SPLICE = "splice";
  var UPDATE = "update";
  var MAX_SPLICE_SIZE = 1e4;
  var arrayTraps = {
    get: function get3(target, name) {
      var adm = target[$mobx];
      if (name === $mobx) {
        return adm;
      }
      if (name === "length") {
        return adm.getArrayLength_();
      }
      if (typeof name === "string" && !isNaN(name)) {
        return adm.get_(parseInt(name));
      }
      if (hasProp(arrayExtensions, name)) {
        return arrayExtensions[name];
      }
      return target[name];
    },
    set: function set4(target, name, value) {
      var adm = target[$mobx];
      if (name === "length") {
        adm.setArrayLength_(value);
      }
      if (typeof name === "symbol" || isNaN(name)) {
        target[name] = value;
      } else {
        adm.set_(parseInt(name), value);
      }
      return true;
    },
    preventExtensions: function preventExtensions2() {
      die(15);
    }
  };
  var ObservableArrayAdministration = /* @__PURE__ */ function() {
    function ObservableArrayAdministration2(name, enhancer, owned_, legacyMode_) {
      if (name === void 0) {
        name = "ObservableArray";
      }
      this.owned_ = void 0;
      this.legacyMode_ = void 0;
      this.atom_ = void 0;
      this.values_ = [];
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.enhancer_ = void 0;
      this.dehancer = void 0;
      this.proxy_ = void 0;
      this.lastKnownLength_ = 0;
      this.owned_ = owned_;
      this.legacyMode_ = legacyMode_;
      this.atom_ = new Atom(name);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, "ObservableArray[..]");
      };
    }
    var _proto = ObservableArrayAdministration2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.dehanceValues_ = function dehanceValues_(values) {
      if (this.dehancer !== void 0 && values.length > 0) {
        return values.map(this.dehancer);
      }
      return values;
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      if (fireImmediately === void 0) {
        fireImmediately = false;
      }
      if (fireImmediately) {
        listener({
          observableKind: "array",
          object: this.proxy_,
          debugObjectName: this.atom_.name_,
          type: "splice",
          index: 0,
          added: this.values_.slice(),
          addedCount: this.values_.length,
          removed: [],
          removedCount: 0
        });
      }
      return registerListener(this, listener);
    };
    _proto.getArrayLength_ = function getArrayLength_() {
      this.atom_.reportObserved();
      return this.values_.length;
    };
    _proto.setArrayLength_ = function setArrayLength_(newLength) {
      if (typeof newLength !== "number" || isNaN(newLength) || newLength < 0) {
        die("Out of range: " + newLength);
      }
      var currentLength = this.values_.length;
      if (newLength === currentLength) {
        return;
      } else if (newLength > currentLength) {
        var newItems = new Array(newLength - currentLength);
        for (var i = 0; i < newLength - currentLength; i++) {
          newItems[i] = void 0;
        }
        this.spliceWithArray_(currentLength, 0, newItems);
      } else {
        this.spliceWithArray_(newLength, currentLength - newLength);
      }
    };
    _proto.updateArrayLength_ = function updateArrayLength_(oldLength, delta) {
      if (oldLength !== this.lastKnownLength_) {
        die(16);
      }
      this.lastKnownLength_ += delta;
      if (this.legacyMode_ && delta > 0) {
        reserveArrayBuffer(oldLength + delta + 1);
      }
    };
    _proto.spliceWithArray_ = function spliceWithArray_(index2, deleteCount, newItems) {
      var _this = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      var length2 = this.values_.length;
      if (index2 === void 0) {
        index2 = 0;
      } else if (index2 > length2) {
        index2 = length2;
      } else if (index2 < 0) {
        index2 = Math.max(0, length2 + index2);
      }
      if (arguments.length === 1) {
        deleteCount = length2 - index2;
      } else if (deleteCount === void 0 || deleteCount === null) {
        deleteCount = 0;
      } else {
        deleteCount = Math.max(0, Math.min(deleteCount, length2 - index2));
      }
      if (newItems === void 0) {
        newItems = EMPTY_ARRAY;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_,
          type: SPLICE,
          index: index2,
          removedCount: deleteCount,
          added: newItems
        });
        if (!change) {
          return EMPTY_ARRAY;
        }
        deleteCount = change.removedCount;
        newItems = change.added;
      }
      newItems = newItems.length === 0 ? newItems : newItems.map(function(v2) {
        return _this.enhancer_(v2, void 0);
      });
      if (this.legacyMode_ || false) {
        var lengthDelta = newItems.length - deleteCount;
        this.updateArrayLength_(length2, lengthDelta);
      }
      var res = this.spliceItemsIntoValues_(index2, deleteCount, newItems);
      if (deleteCount !== 0 || newItems.length !== 0) {
        this.notifyArraySplice_(index2, newItems, res);
      }
      return this.dehanceValues_(res);
    };
    _proto.spliceItemsIntoValues_ = function spliceItemsIntoValues_(index2, deleteCount, newItems) {
      if (newItems.length < MAX_SPLICE_SIZE) {
        var _this$values_;
        return (_this$values_ = this.values_).splice.apply(_this$values_, [index2, deleteCount].concat(newItems));
      } else {
        var res = this.values_.slice(index2, index2 + deleteCount);
        var oldItems = this.values_.slice(index2 + deleteCount);
        this.values_.length += newItems.length - deleteCount;
        for (var i = 0; i < newItems.length; i++) {
          this.values_[index2 + i] = newItems[i];
        }
        for (var _i = 0; _i < oldItems.length; _i++) {
          this.values_[index2 + newItems.length + _i] = oldItems[_i];
        }
        return res;
      }
    };
    _proto.notifyArrayChildUpdate_ = function notifyArrayChildUpdate_(index2, newValue, oldValue) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        type: UPDATE,
        debugObjectName: this.atom_.name_,
        index: index2,
        newValue,
        oldValue
      } : null;
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
    };
    _proto.notifyArraySplice_ = function notifyArraySplice_(index2, added, removed) {
      var notifySpy = !this.owned_ && isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "array",
        object: this.proxy_,
        debugObjectName: this.atom_.name_,
        type: SPLICE,
        index: index2,
        removed,
        added,
        removedCount: removed.length,
        addedCount: added.length
      } : null;
      this.atom_.reportChanged();
      if (notify) {
        notifyListeners(this, change);
      }
    };
    _proto.get_ = function get_(index2) {
      if (this.legacyMode_ && index2 >= this.values_.length) {
        console.warn("[mobx] Out of bounds read: " + index2);
        return void 0;
      }
      this.atom_.reportObserved();
      return this.dehanceValue_(this.values_[index2]);
    };
    _proto.set_ = function set_(index2, newValue) {
      var values = this.values_;
      if (this.legacyMode_ && index2 > values.length) {
        die(17, index2, values.length);
      }
      if (index2 < values.length) {
        checkIfStateModificationsAreAllowed(this.atom_);
        var oldValue = values[index2];
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            type: UPDATE,
            object: this.proxy_,
            index: index2,
            newValue
          });
          if (!change) {
            return;
          }
          newValue = change.newValue;
        }
        newValue = this.enhancer_(newValue, oldValue);
        var changed = newValue !== oldValue;
        if (changed) {
          values[index2] = newValue;
          this.notifyArrayChildUpdate_(index2, newValue, oldValue);
        }
      } else {
        var newItems = new Array(index2 + 1 - values.length);
        for (var i = 0; i < newItems.length - 1; i++) {
          newItems[i] = void 0;
        }
        newItems[newItems.length - 1] = newValue;
        this.spliceWithArray_(values.length, 0, newItems);
      }
    };
    return ObservableArrayAdministration2;
  }();
  function createObservableArray(initialValues, enhancer, name, owned) {
    if (name === void 0) {
      name = "ObservableArray";
    }
    if (owned === void 0) {
      owned = false;
    }
    assertProxies();
    var adm = new ObservableArrayAdministration(name, enhancer, owned, false);
    addHiddenFinalProp(adm.values_, $mobx, adm);
    var proxy = new Proxy(adm.values_, arrayTraps);
    adm.proxy_ = proxy;
    if (initialValues && initialValues.length) {
      var prev2 = allowStateChangesStart(true);
      adm.spliceWithArray_(0, 0, initialValues);
      allowStateChangesEnd(prev2);
    }
    return proxy;
  }
  var arrayExtensions = {
    clear: function clear() {
      return this.splice(0);
    },
    replace: function replace2(newItems) {
      var adm = this[$mobx];
      return adm.spliceWithArray_(0, adm.values_.length, newItems);
    },
    // Used by JSON.stringify
    toJSON: function toJSON() {
      return this.slice();
    },
    /*
     * functions that do alter the internal structure of the array, (based on lib.es6.d.ts)
     * since these functions alter the inner structure of the array, the have side effects.
     * Because the have side effects, they should not be used in computed function,
     * and for that reason the do not call dependencyState.notifyObserved
     */
    splice: function splice(index2, deleteCount) {
      for (var _len = arguments.length, newItems = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        newItems[_key - 2] = arguments[_key];
      }
      var adm = this[$mobx];
      switch (arguments.length) {
        case 0:
          return [];
        case 1:
          return adm.spliceWithArray_(index2);
        case 2:
          return adm.spliceWithArray_(index2, deleteCount);
      }
      return adm.spliceWithArray_(index2, deleteCount, newItems);
    },
    spliceWithArray: function spliceWithArray(index2, deleteCount, newItems) {
      return this[$mobx].spliceWithArray_(index2, deleteCount, newItems);
    },
    push: function push() {
      var adm = this[$mobx];
      for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        items[_key2] = arguments[_key2];
      }
      adm.spliceWithArray_(adm.values_.length, 0, items);
      return adm.values_.length;
    },
    pop: function pop() {
      return this.splice(Math.max(this[$mobx].values_.length - 1, 0), 1)[0];
    },
    shift: function shift() {
      return this.splice(0, 1)[0];
    },
    unshift: function unshift() {
      var adm = this[$mobx];
      for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        items[_key3] = arguments[_key3];
      }
      adm.spliceWithArray_(0, 0, items);
      return adm.values_.length;
    },
    reverse: function reverse() {
      if (globalState.trackingDerivation) {
        die(37, "reverse");
      }
      this.replace(this.slice().reverse());
      return this;
    },
    sort: function sort() {
      if (globalState.trackingDerivation) {
        die(37, "sort");
      }
      var copy = this.slice();
      copy.sort.apply(copy, arguments);
      this.replace(copy);
      return this;
    },
    remove: function remove(value) {
      var adm = this[$mobx];
      var idx = adm.dehanceValues_(adm.values_).indexOf(value);
      if (idx > -1) {
        this.splice(idx, 1);
        return true;
      }
      return false;
    }
  };
  addArrayExtension("concat", simpleFunc);
  addArrayExtension("flat", simpleFunc);
  addArrayExtension("includes", simpleFunc);
  addArrayExtension("indexOf", simpleFunc);
  addArrayExtension("join", simpleFunc);
  addArrayExtension("lastIndexOf", simpleFunc);
  addArrayExtension("slice", simpleFunc);
  addArrayExtension("toString", simpleFunc);
  addArrayExtension("toLocaleString", simpleFunc);
  addArrayExtension("every", mapLikeFunc);
  addArrayExtension("filter", mapLikeFunc);
  addArrayExtension("find", mapLikeFunc);
  addArrayExtension("findIndex", mapLikeFunc);
  addArrayExtension("flatMap", mapLikeFunc);
  addArrayExtension("forEach", mapLikeFunc);
  addArrayExtension("map", mapLikeFunc);
  addArrayExtension("some", mapLikeFunc);
  addArrayExtension("reduce", reduceLikeFunc);
  addArrayExtension("reduceRight", reduceLikeFunc);
  function addArrayExtension(funcName, funcFactory) {
    if (typeof Array.prototype[funcName] === "function") {
      arrayExtensions[funcName] = funcFactory(funcName);
    }
  }
  function simpleFunc(funcName) {
    return function() {
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  function mapLikeFunc(funcName) {
    return function(callback, thisArg) {
      var _this2 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      return dehancedValues[funcName](function(element, index2) {
        return callback.call(thisArg, element, index2, _this2);
      });
    };
  }
  function reduceLikeFunc(funcName) {
    return function() {
      var _this3 = this;
      var adm = this[$mobx];
      adm.atom_.reportObserved();
      var dehancedValues = adm.dehanceValues_(adm.values_);
      var callback = arguments[0];
      arguments[0] = function(accumulator, currentValue, index2) {
        return callback(accumulator, currentValue, index2, _this3);
      };
      return dehancedValues[funcName].apply(dehancedValues, arguments);
    };
  }
  var isObservableArrayAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableArrayAdministration", ObservableArrayAdministration);
  function isObservableArray(thing) {
    return isObject$1(thing) && isObservableArrayAdministration(thing[$mobx]);
  }
  var _Symbol$iterator, _Symbol$toStringTag;
  var ObservableMapMarker = {};
  var ADD = "add";
  var DELETE = "delete";
  _Symbol$iterator = Symbol.iterator;
  _Symbol$toStringTag = Symbol.toStringTag;
  var ObservableMap = /* @__PURE__ */ function() {
    function ObservableMap2(initialData, enhancer_, name_) {
      var _this = this;
      if (enhancer_ === void 0) {
        enhancer_ = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = "ObservableMap";
      }
      this.enhancer_ = void 0;
      this.name_ = void 0;
      this[$mobx] = ObservableMapMarker;
      this.data_ = void 0;
      this.hasMap_ = void 0;
      this.keysAtom_ = void 0;
      this.interceptors_ = void 0;
      this.changeListeners_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = enhancer_;
      this.name_ = name_;
      if (!isFunction$2(Map)) {
        die(18);
      }
      this.keysAtom_ = createAtom("ObservableMap.keys()");
      this.data_ = /* @__PURE__ */ new Map();
      this.hasMap_ = /* @__PURE__ */ new Map();
      allowStateChanges(true, function() {
        _this.merge(initialData);
      });
    }
    var _proto = ObservableMap2.prototype;
    _proto.has_ = function has_(key) {
      return this.data_.has(key);
    };
    _proto.has = function has2(key) {
      var _this2 = this;
      if (!globalState.trackingDerivation) {
        return this.has_(key);
      }
      var entry = this.hasMap_.get(key);
      if (!entry) {
        var newEntry = entry = new ObservableValue(this.has_(key), referenceEnhancer, "ObservableMap.key?", false);
        this.hasMap_.set(key, newEntry);
        onBecomeUnobserved(newEntry, function() {
          return _this2.hasMap_["delete"](key);
        });
      }
      return entry.get();
    };
    _proto.set = function set5(key, value) {
      var hasKey = this.has_(key);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: hasKey ? UPDATE : ADD,
          object: this,
          newValue: value,
          name: key
        });
        if (!change) {
          return this;
        }
        value = change.newValue;
      }
      if (hasKey) {
        this.updateValue_(key, value);
      } else {
        this.addValue_(key, value);
      }
      return this;
    };
    _proto["delete"] = function _delete(key) {
      var _this3 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          name: key
        });
        if (!change) {
          return false;
        }
      }
      if (this.has_(key)) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: this.data_.get(key).value_,
          name: key
        } : null;
        transaction(function() {
          var _this3$hasMap_$get;
          _this3.keysAtom_.reportChanged();
          (_this3$hasMap_$get = _this3.hasMap_.get(key)) == null ? void 0 : _this3$hasMap_$get.setNewValue_(false);
          var observable2 = _this3.data_.get(key);
          observable2.setNewValue_(void 0);
          _this3.data_["delete"](key);
        });
        if (notify) {
          notifyListeners(this, _change);
        }
        return true;
      }
      return false;
    };
    _proto.updateValue_ = function updateValue_(key, newValue) {
      var observable2 = this.data_.get(key);
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notifySpy = isSpyEnabled();
        var notify = hasListeners(this);
        var change = notify || notifySpy ? {
          observableKind: "map",
          debugObjectName: this.name_,
          type: UPDATE,
          object: this,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        observable2.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, change);
        }
      }
    };
    _proto.addValue_ = function addValue_(key, newValue) {
      var _this4 = this;
      checkIfStateModificationsAreAllowed(this.keysAtom_);
      transaction(function() {
        var _this4$hasMap_$get;
        var observable2 = new ObservableValue(newValue, _this4.enhancer_, "ObservableMap.key", false);
        _this4.data_.set(key, observable2);
        newValue = observable2.value_;
        (_this4$hasMap_$get = _this4.hasMap_.get(key)) == null ? void 0 : _this4$hasMap_$get.setNewValue_(true);
        _this4.keysAtom_.reportChanged();
      });
      var notifySpy = isSpyEnabled();
      var notify = hasListeners(this);
      var change = notify || notifySpy ? {
        observableKind: "map",
        debugObjectName: this.name_,
        type: ADD,
        object: this,
        name: key,
        newValue
      } : null;
      if (notify) {
        notifyListeners(this, change);
      }
    };
    _proto.get = function get4(key) {
      if (this.has(key)) {
        return this.dehanceValue_(this.data_.get(key).get());
      }
      return this.dehanceValue_(void 0);
    };
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.keys = function keys2() {
      this.keysAtom_.reportObserved();
      return this.data_.keys();
    };
    _proto.values = function values() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next2() {
          var _keys$next = keys2.next(), done = _keys$next.done, value = _keys$next.value;
          return {
            done,
            value: done ? void 0 : self2.get(value)
          };
        }
      });
    };
    _proto.entries = function entries() {
      var self2 = this;
      var keys2 = this.keys();
      return makeIterable({
        next: function next2() {
          var _keys$next2 = keys2.next(), done = _keys$next2.done, value = _keys$next2.value;
          return {
            done,
            value: done ? void 0 : [value, self2.get(value)]
          };
        }
      });
    };
    _proto[_Symbol$iterator] = function() {
      return this.entries();
    };
    _proto.forEach = function forEach2(callback, thisArg) {
      for (var _iterator = _createForOfIteratorHelperLoose(this), _step; !(_step = _iterator()).done; ) {
        var _step$value = _step.value, key = _step$value[0], value = _step$value[1];
        callback.call(thisArg, value, key, this);
      }
    };
    _proto.merge = function merge2(other) {
      var _this5 = this;
      if (isObservableMap(other)) {
        other = new Map(other);
      }
      transaction(function() {
        if (isPlainObject$1(other)) {
          getPlainObjectKeys(other).forEach(function(key) {
            return _this5.set(key, other[key]);
          });
        } else if (Array.isArray(other)) {
          other.forEach(function(_ref) {
            var key = _ref[0], value = _ref[1];
            return _this5.set(key, value);
          });
        } else if (isES6Map(other)) {
          if (other.constructor !== Map) {
            die(19, other);
          }
          other.forEach(function(value, key) {
            return _this5.set(key, value);
          });
        } else if (other !== null && other !== void 0) {
          die(20, other);
        }
      });
      return this;
    };
    _proto.clear = function clear4() {
      var _this6 = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator2 = _createForOfIteratorHelperLoose(_this6.keys()), _step2; !(_step2 = _iterator2()).done; ) {
            var key = _step2.value;
            _this6["delete"](key);
          }
        });
      });
    };
    _proto.replace = function replace3(values) {
      var _this7 = this;
      transaction(function() {
        var replacementMap = convertToMap(values);
        var orderedData = /* @__PURE__ */ new Map();
        var keysReportChangedCalled = false;
        for (var _iterator3 = _createForOfIteratorHelperLoose(_this7.data_.keys()), _step3; !(_step3 = _iterator3()).done; ) {
          var key = _step3.value;
          if (!replacementMap.has(key)) {
            var deleted = _this7["delete"](key);
            if (deleted) {
              keysReportChangedCalled = true;
            } else {
              var value = _this7.data_.get(key);
              orderedData.set(key, value);
            }
          }
        }
        for (var _iterator4 = _createForOfIteratorHelperLoose(replacementMap.entries()), _step4; !(_step4 = _iterator4()).done; ) {
          var _step4$value = _step4.value, _key = _step4$value[0], _value = _step4$value[1];
          var keyExisted = _this7.data_.has(_key);
          _this7.set(_key, _value);
          if (_this7.data_.has(_key)) {
            var _value2 = _this7.data_.get(_key);
            orderedData.set(_key, _value2);
            if (!keyExisted) {
              keysReportChangedCalled = true;
            }
          }
        }
        if (!keysReportChangedCalled) {
          if (_this7.data_.size !== orderedData.size) {
            _this7.keysAtom_.reportChanged();
          } else {
            var iter1 = _this7.data_.keys();
            var iter2 = orderedData.keys();
            var next1 = iter1.next();
            var next2 = iter2.next();
            while (!next1.done) {
              if (next1.value !== next2.value) {
                _this7.keysAtom_.reportChanged();
                break;
              }
              next1 = iter1.next();
              next2 = iter2.next();
            }
          }
        }
        _this7.data_ = orderedData;
      });
      return this;
    };
    _proto.toString = function toString3() {
      return "[object ObservableMap]";
    };
    _proto.toJSON = function toJSON3() {
      return Array.from(this);
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _createClass(ObservableMap2, [{
      key: "size",
      get: function get4() {
        this.keysAtom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag,
      get: function get4() {
        return "Map";
      }
    }]);
    return ObservableMap2;
  }();
  var isObservableMap = /* @__PURE__ */ createInstanceofPredicate("ObservableMap", ObservableMap);
  function convertToMap(dataStructure) {
    if (isES6Map(dataStructure) || isObservableMap(dataStructure)) {
      return dataStructure;
    } else if (Array.isArray(dataStructure)) {
      return new Map(dataStructure);
    } else if (isPlainObject$1(dataStructure)) {
      var map2 = /* @__PURE__ */ new Map();
      for (var key in dataStructure) {
        map2.set(key, dataStructure[key]);
      }
      return map2;
    } else {
      return die(21, dataStructure);
    }
  }
  var _Symbol$iterator$1, _Symbol$toStringTag$1;
  var ObservableSetMarker = {};
  _Symbol$iterator$1 = Symbol.iterator;
  _Symbol$toStringTag$1 = Symbol.toStringTag;
  var ObservableSet = /* @__PURE__ */ function() {
    function ObservableSet2(initialData, enhancer, name_) {
      if (enhancer === void 0) {
        enhancer = deepEnhancer;
      }
      if (name_ === void 0) {
        name_ = "ObservableSet";
      }
      this.name_ = void 0;
      this[$mobx] = ObservableSetMarker;
      this.data_ = /* @__PURE__ */ new Set();
      this.atom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.dehancer = void 0;
      this.enhancer_ = void 0;
      this.name_ = name_;
      if (!isFunction$2(Set)) {
        die(22);
      }
      this.atom_ = createAtom(this.name_);
      this.enhancer_ = function(newV, oldV) {
        return enhancer(newV, oldV, name_);
      };
      if (initialData) {
        this.replace(initialData);
      }
    }
    var _proto = ObservableSet2.prototype;
    _proto.dehanceValue_ = function dehanceValue_(value) {
      if (this.dehancer !== void 0) {
        return this.dehancer(value);
      }
      return value;
    };
    _proto.clear = function clear4() {
      var _this = this;
      transaction(function() {
        untracked(function() {
          for (var _iterator = _createForOfIteratorHelperLoose(_this.data_.values()), _step; !(_step = _iterator()).done; ) {
            var value = _step.value;
            _this["delete"](value);
          }
        });
      });
    };
    _proto.forEach = function forEach2(callbackFn, thisArg) {
      for (var _iterator2 = _createForOfIteratorHelperLoose(this), _step2; !(_step2 = _iterator2()).done; ) {
        var value = _step2.value;
        callbackFn.call(thisArg, value, value, this);
      }
    };
    _proto.add = function add(value) {
      var _this2 = this;
      checkIfStateModificationsAreAllowed(this.atom_);
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: ADD,
          object: this,
          newValue: value
        });
        if (!change) {
          return this;
        }
      }
      if (!this.has(value)) {
        transaction(function() {
          _this2.data_.add(_this2.enhancer_(value, void 0));
          _this2.atom_.reportChanged();
        });
        var notifySpy = false;
        var notify = hasListeners(this);
        var _change = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: ADD,
          object: this,
          newValue: value
        } : null;
        if (notify) {
          notifyListeners(this, _change);
        }
      }
      return this;
    };
    _proto["delete"] = function _delete(value) {
      var _this3 = this;
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: DELETE,
          object: this,
          oldValue: value
        });
        if (!change) {
          return false;
        }
      }
      if (this.has(value)) {
        var notifySpy = false;
        var notify = hasListeners(this);
        var _change2 = notify || notifySpy ? {
          observableKind: "set",
          debugObjectName: this.name_,
          type: DELETE,
          object: this,
          oldValue: value
        } : null;
        transaction(function() {
          _this3.atom_.reportChanged();
          _this3.data_["delete"](value);
        });
        if (notify) {
          notifyListeners(this, _change2);
        }
        return true;
      }
      return false;
    };
    _proto.has = function has2(value) {
      this.atom_.reportObserved();
      return this.data_.has(this.dehanceValue_(value));
    };
    _proto.entries = function entries() {
      var nextIndex = 0;
      var keys2 = Array.from(this.keys());
      var values = Array.from(this.values());
      return makeIterable({
        next: function next2() {
          var index2 = nextIndex;
          nextIndex += 1;
          return index2 < values.length ? {
            value: [keys2[index2], values[index2]],
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.keys = function keys2() {
      return this.values();
    };
    _proto.values = function values() {
      this.atom_.reportObserved();
      var self2 = this;
      var nextIndex = 0;
      var observableValues = Array.from(this.data_.values());
      return makeIterable({
        next: function next2() {
          return nextIndex < observableValues.length ? {
            value: self2.dehanceValue_(observableValues[nextIndex++]),
            done: false
          } : {
            done: true
          };
        }
      });
    };
    _proto.replace = function replace3(other) {
      var _this4 = this;
      if (isObservableSet(other)) {
        other = new Set(other);
      }
      transaction(function() {
        if (Array.isArray(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (isES6Set(other)) {
          _this4.clear();
          other.forEach(function(value) {
            return _this4.add(value);
          });
        } else if (other !== null && other !== void 0) {
          die("Cannot initialize set from " + other);
        }
      });
      return this;
    };
    _proto.observe_ = function observe_(listener, fireImmediately) {
      return registerListener(this, listener);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.toJSON = function toJSON3() {
      return Array.from(this);
    };
    _proto.toString = function toString3() {
      return "[object ObservableSet]";
    };
    _proto[_Symbol$iterator$1] = function() {
      return this.values();
    };
    _createClass(ObservableSet2, [{
      key: "size",
      get: function get4() {
        this.atom_.reportObserved();
        return this.data_.size;
      }
    }, {
      key: _Symbol$toStringTag$1,
      get: function get4() {
        return "Set";
      }
    }]);
    return ObservableSet2;
  }();
  var isObservableSet = /* @__PURE__ */ createInstanceofPredicate("ObservableSet", ObservableSet);
  var descriptorCache = /* @__PURE__ */ Object.create(null);
  var REMOVE = "remove";
  var ObservableObjectAdministration = /* @__PURE__ */ function() {
    function ObservableObjectAdministration2(target_, values_, name_, defaultAnnotation_) {
      if (values_ === void 0) {
        values_ = /* @__PURE__ */ new Map();
      }
      if (defaultAnnotation_ === void 0) {
        defaultAnnotation_ = autoAnnotation;
      }
      this.target_ = void 0;
      this.values_ = void 0;
      this.name_ = void 0;
      this.defaultAnnotation_ = void 0;
      this.keysAtom_ = void 0;
      this.changeListeners_ = void 0;
      this.interceptors_ = void 0;
      this.proxy_ = void 0;
      this.isPlainObject_ = void 0;
      this.appliedAnnotations_ = void 0;
      this.pendingKeys_ = void 0;
      this.target_ = target_;
      this.values_ = values_;
      this.name_ = name_;
      this.defaultAnnotation_ = defaultAnnotation_;
      this.keysAtom_ = new Atom("ObservableObject.keys");
      this.isPlainObject_ = isPlainObject$1(this.target_);
    }
    var _proto = ObservableObjectAdministration2.prototype;
    _proto.getObservablePropValue_ = function getObservablePropValue_(key) {
      return this.values_.get(key).get();
    };
    _proto.setObservablePropValue_ = function setObservablePropValue_(key, newValue) {
      var observable2 = this.values_.get(key);
      if (observable2 instanceof ComputedValue) {
        observable2.set(newValue);
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          type: UPDATE,
          object: this.proxy_ || this.target_,
          name: key,
          newValue
        });
        if (!change) {
          return null;
        }
        newValue = change.newValue;
      }
      newValue = observable2.prepareNewValue_(newValue);
      if (newValue !== globalState.UNCHANGED) {
        var notify = hasListeners(this);
        var notifySpy = false;
        var _change = notify || notifySpy ? {
          type: UPDATE,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          oldValue: observable2.value_,
          name: key,
          newValue
        } : null;
        observable2.setNewValue_(newValue);
        if (notify) {
          notifyListeners(this, _change);
        }
      }
      return true;
    };
    _proto.get_ = function get_(key) {
      if (globalState.trackingDerivation && !hasProp(this.target_, key)) {
        this.has_(key);
      }
      return this.target_[key];
    };
    _proto.set_ = function set_(key, value, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (hasProp(this.target_, key)) {
        if (this.values_.has(key)) {
          return this.setObservablePropValue_(key, value);
        } else if (proxyTrap) {
          return Reflect.set(this.target_, key, value);
        } else {
          this.target_[key] = value;
          return true;
        }
      } else {
        return this.extend_(key, {
          value,
          enumerable: true,
          writable: true,
          configurable: true
        }, this.defaultAnnotation_, proxyTrap);
      }
    };
    _proto.has_ = function has_(key) {
      if (!globalState.trackingDerivation) {
        return key in this.target_;
      }
      this.pendingKeys_ || (this.pendingKeys_ = /* @__PURE__ */ new Map());
      var entry = this.pendingKeys_.get(key);
      if (!entry) {
        entry = new ObservableValue(key in this.target_, referenceEnhancer, "ObservableObject.key?", false);
        this.pendingKeys_.set(key, entry);
      }
      return entry.get();
    };
    _proto.make_ = function make_(key, annotation) {
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return;
      }
      if (!(key in this.target_)) {
        var _this$target_$storedA;
        if ((_this$target_$storedA = this.target_[storedAnnotationsSymbol]) != null && _this$target_$storedA[key]) {
          return;
        } else {
          die(1, annotation.annotationType_, this.name_ + "." + key.toString());
        }
      }
      var source = this.target_;
      while (source && source !== objectPrototype) {
        var descriptor = getDescriptor(source, key);
        if (descriptor) {
          var outcome = annotation.make_(this, key, descriptor, source);
          if (outcome === 0) {
            return;
          }
          if (outcome === 1) {
            break;
          }
        }
        source = Object.getPrototypeOf(source);
      }
      recordAnnotationApplied(this, annotation, key);
    };
    _proto.extend_ = function extend_(key, descriptor, annotation, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (annotation === true) {
        annotation = this.defaultAnnotation_;
      }
      if (annotation === false) {
        return this.defineProperty_(key, descriptor, proxyTrap);
      }
      var outcome = annotation.extend_(this, key, descriptor, proxyTrap);
      if (outcome) {
        recordAnnotationApplied(this, annotation, key);
      }
      return outcome;
    };
    _proto.defineProperty_ = function defineProperty_(key, descriptor, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: descriptor.value
          });
          if (!change) {
            return null;
          }
          var newValue = change.newValue;
          if (descriptor.value !== newValue) {
            descriptor = _extends({}, descriptor, {
              value: newValue
            });
          }
        }
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.notifyPropertyAddition_(key, descriptor.value);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineObservableProperty_ = function defineObservableProperty_(key, value, enhancer, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: value
          });
          if (!change) {
            return null;
          }
          value = change.newValue;
        }
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: true,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        var observable2 = new ObservableValue(value, enhancer, false ? this.name_ + "." + key.toString() : "ObservableObject.key", false);
        this.values_.set(key, observable2);
        this.notifyPropertyAddition_(key, observable2.value_);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.defineComputedProperty_ = function defineComputedProperty_(key, options, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      try {
        startBatch();
        var deleteOutcome = this.delete_(key);
        if (!deleteOutcome) {
          return deleteOutcome;
        }
        if (hasInterceptors(this)) {
          var change = interceptChange(this, {
            object: this.proxy_ || this.target_,
            name: key,
            type: ADD,
            newValue: void 0
          });
          if (!change) {
            return null;
          }
        }
        options.name || (options.name = false ? this.name_ + "." + key.toString() : "ObservableObject.key");
        options.context = this.proxy_ || this.target_;
        var cachedDescriptor = getCachedObservablePropDescriptor(key);
        var descriptor = {
          configurable: globalState.safeDescriptors ? this.isPlainObject_ : true,
          enumerable: false,
          get: cachedDescriptor.get,
          set: cachedDescriptor.set
        };
        if (proxyTrap) {
          if (!Reflect.defineProperty(this.target_, key, descriptor)) {
            return false;
          }
        } else {
          defineProperty(this.target_, key, descriptor);
        }
        this.values_.set(key, new ComputedValue(options));
        this.notifyPropertyAddition_(key, void 0);
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.delete_ = function delete_(key, proxyTrap) {
      if (proxyTrap === void 0) {
        proxyTrap = false;
      }
      if (!hasProp(this.target_, key)) {
        return true;
      }
      if (hasInterceptors(this)) {
        var change = interceptChange(this, {
          object: this.proxy_ || this.target_,
          name: key,
          type: REMOVE
        });
        if (!change) {
          return null;
        }
      }
      try {
        var _this$pendingKeys_, _this$pendingKeys_$ge;
        startBatch();
        var notify = hasListeners(this);
        var notifySpy = false;
        var observable2 = this.values_.get(key);
        var value = void 0;
        if (!observable2 && (notify || notifySpy)) {
          var _getDescriptor2;
          value = (_getDescriptor2 = getDescriptor(this.target_, key)) == null ? void 0 : _getDescriptor2.value;
        }
        if (proxyTrap) {
          if (!Reflect.deleteProperty(this.target_, key)) {
            return false;
          }
        } else {
          delete this.target_[key];
        }
        if (false)
          ;
        if (observable2) {
          this.values_["delete"](key);
          if (observable2 instanceof ObservableValue) {
            value = observable2.value_;
          }
          propagateChanged(observable2);
        }
        this.keysAtom_.reportChanged();
        (_this$pendingKeys_ = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_$ge = _this$pendingKeys_.get(key)) == null ? void 0 : _this$pendingKeys_$ge.set(key in this.target_);
        if (notify || notifySpy) {
          var _change2 = {
            type: REMOVE,
            observableKind: "object",
            object: this.proxy_ || this.target_,
            debugObjectName: this.name_,
            oldValue: value,
            name: key
          };
          if (false)
            ;
          if (notify) {
            notifyListeners(this, _change2);
          }
          if (false)
            ;
        }
      } finally {
        endBatch();
      }
      return true;
    };
    _proto.observe_ = function observe_(callback, fireImmediately) {
      return registerListener(this, callback);
    };
    _proto.intercept_ = function intercept_(handler) {
      return registerInterceptor(this, handler);
    };
    _proto.notifyPropertyAddition_ = function notifyPropertyAddition_(key, value) {
      var _this$pendingKeys_2, _this$pendingKeys_2$g;
      var notify = hasListeners(this);
      var notifySpy = false;
      if (notify || notifySpy) {
        var change = notify || notifySpy ? {
          type: ADD,
          observableKind: "object",
          debugObjectName: this.name_,
          object: this.proxy_ || this.target_,
          name: key,
          newValue: value
        } : null;
        if (notify) {
          notifyListeners(this, change);
        }
      }
      (_this$pendingKeys_2 = this.pendingKeys_) == null ? void 0 : (_this$pendingKeys_2$g = _this$pendingKeys_2.get(key)) == null ? void 0 : _this$pendingKeys_2$g.set(true);
      this.keysAtom_.reportChanged();
    };
    _proto.ownKeys_ = function ownKeys_() {
      this.keysAtom_.reportObserved();
      return ownKeys(this.target_);
    };
    _proto.keys_ = function keys_() {
      this.keysAtom_.reportObserved();
      return Object.keys(this.target_);
    };
    return ObservableObjectAdministration2;
  }();
  function asObservableObject(target, options) {
    var _options$name;
    if (hasProp(target, $mobx)) {
      return target;
    }
    var name = (_options$name = options == null ? void 0 : options.name) != null ? _options$name : "ObservableObject";
    var adm = new ObservableObjectAdministration(target, /* @__PURE__ */ new Map(), String(name), getAnnotationFromOptions(options));
    addHiddenProp(target, $mobx, adm);
    return target;
  }
  var isObservableObjectAdministration = /* @__PURE__ */ createInstanceofPredicate("ObservableObjectAdministration", ObservableObjectAdministration);
  function getCachedObservablePropDescriptor(key) {
    return descriptorCache[key] || (descriptorCache[key] = {
      get: function get4() {
        return this[$mobx].getObservablePropValue_(key);
      },
      set: function set5(value) {
        return this[$mobx].setObservablePropValue_(key, value);
      }
    });
  }
  function isObservableObject(thing) {
    if (isObject$1(thing)) {
      return isObservableObjectAdministration(thing[$mobx]);
    }
    return false;
  }
  function recordAnnotationApplied(adm, annotation, key) {
    var _adm$target_$storedAn;
    (_adm$target_$storedAn = adm.target_[storedAnnotationsSymbol]) == null ? true : delete _adm$target_$storedAn[key];
  }
  var ENTRY_0 = /* @__PURE__ */ createArrayEntryDescriptor(0);
  var OBSERVABLE_ARRAY_BUFFER_SIZE = 0;
  var StubArray = function StubArray2() {
  };
  function inherit(ctor, proto) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(ctor.prototype, proto);
    } else if (ctor.prototype.__proto__ !== void 0) {
      ctor.prototype.__proto__ = proto;
    } else {
      ctor.prototype = proto;
    }
  }
  inherit(StubArray, Array.prototype);
  var LegacyObservableArray = /* @__PURE__ */ function(_StubArray, _Symbol$toStringTag2, _Symbol$iterator2) {
    _inheritsLoose(LegacyObservableArray2, _StubArray);
    function LegacyObservableArray2(initialValues, enhancer, name, owned) {
      var _this;
      if (name === void 0) {
        name = "ObservableArray";
      }
      if (owned === void 0) {
        owned = false;
      }
      _this = _StubArray.call(this) || this;
      var adm = new ObservableArrayAdministration(name, enhancer, owned, true);
      adm.proxy_ = _assertThisInitialized(_this);
      addHiddenFinalProp(_assertThisInitialized(_this), $mobx, adm);
      if (initialValues && initialValues.length) {
        var prev2 = allowStateChangesStart(true);
        _this.spliceWithArray(0, 0, initialValues);
        allowStateChangesEnd(prev2);
      }
      {
        Object.defineProperty(_assertThisInitialized(_this), "0", ENTRY_0);
      }
      return _this;
    }
    var _proto = LegacyObservableArray2.prototype;
    _proto.concat = function concat() {
      this[$mobx].atom_.reportObserved();
      for (var _len = arguments.length, arrays = new Array(_len), _key = 0; _key < _len; _key++) {
        arrays[_key] = arguments[_key];
      }
      return Array.prototype.concat.apply(
        this.slice(),
        //@ts-ignore
        arrays.map(function(a) {
          return isObservableArray(a) ? a.slice() : a;
        })
      );
    };
    _proto[_Symbol$iterator2] = function() {
      var self2 = this;
      var nextIndex = 0;
      return makeIterable({
        next: function next2() {
          return nextIndex < self2.length ? {
            value: self2[nextIndex++],
            done: false
          } : {
            done: true,
            value: void 0
          };
        }
      });
    };
    _createClass(LegacyObservableArray2, [{
      key: "length",
      get: function get4() {
        return this[$mobx].getArrayLength_();
      },
      set: function set5(newLength) {
        this[$mobx].setArrayLength_(newLength);
      }
    }, {
      key: _Symbol$toStringTag2,
      get: function get4() {
        return "Array";
      }
    }]);
    return LegacyObservableArray2;
  }(StubArray, Symbol.toStringTag, Symbol.iterator);
  Object.entries(arrayExtensions).forEach(function(_ref) {
    var prop = _ref[0], fn = _ref[1];
    if (prop !== "concat") {
      addHiddenProp(LegacyObservableArray.prototype, prop, fn);
    }
  });
  function createArrayEntryDescriptor(index2) {
    return {
      enumerable: false,
      configurable: true,
      get: function get4() {
        return this[$mobx].get_(index2);
      },
      set: function set5(value) {
        this[$mobx].set_(index2, value);
      }
    };
  }
  function createArrayBufferItem(index2) {
    defineProperty(LegacyObservableArray.prototype, "" + index2, createArrayEntryDescriptor(index2));
  }
  function reserveArrayBuffer(max) {
    if (max > OBSERVABLE_ARRAY_BUFFER_SIZE) {
      for (var index2 = OBSERVABLE_ARRAY_BUFFER_SIZE; index2 < max + 100; index2++) {
        createArrayBufferItem(index2);
      }
      OBSERVABLE_ARRAY_BUFFER_SIZE = max;
    }
  }
  reserveArrayBuffer(1e3);
  function createLegacyArray(initialValues, enhancer, name) {
    return new LegacyObservableArray(initialValues, enhancer, name);
  }
  function getAtom(thing, property) {
    if (typeof thing === "object" && thing !== null) {
      if (isObservableArray(thing)) {
        if (property !== void 0) {
          die(23);
        }
        return thing[$mobx].atom_;
      }
      if (isObservableSet(thing)) {
        return thing.atom_;
      }
      if (isObservableMap(thing)) {
        if (property === void 0) {
          return thing.keysAtom_;
        }
        var observable2 = thing.data_.get(property) || thing.hasMap_.get(property);
        if (!observable2) {
          die(25, property, getDebugName(thing));
        }
        return observable2;
      }
      if (isObservableObject(thing)) {
        if (!property) {
          return die(26);
        }
        var _observable = thing[$mobx].values_.get(property);
        if (!_observable) {
          die(27, property, getDebugName(thing));
        }
        return _observable;
      }
      if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
        return thing;
      }
    } else if (isFunction$2(thing)) {
      if (isReaction(thing[$mobx])) {
        return thing[$mobx];
      }
    }
    die(28);
  }
  function getAdministration(thing, property) {
    if (!thing) {
      die(29);
    }
    if (property !== void 0) {
      return getAdministration(getAtom(thing, property));
    }
    if (isAtom(thing) || isComputedValue(thing) || isReaction(thing)) {
      return thing;
    }
    if (isObservableMap(thing) || isObservableSet(thing)) {
      return thing;
    }
    if (thing[$mobx]) {
      return thing[$mobx];
    }
    die(24, thing);
  }
  function getDebugName(thing, property) {
    var named;
    if (property !== void 0) {
      named = getAtom(thing, property);
    } else if (isAction(thing)) {
      return thing.name;
    } else if (isObservableObject(thing) || isObservableMap(thing) || isObservableSet(thing)) {
      named = getAdministration(thing);
    } else {
      named = getAtom(thing);
    }
    return named.name_;
  }
  var toString$1 = objectPrototype.toString;
  function deepEqual(a, b2, depth) {
    if (depth === void 0) {
      depth = -1;
    }
    return eq(a, b2, depth);
  }
  function eq(a, b2, depth, aStack, bStack) {
    if (a === b2) {
      return a !== 0 || 1 / a === 1 / b2;
    }
    if (a == null || b2 == null) {
      return false;
    }
    if (a !== a) {
      return b2 !== b2;
    }
    var type4 = typeof a;
    if (type4 !== "function" && type4 !== "object" && typeof b2 != "object") {
      return false;
    }
    var className = toString$1.call(a);
    if (className !== toString$1.call(b2)) {
      return false;
    }
    switch (className) {
      case "[object RegExp]":
      case "[object String]":
        return "" + a === "" + b2;
      case "[object Number]":
        if (+a !== +a) {
          return +b2 !== +b2;
        }
        return +a === 0 ? 1 / +a === 1 / b2 : +a === +b2;
      case "[object Date]":
      case "[object Boolean]":
        return +a === +b2;
      case "[object Symbol]":
        return typeof Symbol !== "undefined" && Symbol.valueOf.call(a) === Symbol.valueOf.call(b2);
      case "[object Map]":
      case "[object Set]":
        if (depth >= 0) {
          depth++;
        }
        break;
    }
    a = unwrap(a);
    b2 = unwrap(b2);
    var areArrays = className === "[object Array]";
    if (!areArrays) {
      if (typeof a != "object" || typeof b2 != "object") {
        return false;
      }
      var aCtor = a.constructor, bCtor = b2.constructor;
      if (aCtor !== bCtor && !(isFunction$2(aCtor) && aCtor instanceof aCtor && isFunction$2(bCtor) && bCtor instanceof bCtor) && "constructor" in a && "constructor" in b2) {
        return false;
      }
    }
    if (depth === 0) {
      return false;
    } else if (depth < 0) {
      depth = -1;
    }
    aStack = aStack || [];
    bStack = bStack || [];
    var length2 = aStack.length;
    while (length2--) {
      if (aStack[length2] === a) {
        return bStack[length2] === b2;
      }
    }
    aStack.push(a);
    bStack.push(b2);
    if (areArrays) {
      length2 = a.length;
      if (length2 !== b2.length) {
        return false;
      }
      while (length2--) {
        if (!eq(a[length2], b2[length2], depth - 1, aStack, bStack)) {
          return false;
        }
      }
    } else {
      var keys2 = Object.keys(a);
      var key;
      length2 = keys2.length;
      if (Object.keys(b2).length !== length2) {
        return false;
      }
      while (length2--) {
        key = keys2[length2];
        if (!(hasProp(b2, key) && eq(a[key], b2[key], depth - 1, aStack, bStack))) {
          return false;
        }
      }
    }
    aStack.pop();
    bStack.pop();
    return true;
  }
  function unwrap(a) {
    if (isObservableArray(a)) {
      return a.slice();
    }
    if (isES6Map(a) || isObservableMap(a)) {
      return Array.from(a.entries());
    }
    if (isES6Set(a) || isObservableSet(a)) {
      return Array.from(a.entries());
    }
    return a;
  }
  function makeIterable(iterator) {
    iterator[Symbol.iterator] = getSelf;
    return iterator;
  }
  function getSelf() {
    return this;
  }
  ["Symbol", "Map", "Set"].forEach(function(m2) {
    var g2 = getGlobal();
    if (typeof g2[m2] === "undefined") {
      die("MobX requires global '" + m2 + "' to be available or polyfilled");
    }
  });
  if (typeof __MOBX_DEVTOOLS_GLOBAL_HOOK__ === "object") {
    __MOBX_DEVTOOLS_GLOBAL_HOOK__.injectMobx({
      spy,
      extras: {
        getDebugName
      },
      $mobx
    });
  }
  if (!React.useState) {
    throw new Error("mobx-react-lite requires React with Hooks support");
  }
  if (!makeObservable) {
    throw new Error("mobx-react-lite@3 requires mobx at least version 6 to be available");
  }
  function defaultNoopBatch(callback) {
    callback();
  }
  function observerBatching(reactionScheduler3) {
    if (!reactionScheduler3) {
      reactionScheduler3 = defaultNoopBatch;
    }
    configure({ reactionScheduler: reactionScheduler3 });
  }
  function printDebugValue(v2) {
    return getDependencyTree(v2);
  }
  var REGISTRY_FINALIZE_AFTER = 1e4;
  var REGISTRY_SWEEP_INTERVAL = 1e4;
  var TimerBasedFinalizationRegistry = (
    /** @class */
    function() {
      function TimerBasedFinalizationRegistry2(finalize) {
        var _this = this;
        Object.defineProperty(this, "finalize", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: finalize
        });
        Object.defineProperty(this, "registrations", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: /* @__PURE__ */ new Map()
        });
        Object.defineProperty(this, "sweepTimeout", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        Object.defineProperty(this, "sweep", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: function(maxAge) {
            if (maxAge === void 0) {
              maxAge = REGISTRY_FINALIZE_AFTER;
            }
            clearTimeout(_this.sweepTimeout);
            _this.sweepTimeout = void 0;
            var now = Date.now();
            _this.registrations.forEach(function(registration, token2) {
              if (now - registration.registeredAt >= maxAge) {
                _this.finalize(registration.value);
                _this.registrations.delete(token2);
              }
            });
            if (_this.registrations.size > 0) {
              _this.scheduleSweep();
            }
          }
        });
        Object.defineProperty(this, "finalizeAllImmediately", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: function() {
            _this.sweep(0);
          }
        });
      }
      Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "register", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function(target, value, token2) {
          this.registrations.set(token2, {
            value,
            registeredAt: Date.now()
          });
          this.scheduleSweep();
        }
      });
      Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "unregister", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function(token2) {
          this.registrations.delete(token2);
        }
      });
      Object.defineProperty(TimerBasedFinalizationRegistry2.prototype, "scheduleSweep", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: function() {
          if (this.sweepTimeout === void 0) {
            this.sweepTimeout = setTimeout(this.sweep, REGISTRY_SWEEP_INTERVAL);
          }
        }
      });
      return TimerBasedFinalizationRegistry2;
    }()
  );
  var UniversalFinalizationRegistry = typeof FinalizationRegistry !== "undefined" ? FinalizationRegistry : TimerBasedFinalizationRegistry;
  var observerFinalizationRegistry = new UniversalFinalizationRegistry(function(adm) {
    var _a2;
    (_a2 = adm.reaction) === null || _a2 === void 0 ? void 0 : _a2.dispose();
    adm.reaction = null;
  });
  var __read = globalThis && globalThis.__read || function(o, n2) {
    var m2 = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m2)
      return o;
    var i = m2.call(o), r2, ar = [], e2;
    try {
      while ((n2 === void 0 || n2-- > 0) && !(r2 = i.next()).done)
        ar.push(r2.value);
    } catch (error) {
      e2 = { error };
    } finally {
      try {
        if (r2 && !r2.done && (m2 = i["return"]))
          m2.call(i);
      } finally {
        if (e2)
          throw e2.error;
      }
    }
    return ar;
  };
  function observerComponentNameFor(baseComponentName) {
    return "observer".concat(baseComponentName);
  }
  var ObjectToBeRetainedByReact = (
    /** @class */
    function() {
      function ObjectToBeRetainedByReact2() {
      }
      return ObjectToBeRetainedByReact2;
    }()
  );
  function objectToBeRetainedByReactFactory() {
    return new ObjectToBeRetainedByReact();
  }
  function useObserver(fn, baseComponentName) {
    if (baseComponentName === void 0) {
      baseComponentName = "observed";
    }
    var _a2 = __read(React.useState(objectToBeRetainedByReactFactory), 1), objectRetainedByReact = _a2[0];
    var _b = __read(React.useState(), 2), setState = _b[1];
    var forceUpdate = function() {
      return setState([]);
    };
    var admRef = React.useRef(null);
    if (!admRef.current) {
      admRef.current = {
        reaction: null,
        mounted: false,
        changedBeforeMount: false
      };
    }
    var adm = admRef.current;
    if (!adm.reaction) {
      adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
        if (adm.mounted) {
          forceUpdate();
        } else {
          adm.changedBeforeMount = true;
        }
      });
      observerFinalizationRegistry.register(objectRetainedByReact, adm, adm);
    }
    React.useDebugValue(adm.reaction, printDebugValue);
    React.useEffect(function() {
      observerFinalizationRegistry.unregister(adm);
      adm.mounted = true;
      if (adm.reaction) {
        if (adm.changedBeforeMount) {
          adm.changedBeforeMount = false;
          forceUpdate();
        }
      } else {
        adm.reaction = new Reaction(observerComponentNameFor(baseComponentName), function() {
          forceUpdate();
        });
        forceUpdate();
      }
      return function() {
        adm.reaction.dispose();
        adm.reaction = null;
        adm.mounted = false;
        adm.changedBeforeMount = false;
      };
    }, []);
    var rendering;
    var exception;
    adm.reaction.track(function() {
      try {
        rendering = fn();
      } catch (e2) {
        exception = e2;
      }
    });
    if (exception) {
      throw exception;
    }
    return rendering;
  }
  var hasSymbol = typeof Symbol === "function" && Symbol.for;
  var ReactForwardRefSymbol = hasSymbol ? Symbol.for("react.forward_ref") : typeof React.forwardRef === "function" && React.forwardRef(function(props) {
    return null;
  })["$$typeof"];
  var ReactMemoSymbol = hasSymbol ? Symbol.for("react.memo") : typeof React.memo === "function" && React.memo(function(props) {
    return null;
  })["$$typeof"];
  function observer$1(baseComponent, options) {
    var _a2;
    if (ReactMemoSymbol && baseComponent["$$typeof"] === ReactMemoSymbol) {
      throw new Error("[mobx-react-lite] You are trying to use `observer` on a function component wrapped in either another `observer` or `React.memo`. The observer already applies 'React.memo' for you.");
    }
    var useForwardRef = (_a2 = options === null || options === void 0 ? void 0 : options.forwardRef) !== null && _a2 !== void 0 ? _a2 : false;
    var render2 = baseComponent;
    var baseComponentName = baseComponent.displayName || baseComponent.name;
    if (ReactForwardRefSymbol && baseComponent["$$typeof"] === ReactForwardRefSymbol) {
      useForwardRef = true;
      render2 = baseComponent["render"];
      if (typeof render2 !== "function") {
        throw new Error("[mobx-react-lite] `render` property of ForwardRef was not a function");
      }
    }
    var observerComponent = function(props, ref) {
      return useObserver(function() {
        return render2(props, ref);
      }, baseComponentName);
    };
    if (baseComponentName !== "") {
      observerComponent.displayName = baseComponentName;
    }
    if (baseComponent.contextTypes) {
      observerComponent.contextTypes = baseComponent.contextTypes;
    }
    if (useForwardRef) {
      observerComponent = React.forwardRef(observerComponent);
    }
    observerComponent = React.memo(observerComponent);
    copyStaticProperties(baseComponent, observerComponent);
    return observerComponent;
  }
  var hoistBlackList = {
    $$typeof: true,
    render: true,
    compare: true,
    type: true,
    // Don't redefine `displayName`,
    // it's defined as getter-setter pair on `memo` (see #3192).
    displayName: true
  };
  function copyStaticProperties(base, target) {
    Object.keys(base).forEach(function(key) {
      if (!hoistBlackList[key]) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key));
      }
    });
  }
  function useLocalObservable(initializer, annotations) {
    return React.useState(function() {
      return observable(initializer(), annotations, { autoBind: true });
    })[0];
  }
  var _a;
  observerBatching(ReactDOM__default.unstable_batchedUpdates);
  (_a = observerFinalizationRegistry["finalizeAllImmediately"]) !== null && _a !== void 0 ? _a : function() {
  };
  var symbolId = 0;
  function createSymbol(name) {
    if (typeof Symbol === "function") {
      return Symbol(name);
    }
    var symbol = "__$mobx-react " + name + " (" + symbolId + ")";
    symbolId++;
    return symbol;
  }
  var createdSymbols = {};
  function newSymbol(name) {
    if (!createdSymbols[name]) {
      createdSymbols[name] = createSymbol(name);
    }
    return createdSymbols[name];
  }
  function shallowEqual(objA, objB) {
    if (is(objA, objB)) {
      return true;
    }
    if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
      return false;
    }
    var keysA = Object.keys(objA);
    var keysB = Object.keys(objB);
    if (keysA.length !== keysB.length) {
      return false;
    }
    for (var i = 0; i < keysA.length; i++) {
      if (!Object.hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
        return false;
      }
    }
    return true;
  }
  function is(x2, y2) {
    if (x2 === y2) {
      return x2 !== 0 || 1 / x2 === 1 / y2;
    } else {
      return x2 !== x2 && y2 !== y2;
    }
  }
  function setHiddenProp(target, prop, value) {
    if (!Object.hasOwnProperty.call(target, prop)) {
      Object.defineProperty(target, prop, {
        enumerable: false,
        configurable: true,
        writable: true,
        value
      });
    } else {
      target[prop] = value;
    }
  }
  var mobxMixins = /* @__PURE__ */ newSymbol("patchMixins");
  var mobxPatchedDefinition = /* @__PURE__ */ newSymbol("patchedDefinition");
  function getMixins(target, methodName) {
    var mixins = target[mobxMixins] = target[mobxMixins] || {};
    var methodMixins = mixins[methodName] = mixins[methodName] || {};
    methodMixins.locks = methodMixins.locks || 0;
    methodMixins.methods = methodMixins.methods || [];
    return methodMixins;
  }
  function wrapper(realMethod, mixins) {
    var _this = this;
    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      args[_key - 2] = arguments[_key];
    }
    mixins.locks++;
    try {
      var retVal;
      if (realMethod !== void 0 && realMethod !== null) {
        retVal = realMethod.apply(this, args);
      }
      return retVal;
    } finally {
      mixins.locks--;
      if (mixins.locks === 0) {
        mixins.methods.forEach(function(mx) {
          mx.apply(_this, args);
        });
      }
    }
  }
  function wrapFunction(realMethod, mixins) {
    var fn = function fn2() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }
      wrapper.call.apply(wrapper, [this, realMethod, mixins].concat(args));
    };
    return fn;
  }
  function patch(target, methodName, mixinMethod) {
    var mixins = getMixins(target, methodName);
    if (mixins.methods.indexOf(mixinMethod) < 0) {
      mixins.methods.push(mixinMethod);
    }
    var oldDefinition = Object.getOwnPropertyDescriptor(target, methodName);
    if (oldDefinition && oldDefinition[mobxPatchedDefinition]) {
      return;
    }
    var originalMethod = target[methodName];
    var newDefinition = createDefinition(target, methodName, oldDefinition ? oldDefinition.enumerable : void 0, mixins, originalMethod);
    Object.defineProperty(target, methodName, newDefinition);
  }
  function createDefinition(target, methodName, enumerable4, mixins, originalMethod) {
    var _ref;
    var wrappedFunc = wrapFunction(originalMethod, mixins);
    return _ref = {}, _ref[mobxPatchedDefinition] = true, _ref.get = function get4() {
      return wrappedFunc;
    }, _ref.set = function set5(value) {
      if (this === target) {
        wrappedFunc = wrapFunction(value, mixins);
      } else {
        var newDefinition = createDefinition(this, methodName, enumerable4, mixins, value);
        Object.defineProperty(this, methodName, newDefinition);
      }
    }, _ref.configurable = true, _ref.enumerable = enumerable4, _ref;
  }
  var mobxAdminProperty = $mobx || "$mobx";
  var mobxObserverProperty = /* @__PURE__ */ newSymbol("isMobXReactObserver");
  var mobxIsUnmounted = /* @__PURE__ */ newSymbol("isUnmounted");
  var skipRenderKey = /* @__PURE__ */ newSymbol("skipRender");
  var isForcingUpdateKey = /* @__PURE__ */ newSymbol("isForcingUpdate");
  function makeClassComponentObserver(componentClass) {
    var target = componentClass.prototype;
    if (componentClass[mobxObserverProperty]) {
      var displayName = getDisplayName(target);
      console.warn("The provided component class (" + displayName + ")\n                has already been declared as an observer component.");
    } else {
      componentClass[mobxObserverProperty] = true;
    }
    if (target.componentWillReact) {
      throw new Error("The componentWillReact life-cycle event is no longer supported");
    }
    if (componentClass["__proto__"] !== React.PureComponent) {
      if (!target.shouldComponentUpdate) {
        target.shouldComponentUpdate = observerSCU;
      } else if (target.shouldComponentUpdate !== observerSCU) {
        throw new Error("It is not allowed to use shouldComponentUpdate in observer based components.");
      }
    }
    makeObservableProp(target, "props");
    makeObservableProp(target, "state");
    if (componentClass.contextType) {
      makeObservableProp(target, "context");
    }
    var originalRender = target.render;
    if (typeof originalRender !== "function") {
      var _displayName = getDisplayName(target);
      throw new Error("[mobx-react] class component (" + _displayName + ") is missing `render` method.\n`observer` requires `render` being a function defined on prototype.\n`render = () => {}` or `render = function() {}` is not supported.");
    }
    target.render = function() {
      this.render = createReactiveRender.call(this, originalRender);
      return this.render();
    };
    patch(target, "componentDidMount", function() {
      this[mobxIsUnmounted] = false;
      if (!this.render[mobxAdminProperty]) {
        React.Component.prototype.forceUpdate.call(this);
      }
    });
    patch(target, "componentWillUnmount", function() {
      var reaction = this.render[mobxAdminProperty];
      if (reaction) {
        reaction.dispose();
        this.render[mobxAdminProperty] = null;
      } else {
        var _displayName2 = getDisplayName(this);
        console.warn("The reactive render of an observer class component (" + _displayName2 + ")\n                was overridden after MobX attached. This may result in a memory leak if the\n                overridden reactive render was not properly disposed.");
      }
      this[mobxIsUnmounted] = true;
    });
    return componentClass;
  }
  function getDisplayName(comp) {
    return comp.displayName || comp.name || comp.constructor && (comp.constructor.displayName || comp.constructor.name) || "<component>";
  }
  function createReactiveRender(originalRender) {
    var _this = this;
    setHiddenProp(this, skipRenderKey, false);
    setHiddenProp(this, isForcingUpdateKey, false);
    var initialName = getDisplayName(this);
    var boundOriginalRender = originalRender.bind(this);
    var isRenderingPending = false;
    var createReaction = function createReaction2() {
      var reaction = new Reaction(initialName + ".render()", function() {
        if (!isRenderingPending) {
          isRenderingPending = true;
          if (_this[mobxIsUnmounted] !== true) {
            var hasError = true;
            try {
              setHiddenProp(_this, isForcingUpdateKey, true);
              if (!_this[skipRenderKey]) {
                React.Component.prototype.forceUpdate.call(_this);
              }
              hasError = false;
            } finally {
              setHiddenProp(_this, isForcingUpdateKey, false);
              if (hasError) {
                reaction.dispose();
                _this.render[mobxAdminProperty] = null;
              }
            }
          }
        }
      });
      reaction["reactComponent"] = _this;
      return reaction;
    };
    function reactiveRender() {
      var _reactiveRender$mobxA;
      isRenderingPending = false;
      var reaction = (_reactiveRender$mobxA = reactiveRender[mobxAdminProperty]) != null ? _reactiveRender$mobxA : reactiveRender[mobxAdminProperty] = createReaction();
      var exception = void 0;
      var rendering = void 0;
      reaction.track(function() {
        try {
          rendering = allowStateChanges(false, boundOriginalRender);
        } catch (e2) {
          exception = e2;
        }
      });
      if (exception) {
        throw exception;
      }
      return rendering;
    }
    return reactiveRender;
  }
  function observerSCU(nextProps, nextState) {
    if (this.state !== nextState) {
      return true;
    }
    return !shallowEqual(this.props, nextProps);
  }
  function makeObservableProp(target, propName) {
    var valueHolderKey = newSymbol("reactProp_" + propName + "_valueHolder");
    var atomHolderKey = newSymbol("reactProp_" + propName + "_atomHolder");
    function getAtom2() {
      if (!this[atomHolderKey]) {
        setHiddenProp(this, atomHolderKey, createAtom("reactive " + propName));
      }
      return this[atomHolderKey];
    }
    Object.defineProperty(target, propName, {
      configurable: true,
      enumerable: true,
      get: function get4() {
        var prevReadState = false;
        if (allowStateReadsStart && allowStateReadsEnd) {
          prevReadState = allowStateReadsStart(true);
        }
        getAtom2.call(this).reportObserved();
        if (allowStateReadsStart && allowStateReadsEnd) {
          allowStateReadsEnd(prevReadState);
        }
        return this[valueHolderKey];
      },
      set: function set5(v2) {
        if (!this[isForcingUpdateKey] && !shallowEqual(this[valueHolderKey], v2)) {
          setHiddenProp(this, valueHolderKey, v2);
          setHiddenProp(this, skipRenderKey, true);
          getAtom2.call(this).reportChanged();
          setHiddenProp(this, skipRenderKey, false);
        } else {
          setHiddenProp(this, valueHolderKey, v2);
        }
      }
    });
  }
  function observer(component) {
    if (component["isMobxInjector"] === true) {
      console.warn("Mobx observer: You are trying to use `observer` on a component that already has `inject`. Please apply `observer` before applying `inject`");
    }
    if (Object.prototype.isPrototypeOf.call(React.Component, component) || Object.prototype.isPrototypeOf.call(React.PureComponent, component)) {
      return makeClassComponentObserver(component);
    } else {
      return observer$1(component);
    }
  }
  if (!React.Component)
    throw new Error("mobx-react requires React to be available");
  if (!observable)
    throw new Error("mobx-react requires mobx to be available");
  function bind$1(fn, thisArg) {
    return function wrap() {
      return fn.apply(thisArg, arguments);
    };
  }
  const { toString } = Object.prototype;
  const { getPrototypeOf } = Object;
  const kindOf = ((cache) => (thing) => {
    const str = toString.call(thing);
    return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
  })(/* @__PURE__ */ Object.create(null));
  const kindOfTest = (type4) => {
    type4 = type4.toLowerCase();
    return (thing) => kindOf(thing) === type4;
  };
  const typeOfTest = (type4) => (thing) => typeof thing === type4;
  const { isArray } = Array;
  const isUndefined = typeOfTest("undefined");
  function isBuffer(val) {
    return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
  }
  const isArrayBuffer = kindOfTest("ArrayBuffer");
  function isArrayBufferView(val) {
    let result;
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      result = ArrayBuffer.isView(val);
    } else {
      result = val && val.buffer && isArrayBuffer(val.buffer);
    }
    return result;
  }
  const isString$1 = typeOfTest("string");
  const isFunction$1 = typeOfTest("function");
  const isNumber = typeOfTest("number");
  const isObject = (thing) => thing !== null && typeof thing === "object";
  const isBoolean = (thing) => thing === true || thing === false;
  const isPlainObject = (val) => {
    if (kindOf(val) !== "object") {
      return false;
    }
    const prototype2 = getPrototypeOf(val);
    return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
  };
  const isDate = kindOfTest("Date");
  const isFile = kindOfTest("File");
  const isBlob = kindOfTest("Blob");
  const isFileList = kindOfTest("FileList");
  const isStream = (val) => isObject(val) && isFunction$1(val.pipe);
  const isFormData = (thing) => {
    let kind;
    return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$1(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
    kind === "object" && isFunction$1(thing.toString) && thing.toString() === "[object FormData]"));
  };
  const isURLSearchParams = kindOfTest("URLSearchParams");
  const trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  function forEach(obj, fn, { allOwnKeys = false } = {}) {
    if (obj === null || typeof obj === "undefined") {
      return;
    }
    let i;
    let l2;
    if (typeof obj !== "object") {
      obj = [obj];
    }
    if (isArray(obj)) {
      for (i = 0, l2 = obj.length; i < l2; i++) {
        fn.call(null, obj[i], i, obj);
      }
    } else {
      const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
      const len = keys2.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys2[i];
        fn.call(null, obj[key], key, obj);
      }
    }
  }
  function findKey(obj, key) {
    key = key.toLowerCase();
    const keys2 = Object.keys(obj);
    let i = keys2.length;
    let _key;
    while (i-- > 0) {
      _key = keys2[i];
      if (key === _key.toLowerCase()) {
        return _key;
      }
    }
    return null;
  }
  const _global = (() => {
    if (typeof globalThis !== "undefined")
      return globalThis;
    return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
  })();
  const isContextDefined = (context) => !isUndefined(context) && context !== _global;
  function merge() {
    const { caseless } = isContextDefined(this) && this || {};
    const result = {};
    const assignValue = (val, key) => {
      const targetKey = caseless && findKey(result, key) || key;
      if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
        result[targetKey] = merge(result[targetKey], val);
      } else if (isPlainObject(val)) {
        result[targetKey] = merge({}, val);
      } else if (isArray(val)) {
        result[targetKey] = val.slice();
      } else {
        result[targetKey] = val;
      }
    };
    for (let i = 0, l2 = arguments.length; i < l2; i++) {
      arguments[i] && forEach(arguments[i], assignValue);
    }
    return result;
  }
  const extend = (a, b2, thisArg, { allOwnKeys } = {}) => {
    forEach(b2, (val, key) => {
      if (thisArg && isFunction$1(val)) {
        a[key] = bind$1(val, thisArg);
      } else {
        a[key] = val;
      }
    }, { allOwnKeys });
    return a;
  };
  const stripBOM = (content) => {
    if (content.charCodeAt(0) === 65279) {
      content = content.slice(1);
    }
    return content;
  };
  const inherits = (constructor, superConstructor, props, descriptors2) => {
    constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
    constructor.prototype.constructor = constructor;
    Object.defineProperty(constructor, "super", {
      value: superConstructor.prototype
    });
    props && Object.assign(constructor.prototype, props);
  };
  const toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
    let props;
    let i;
    let prop;
    const merged = {};
    destObj = destObj || {};
    if (sourceObj == null)
      return destObj;
    do {
      props = Object.getOwnPropertyNames(sourceObj);
      i = props.length;
      while (i-- > 0) {
        prop = props[i];
        if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
          destObj[prop] = sourceObj[prop];
          merged[prop] = true;
        }
      }
      sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
    } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
    return destObj;
  };
  const endsWith = (str, searchString, position2) => {
    str = String(str);
    if (position2 === void 0 || position2 > str.length) {
      position2 = str.length;
    }
    position2 -= searchString.length;
    const lastIndex = str.indexOf(searchString, position2);
    return lastIndex !== -1 && lastIndex === position2;
  };
  const toArray = (thing) => {
    if (!thing)
      return null;
    if (isArray(thing))
      return thing;
    let i = thing.length;
    if (!isNumber(i))
      return null;
    const arr = new Array(i);
    while (i-- > 0) {
      arr[i] = thing[i];
    }
    return arr;
  };
  const isTypedArray = ((TypedArray) => {
    return (thing) => {
      return TypedArray && thing instanceof TypedArray;
    };
  })(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
  const forEachEntry = (obj, fn) => {
    const generator = obj && obj[Symbol.iterator];
    const iterator = generator.call(obj);
    let result;
    while ((result = iterator.next()) && !result.done) {
      const pair = result.value;
      fn.call(obj, pair[0], pair[1]);
    }
  };
  const matchAll = (regExp, str) => {
    let matches;
    const arr = [];
    while ((matches = regExp.exec(str)) !== null) {
      arr.push(matches);
    }
    return arr;
  };
  const isHTMLForm = kindOfTest("HTMLFormElement");
  const toCamelCase = (str) => {
    return str.toLowerCase().replace(
      /[-_\s]([a-z\d])(\w*)/g,
      function replacer(m2, p1, p2) {
        return p1.toUpperCase() + p2;
      }
    );
  };
  const hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
  const isRegExp = kindOfTest("RegExp");
  const reduceDescriptors = (obj, reducer) => {
    const descriptors2 = Object.getOwnPropertyDescriptors(obj);
    const reducedDescriptors = {};
    forEach(descriptors2, (descriptor, name) => {
      if (reducer(descriptor, name, obj) !== false) {
        reducedDescriptors[name] = descriptor;
      }
    });
    Object.defineProperties(obj, reducedDescriptors);
  };
  const freezeMethods = (obj) => {
    reduceDescriptors(obj, (descriptor, name) => {
      if (isFunction$1(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
        return false;
      }
      const value = obj[name];
      if (!isFunction$1(value))
        return;
      descriptor.enumerable = false;
      if ("writable" in descriptor) {
        descriptor.writable = false;
        return;
      }
      if (!descriptor.set) {
        descriptor.set = () => {
          throw Error("Can not rewrite read-only method '" + name + "'");
        };
      }
    });
  };
  const toObjectSet = (arrayOrString, delimiter2) => {
    const obj = {};
    const define = (arr) => {
      arr.forEach((value) => {
        obj[value] = true;
      });
    };
    isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter2));
    return obj;
  };
  const noop2 = () => {
  };
  const toFiniteNumber = (value, defaultValue) => {
    value = +value;
    return Number.isFinite(value) ? value : defaultValue;
  };
  const ALPHA = "abcdefghijklmnopqrstuvwxyz";
  const DIGIT = "0123456789";
  const ALPHABET = {
    DIGIT,
    ALPHA,
    ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
  };
  const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
    let str = "";
    const { length: length2 } = alphabet;
    while (size--) {
      str += alphabet[Math.random() * length2 | 0];
    }
    return str;
  };
  function isSpecCompliantForm(thing) {
    return !!(thing && isFunction$1(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
  }
  const toJSONObject = (obj) => {
    const stack = new Array(10);
    const visit = (source, i) => {
      if (isObject(source)) {
        if (stack.indexOf(source) >= 0) {
          return;
        }
        if (!("toJSON" in source)) {
          stack[i] = source;
          const target = isArray(source) ? [] : {};
          forEach(source, (value, key) => {
            const reducedValue = visit(value, i + 1);
            !isUndefined(reducedValue) && (target[key] = reducedValue);
          });
          stack[i] = void 0;
          return target;
        }
      }
      return source;
    };
    return visit(obj, 0);
  };
  const isAsyncFn = kindOfTest("AsyncFunction");
  const isThenable = (thing) => thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);
  const utils = {
    isArray,
    isArrayBuffer,
    isBuffer,
    isFormData,
    isArrayBufferView,
    isString: isString$1,
    isNumber,
    isBoolean,
    isObject,
    isPlainObject,
    isUndefined,
    isDate,
    isFile,
    isBlob,
    isRegExp,
    isFunction: isFunction$1,
    isStream,
    isURLSearchParams,
    isTypedArray,
    isFileList,
    forEach,
    merge,
    extend,
    trim,
    stripBOM,
    inherits,
    toFlatObject,
    kindOf,
    kindOfTest,
    endsWith,
    toArray,
    forEachEntry,
    matchAll,
    isHTMLForm,
    hasOwnProperty,
    hasOwnProp: hasOwnProperty,
    // an alias to avoid ESLint no-prototype-builtins detection
    reduceDescriptors,
    freezeMethods,
    toObjectSet,
    toCamelCase,
    noop: noop2,
    toFiniteNumber,
    findKey,
    global: _global,
    isContextDefined,
    ALPHABET,
    generateString,
    isSpecCompliantForm,
    toJSONObject,
    isAsyncFn,
    isThenable
  };
  function AxiosError(message, code, config, request, response) {
    Error.call(this);
    if (Error.captureStackTrace) {
      Error.captureStackTrace(this, this.constructor);
    } else {
      this.stack = new Error().stack;
    }
    this.message = message;
    this.name = "AxiosError";
    code && (this.code = code);
    config && (this.config = config);
    request && (this.request = request);
    response && (this.response = response);
  }
  utils.inherits(AxiosError, Error, {
    toJSON: function toJSON2() {
      return {
        // Standard
        message: this.message,
        name: this.name,
        // Microsoft
        description: this.description,
        number: this.number,
        // Mozilla
        fileName: this.fileName,
        lineNumber: this.lineNumber,
        columnNumber: this.columnNumber,
        stack: this.stack,
        // Axios
        config: utils.toJSONObject(this.config),
        code: this.code,
        status: this.response && this.response.status ? this.response.status : null
      };
    }
  });
  const prototype$1 = AxiosError.prototype;
  const descriptors = {};
  [
    "ERR_BAD_OPTION_VALUE",
    "ERR_BAD_OPTION",
    "ECONNABORTED",
    "ETIMEDOUT",
    "ERR_NETWORK",
    "ERR_FR_TOO_MANY_REDIRECTS",
    "ERR_DEPRECATED",
    "ERR_BAD_RESPONSE",
    "ERR_BAD_REQUEST",
    "ERR_CANCELED",
    "ERR_NOT_SUPPORT",
    "ERR_INVALID_URL"
    // eslint-disable-next-line func-names
  ].forEach((code) => {
    descriptors[code] = { value: code };
  });
  Object.defineProperties(AxiosError, descriptors);
  Object.defineProperty(prototype$1, "isAxiosError", { value: true });
  AxiosError.from = (error, code, config, request, response, customProps) => {
    const axiosError = Object.create(prototype$1);
    utils.toFlatObject(error, axiosError, function filter2(obj) {
      return obj !== Error.prototype;
    }, (prop) => {
      return prop !== "isAxiosError";
    });
    AxiosError.call(axiosError, error.message, code, config, request, response);
    axiosError.cause = error;
    axiosError.name = error.name;
    customProps && Object.assign(axiosError, customProps);
    return axiosError;
  };
  const httpAdapter = null;
  function isVisitable(thing) {
    return utils.isPlainObject(thing) || utils.isArray(thing);
  }
  function removeBrackets(key) {
    return utils.endsWith(key, "[]") ? key.slice(0, -2) : key;
  }
  function renderKey(path2, key, dots) {
    if (!path2)
      return key;
    return path2.concat(key).map(function each(token2, i) {
      token2 = removeBrackets(token2);
      return !dots && i ? "[" + token2 + "]" : token2;
    }).join(dots ? "." : "");
  }
  function isFlatArray(arr) {
    return utils.isArray(arr) && !arr.some(isVisitable);
  }
  const predicates = utils.toFlatObject(utils, {}, null, function filter(prop) {
    return /^is[A-Z]/.test(prop);
  });
  function toFormData(obj, formData, options) {
    if (!utils.isObject(obj)) {
      throw new TypeError("target must be an object");
    }
    formData = formData || new FormData();
    options = utils.toFlatObject(options, {
      metaTokens: true,
      dots: false,
      indexes: false
    }, false, function defined(option, source) {
      return !utils.isUndefined(source[option]);
    });
    const metaTokens = options.metaTokens;
    const visitor = options.visitor || defaultVisitor;
    const dots = options.dots;
    const indexes = options.indexes;
    const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
    const useBlob = _Blob && utils.isSpecCompliantForm(formData);
    if (!utils.isFunction(visitor)) {
      throw new TypeError("visitor must be a function");
    }
    function convertValue(value) {
      if (value === null)
        return "";
      if (utils.isDate(value)) {
        return value.toISOString();
      }
      if (!useBlob && utils.isBlob(value)) {
        throw new AxiosError("Blob is not supported. Use a Buffer instead.");
      }
      if (utils.isArrayBuffer(value) || utils.isTypedArray(value)) {
        return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
      }
      return value;
    }
    function defaultVisitor(value, key, path2) {
      let arr = value;
      if (value && !path2 && typeof value === "object") {
        if (utils.endsWith(key, "{}")) {
          key = metaTokens ? key : key.slice(0, -2);
          value = JSON.stringify(value);
        } else if (utils.isArray(value) && isFlatArray(value) || (utils.isFileList(value) || utils.endsWith(key, "[]")) && (arr = utils.toArray(value))) {
          key = removeBrackets(key);
          arr.forEach(function each(el, index2) {
            !(utils.isUndefined(el) || el === null) && formData.append(
              // eslint-disable-next-line no-nested-ternary
              indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
              convertValue(el)
            );
          });
          return false;
        }
      }
      if (isVisitable(value)) {
        return true;
      }
      formData.append(renderKey(path2, key, dots), convertValue(value));
      return false;
    }
    const stack = [];
    const exposedHelpers = Object.assign(predicates, {
      defaultVisitor,
      convertValue,
      isVisitable
    });
    function build(value, path2) {
      if (utils.isUndefined(value))
        return;
      if (stack.indexOf(value) !== -1) {
        throw Error("Circular reference detected in " + path2.join("."));
      }
      stack.push(value);
      utils.forEach(value, function each(el, key) {
        const result = !(utils.isUndefined(el) || el === null) && visitor.call(
          formData,
          el,
          utils.isString(key) ? key.trim() : key,
          path2,
          exposedHelpers
        );
        if (result === true) {
          build(el, path2 ? path2.concat(key) : [key]);
        }
      });
      stack.pop();
    }
    if (!utils.isObject(obj)) {
      throw new TypeError("data must be an object");
    }
    build(obj);
    return formData;
  }
  function encode$1(str) {
    const charMap = {
      "!": "%21",
      "'": "%27",
      "(": "%28",
      ")": "%29",
      "~": "%7E",
      "%20": "+",
      "%00": "\0"
    };
    return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
      return charMap[match2];
    });
  }
  function AxiosURLSearchParams(params, options) {
    this._pairs = [];
    params && toFormData(params, this, options);
  }
  const prototype = AxiosURLSearchParams.prototype;
  prototype.append = function append2(name, value) {
    this._pairs.push([name, value]);
  };
  prototype.toString = function toString2(encoder) {
    const _encode = encoder ? function(value) {
      return encoder.call(this, value, encode$1);
    } : encode$1;
    return this._pairs.map(function each(pair) {
      return _encode(pair[0]) + "=" + _encode(pair[1]);
    }, "").join("&");
  };
  function encode(val) {
    return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
  }
  function buildURL(url2, params, options) {
    if (!params) {
      return url2;
    }
    const _encode = options && options.encode || encode;
    const serializeFn = options && options.serialize;
    let serializedParams;
    if (serializeFn) {
      serializedParams = serializeFn(params, options);
    } else {
      serializedParams = utils.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
    }
    if (serializedParams) {
      const hashmarkIndex = url2.indexOf("#");
      if (hashmarkIndex !== -1) {
        url2 = url2.slice(0, hashmarkIndex);
      }
      url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
    }
    return url2;
  }
  class InterceptorManager {
    constructor() {
      this.handlers = [];
    }
    /**
     * Add a new interceptor to the stack
     *
     * @param {Function} fulfilled The function to handle `then` for a `Promise`
     * @param {Function} rejected The function to handle `reject` for a `Promise`
     *
     * @return {Number} An ID used to remove interceptor later
     */
    use(fulfilled, rejected, options) {
      this.handlers.push({
        fulfilled,
        rejected,
        synchronous: options ? options.synchronous : false,
        runWhen: options ? options.runWhen : null
      });
      return this.handlers.length - 1;
    }
    /**
     * Remove an interceptor from the stack
     *
     * @param {Number} id The ID that was returned by `use`
     *
     * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
     */
    eject(id2) {
      if (this.handlers[id2]) {
        this.handlers[id2] = null;
      }
    }
    /**
     * Clear all interceptors from the stack
     *
     * @returns {void}
     */
    clear() {
      if (this.handlers) {
        this.handlers = [];
      }
    }
    /**
     * Iterate over all the registered interceptors
     *
     * This method is particularly useful for skipping over any
     * interceptors that may have become `null` calling `eject`.
     *
     * @param {Function} fn The function to call for each interceptor
     *
     * @returns {void}
     */
    forEach(fn) {
      utils.forEach(this.handlers, function forEachHandler(h2) {
        if (h2 !== null) {
          fn(h2);
        }
      });
    }
  }
  const InterceptorManager$1 = InterceptorManager;
  const transitionalDefaults = {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  };
  const URLSearchParams$1 = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams;
  const FormData$1 = typeof FormData !== "undefined" ? FormData : null;
  const Blob$1 = typeof Blob !== "undefined" ? Blob : null;
  const isStandardBrowserEnv = (() => {
    let product;
    if (typeof navigator !== "undefined" && ((product = navigator.product) === "ReactNative" || product === "NativeScript" || product === "NS")) {
      return false;
    }
    return typeof window !== "undefined" && typeof document !== "undefined";
  })();
  const isStandardBrowserWebWorkerEnv = (() => {
    return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
    self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
  })();
  const platform = {
    isBrowser: true,
    classes: {
      URLSearchParams: URLSearchParams$1,
      FormData: FormData$1,
      Blob: Blob$1
    },
    isStandardBrowserEnv,
    isStandardBrowserWebWorkerEnv,
    protocols: ["http", "https", "file", "blob", "url", "data"]
  };
  function toURLEncodedForm(data, options) {
    return toFormData(data, new platform.classes.URLSearchParams(), Object.assign({
      visitor: function(value, key, path2, helpers) {
        if (platform.isNode && utils.isBuffer(value)) {
          this.append(key, value.toString("base64"));
          return false;
        }
        return helpers.defaultVisitor.apply(this, arguments);
      }
    }, options));
  }
  function parsePropPath(name) {
    return utils.matchAll(/\w+|\[(\w*)]/g, name).map((match2) => {
      return match2[0] === "[]" ? "" : match2[1] || match2[0];
    });
  }
  function arrayToObject(arr) {
    const obj = {};
    const keys2 = Object.keys(arr);
    let i;
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      obj[key] = arr[key];
    }
    return obj;
  }
  function formDataToJSON(formData) {
    function buildPath(path2, value, target, index2) {
      let name = path2[index2++];
      const isNumericKey = Number.isFinite(+name);
      const isLast = index2 >= path2.length;
      name = !name && utils.isArray(target) ? target.length : name;
      if (isLast) {
        if (utils.hasOwnProp(target, name)) {
          target[name] = [target[name], value];
        } else {
          target[name] = value;
        }
        return !isNumericKey;
      }
      if (!target[name] || !utils.isObject(target[name])) {
        target[name] = [];
      }
      const result = buildPath(path2, value, target[name], index2);
      if (result && utils.isArray(target[name])) {
        target[name] = arrayToObject(target[name]);
      }
      return !isNumericKey;
    }
    if (utils.isFormData(formData) && utils.isFunction(formData.entries)) {
      const obj = {};
      utils.forEachEntry(formData, (name, value) => {
        buildPath(parsePropPath(name), value, obj, 0);
      });
      return obj;
    }
    return null;
  }
  const DEFAULT_CONTENT_TYPE = {
    "Content-Type": void 0
  };
  function stringifySafely(rawValue, parser, encoder) {
    if (utils.isString(rawValue)) {
      try {
        (parser || JSON.parse)(rawValue);
        return utils.trim(rawValue);
      } catch (e2) {
        if (e2.name !== "SyntaxError") {
          throw e2;
        }
      }
    }
    return (encoder || JSON.stringify)(rawValue);
  }
  const defaults = {
    transitional: transitionalDefaults,
    adapter: ["xhr", "http"],
    transformRequest: [function transformRequest(data, headers) {
      const contentType = headers.getContentType() || "";
      const hasJSONContentType = contentType.indexOf("application/json") > -1;
      const isObjectPayload = utils.isObject(data);
      if (isObjectPayload && utils.isHTMLForm(data)) {
        data = new FormData(data);
      }
      const isFormData2 = utils.isFormData(data);
      if (isFormData2) {
        if (!hasJSONContentType) {
          return data;
        }
        return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
      }
      if (utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
        return data;
      }
      if (utils.isArrayBufferView(data)) {
        return data.buffer;
      }
      if (utils.isURLSearchParams(data)) {
        headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
        return data.toString();
      }
      let isFileList2;
      if (isObjectPayload) {
        if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
          return toURLEncodedForm(data, this.formSerializer).toString();
        }
        if ((isFileList2 = utils.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
          const _FormData = this.env && this.env.FormData;
          return toFormData(
            isFileList2 ? { "files[]": data } : data,
            _FormData && new _FormData(),
            this.formSerializer
          );
        }
      }
      if (isObjectPayload || hasJSONContentType) {
        headers.setContentType("application/json", false);
        return stringifySafely(data);
      }
      return data;
    }],
    transformResponse: [function transformResponse(data) {
      const transitional2 = this.transitional || defaults.transitional;
      const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
      const JSONRequested = this.responseType === "json";
      if (data && utils.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
        const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
        const strictJSONParsing = !silentJSONParsing && JSONRequested;
        try {
          return JSON.parse(data);
        } catch (e2) {
          if (strictJSONParsing) {
            if (e2.name === "SyntaxError") {
              throw AxiosError.from(e2, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
            }
            throw e2;
          }
        }
      }
      return data;
    }],
    /**
     * A timeout in milliseconds to abort a request. If set to 0 (default) a
     * timeout is not created.
     */
    timeout: 0,
    xsrfCookieName: "XSRF-TOKEN",
    xsrfHeaderName: "X-XSRF-TOKEN",
    maxContentLength: -1,
    maxBodyLength: -1,
    env: {
      FormData: platform.classes.FormData,
      Blob: platform.classes.Blob
    },
    validateStatus: function validateStatus(status) {
      return status >= 200 && status < 300;
    },
    headers: {
      common: {
        "Accept": "application/json, text/plain, */*"
      }
    }
  };
  utils.forEach(["delete", "get", "head"], function forEachMethodNoData(method4) {
    defaults.headers[method4] = {};
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData(method4) {
    defaults.headers[method4] = utils.merge(DEFAULT_CONTENT_TYPE);
  });
  const defaults$1 = defaults;
  const ignoreDuplicateOf = utils.toObjectSet([
    "age",
    "authorization",
    "content-length",
    "content-type",
    "etag",
    "expires",
    "from",
    "host",
    "if-modified-since",
    "if-unmodified-since",
    "last-modified",
    "location",
    "max-forwards",
    "proxy-authorization",
    "referer",
    "retry-after",
    "user-agent"
  ]);
  const parseHeaders = (rawHeaders) => {
    const parsed = {};
    let key;
    let val;
    let i;
    rawHeaders && rawHeaders.split("\n").forEach(function parser(line2) {
      i = line2.indexOf(":");
      key = line2.substring(0, i).trim().toLowerCase();
      val = line2.substring(i + 1).trim();
      if (!key || parsed[key] && ignoreDuplicateOf[key]) {
        return;
      }
      if (key === "set-cookie") {
        if (parsed[key]) {
          parsed[key].push(val);
        } else {
          parsed[key] = [val];
        }
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    });
    return parsed;
  };
  const $internals = Symbol("internals");
  function normalizeHeader(header) {
    return header && String(header).trim().toLowerCase();
  }
  function normalizeValue(value) {
    if (value === false || value == null) {
      return value;
    }
    return utils.isArray(value) ? value.map(normalizeValue) : String(value);
  }
  function parseTokens(str) {
    const tokens = /* @__PURE__ */ Object.create(null);
    const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
    let match2;
    while (match2 = tokensRE.exec(str)) {
      tokens[match2[1]] = match2[2];
    }
    return tokens;
  }
  const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
  function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
    if (utils.isFunction(filter2)) {
      return filter2.call(this, value, header);
    }
    if (isHeaderNameFilter) {
      value = header;
    }
    if (!utils.isString(value))
      return;
    if (utils.isString(filter2)) {
      return value.indexOf(filter2) !== -1;
    }
    if (utils.isRegExp(filter2)) {
      return filter2.test(value);
    }
  }
  function formatHeader(header) {
    return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char2, str) => {
      return char2.toUpperCase() + str;
    });
  }
  function buildAccessors(obj, header) {
    const accessorName = utils.toCamelCase(" " + header);
    ["get", "set", "has"].forEach((methodName) => {
      Object.defineProperty(obj, methodName + accessorName, {
        value: function(arg1, arg2, arg3) {
          return this[methodName].call(this, header, arg1, arg2, arg3);
        },
        configurable: true
      });
    });
  }
  class AxiosHeaders {
    constructor(headers) {
      headers && this.set(headers);
    }
    set(header, valueOrRewrite, rewrite) {
      const self2 = this;
      function setHeader(_value, _header, _rewrite) {
        const lHeader = normalizeHeader(_header);
        if (!lHeader) {
          throw new Error("header name must be a non-empty string");
        }
        const key = utils.findKey(self2, lHeader);
        if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
          self2[key || _header] = normalizeValue(_value);
        }
      }
      const setHeaders = (headers, _rewrite) => utils.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
      if (utils.isPlainObject(header) || header instanceof this.constructor) {
        setHeaders(header, valueOrRewrite);
      } else if (utils.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
        setHeaders(parseHeaders(header), valueOrRewrite);
      } else {
        header != null && setHeader(valueOrRewrite, header, rewrite);
      }
      return this;
    }
    get(header, parser) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        if (key) {
          const value = this[key];
          if (!parser) {
            return value;
          }
          if (parser === true) {
            return parseTokens(value);
          }
          if (utils.isFunction(parser)) {
            return parser.call(this, value, key);
          }
          if (utils.isRegExp(parser)) {
            return parser.exec(value);
          }
          throw new TypeError("parser must be boolean|regexp|function");
        }
      }
    }
    has(header, matcher) {
      header = normalizeHeader(header);
      if (header) {
        const key = utils.findKey(this, header);
        return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
      }
      return false;
    }
    delete(header, matcher) {
      const self2 = this;
      let deleted = false;
      function deleteHeader(_header) {
        _header = normalizeHeader(_header);
        if (_header) {
          const key = utils.findKey(self2, _header);
          if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
            delete self2[key];
            deleted = true;
          }
        }
      }
      if (utils.isArray(header)) {
        header.forEach(deleteHeader);
      } else {
        deleteHeader(header);
      }
      return deleted;
    }
    clear(matcher) {
      const keys2 = Object.keys(this);
      let i = keys2.length;
      let deleted = false;
      while (i--) {
        const key = keys2[i];
        if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
          delete this[key];
          deleted = true;
        }
      }
      return deleted;
    }
    normalize(format2) {
      const self2 = this;
      const headers = {};
      utils.forEach(this, (value, header) => {
        const key = utils.findKey(headers, header);
        if (key) {
          self2[key] = normalizeValue(value);
          delete self2[header];
          return;
        }
        const normalized = format2 ? formatHeader(header) : String(header).trim();
        if (normalized !== header) {
          delete self2[header];
        }
        self2[normalized] = normalizeValue(value);
        headers[normalized] = true;
      });
      return this;
    }
    concat(...targets) {
      return this.constructor.concat(this, ...targets);
    }
    toJSON(asStrings) {
      const obj = /* @__PURE__ */ Object.create(null);
      utils.forEach(this, (value, header) => {
        value != null && value !== false && (obj[header] = asStrings && utils.isArray(value) ? value.join(", ") : value);
      });
      return obj;
    }
    [Symbol.iterator]() {
      return Object.entries(this.toJSON())[Symbol.iterator]();
    }
    toString() {
      return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
    }
    get [Symbol.toStringTag]() {
      return "AxiosHeaders";
    }
    static from(thing) {
      return thing instanceof this ? thing : new this(thing);
    }
    static concat(first, ...targets) {
      const computed3 = new this(first);
      targets.forEach((target) => computed3.set(target));
      return computed3;
    }
    static accessor(header) {
      const internals = this[$internals] = this[$internals] = {
        accessors: {}
      };
      const accessors = internals.accessors;
      const prototype2 = this.prototype;
      function defineAccessor(_header) {
        const lHeader = normalizeHeader(_header);
        if (!accessors[lHeader]) {
          buildAccessors(prototype2, _header);
          accessors[lHeader] = true;
        }
      }
      utils.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
      return this;
    }
  }
  AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
  utils.freezeMethods(AxiosHeaders.prototype);
  utils.freezeMethods(AxiosHeaders);
  const AxiosHeaders$1 = AxiosHeaders;
  function transformData(fns, response) {
    const config = this || defaults$1;
    const context = response || config;
    const headers = AxiosHeaders$1.from(context.headers);
    let data = context.data;
    utils.forEach(fns, function transform(fn) {
      data = fn.call(config, data, headers.normalize(), response ? response.status : void 0);
    });
    headers.normalize();
    return data;
  }
  function isCancel(value) {
    return !!(value && value.__CANCEL__);
  }
  function CanceledError(message, config, request) {
    AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request);
    this.name = "CanceledError";
  }
  utils.inherits(CanceledError, AxiosError, {
    __CANCEL__: true
  });
  function settle(resolve, reject, response) {
    const validateStatus2 = response.config.validateStatus;
    if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
      resolve(response);
    } else {
      reject(new AxiosError(
        "Request failed with status code " + response.status,
        [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
        response.config,
        response.request,
        response
      ));
    }
  }
  const cookies = platform.isStandardBrowserEnv ? (
    // Standard browser envs support document.cookie
    function standardBrowserEnv() {
      return {
        write: function write(name, value, expires, path2, domain, secure) {
          const cookie = [];
          cookie.push(name + "=" + encodeURIComponent(value));
          if (utils.isNumber(expires)) {
            cookie.push("expires=" + new Date(expires).toGMTString());
          }
          if (utils.isString(path2)) {
            cookie.push("path=" + path2);
          }
          if (utils.isString(domain)) {
            cookie.push("domain=" + domain);
          }
          if (secure === true) {
            cookie.push("secure");
          }
          document.cookie = cookie.join("; ");
        },
        read: function read(name) {
          const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
          return match2 ? decodeURIComponent(match2[3]) : null;
        },
        remove: function remove2(name) {
          this.write(name, "", Date.now() - 864e5);
        }
      };
    }()
  ) : (
    // Non standard browser env (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv() {
      return {
        write: function write() {
        },
        read: function read() {
          return null;
        },
        remove: function remove2() {
        }
      };
    }()
  );
  function isAbsoluteURL(url2) {
    return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
  }
  function combineURLs(baseURL, relativeURL) {
    return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
  }
  function buildFullPath(baseURL, requestedURL) {
    if (baseURL && !isAbsoluteURL(requestedURL)) {
      return combineURLs(baseURL, requestedURL);
    }
    return requestedURL;
  }
  const isURLSameOrigin = platform.isStandardBrowserEnv ? (
    // Standard browser envs have full support of the APIs needed to test
    // whether the request URL is of the same origin as current location.
    function standardBrowserEnv2() {
      const msie = /(msie|trident)/i.test(navigator.userAgent);
      const urlParsingNode = document.createElement("a");
      let originURL;
      function resolveURL(url2) {
        let href = url2;
        if (msie) {
          urlParsingNode.setAttribute("href", href);
          href = urlParsingNode.href;
        }
        urlParsingNode.setAttribute("href", href);
        return {
          href: urlParsingNode.href,
          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
          host: urlParsingNode.host,
          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
          hostname: urlParsingNode.hostname,
          port: urlParsingNode.port,
          pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
        };
      }
      originURL = resolveURL(window.location.href);
      return function isURLSameOrigin2(requestURL) {
        const parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
        return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
      };
    }()
  ) : (
    // Non standard browser envs (web workers, react-native) lack needed support.
    function nonStandardBrowserEnv2() {
      return function isURLSameOrigin2() {
        return true;
      };
    }()
  );
  function parseProtocol(url2) {
    const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
    return match2 && match2[1] || "";
  }
  function speedometer(samplesCount, min) {
    samplesCount = samplesCount || 10;
    const bytes = new Array(samplesCount);
    const timestamps = new Array(samplesCount);
    let head = 0;
    let tail = 0;
    let firstSampleTS;
    min = min !== void 0 ? min : 1e3;
    return function push2(chunkLength) {
      const now = Date.now();
      const startedAt = timestamps[tail];
      if (!firstSampleTS) {
        firstSampleTS = now;
      }
      bytes[head] = chunkLength;
      timestamps[head] = now;
      let i = tail;
      let bytesCount = 0;
      while (i !== head) {
        bytesCount += bytes[i++];
        i = i % samplesCount;
      }
      head = (head + 1) % samplesCount;
      if (head === tail) {
        tail = (tail + 1) % samplesCount;
      }
      if (now - firstSampleTS < min) {
        return;
      }
      const passed = startedAt && now - startedAt;
      return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
    };
  }
  function progressEventReducer(listener, isDownloadStream) {
    let bytesNotified = 0;
    const _speedometer = speedometer(50, 250);
    return (e2) => {
      const loaded = e2.loaded;
      const total = e2.lengthComputable ? e2.total : void 0;
      const progressBytes = loaded - bytesNotified;
      const rate = _speedometer(progressBytes);
      const inRange = loaded <= total;
      bytesNotified = loaded;
      const data = {
        loaded,
        total,
        progress: total ? loaded / total : void 0,
        bytes: progressBytes,
        rate: rate ? rate : void 0,
        estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
        event: e2
      };
      data[isDownloadStream ? "download" : "upload"] = true;
      listener(data);
    };
  }
  const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
  const xhrAdapter = isXHRAdapterSupported && function(config) {
    return new Promise(function dispatchXhrRequest(resolve, reject) {
      let requestData = config.data;
      const requestHeaders = AxiosHeaders$1.from(config.headers).normalize();
      const responseType = config.responseType;
      let onCanceled;
      function done() {
        if (config.cancelToken) {
          config.cancelToken.unsubscribe(onCanceled);
        }
        if (config.signal) {
          config.signal.removeEventListener("abort", onCanceled);
        }
      }
      if (utils.isFormData(requestData)) {
        if (platform.isStandardBrowserEnv || platform.isStandardBrowserWebWorkerEnv) {
          requestHeaders.setContentType(false);
        } else {
          requestHeaders.setContentType("multipart/form-data;", false);
        }
      }
      let request = new XMLHttpRequest();
      if (config.auth) {
        const username = config.auth.username || "";
        const password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : "";
        requestHeaders.set("Authorization", "Basic " + btoa(username + ":" + password));
      }
      const fullPath = buildFullPath(config.baseURL, config.url);
      request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);
      request.timeout = config.timeout;
      function onloadend() {
        if (!request) {
          return;
        }
        const responseHeaders = AxiosHeaders$1.from(
          "getAllResponseHeaders" in request && request.getAllResponseHeaders()
        );
        const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
        const response = {
          data: responseData,
          status: request.status,
          statusText: request.statusText,
          headers: responseHeaders,
          config,
          request
        };
        settle(function _resolve(value) {
          resolve(value);
          done();
        }, function _reject(err) {
          reject(err);
          done();
        }, response);
        request = null;
      }
      if ("onloadend" in request) {
        request.onloadend = onloadend;
      } else {
        request.onreadystatechange = function handleLoad() {
          if (!request || request.readyState !== 4) {
            return;
          }
          if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
            return;
          }
          setTimeout(onloadend);
        };
      }
      request.onabort = function handleAbort() {
        if (!request) {
          return;
        }
        reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request));
        request = null;
      };
      request.onerror = function handleError() {
        reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request));
        request = null;
      };
      request.ontimeout = function handleTimeout() {
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          request
        ));
        request = null;
      };
      if (platform.isStandardBrowserEnv) {
        const xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName && cookies.read(config.xsrfCookieName);
        if (xsrfValue) {
          requestHeaders.set(config.xsrfHeaderName, xsrfValue);
        }
      }
      requestData === void 0 && requestHeaders.setContentType(null);
      if ("setRequestHeader" in request) {
        utils.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
          request.setRequestHeader(key, val);
        });
      }
      if (!utils.isUndefined(config.withCredentials)) {
        request.withCredentials = !!config.withCredentials;
      }
      if (responseType && responseType !== "json") {
        request.responseType = config.responseType;
      }
      if (typeof config.onDownloadProgress === "function") {
        request.addEventListener("progress", progressEventReducer(config.onDownloadProgress, true));
      }
      if (typeof config.onUploadProgress === "function" && request.upload) {
        request.upload.addEventListener("progress", progressEventReducer(config.onUploadProgress));
      }
      if (config.cancelToken || config.signal) {
        onCanceled = (cancel) => {
          if (!request) {
            return;
          }
          reject(!cancel || cancel.type ? new CanceledError(null, config, request) : cancel);
          request.abort();
          request = null;
        };
        config.cancelToken && config.cancelToken.subscribe(onCanceled);
        if (config.signal) {
          config.signal.aborted ? onCanceled() : config.signal.addEventListener("abort", onCanceled);
        }
      }
      const protocol = parseProtocol(fullPath);
      if (protocol && platform.protocols.indexOf(protocol) === -1) {
        reject(new AxiosError("Unsupported protocol " + protocol + ":", AxiosError.ERR_BAD_REQUEST, config));
        return;
      }
      request.send(requestData || null);
    });
  };
  const knownAdapters = {
    http: httpAdapter,
    xhr: xhrAdapter
  };
  utils.forEach(knownAdapters, (fn, value) => {
    if (fn) {
      try {
        Object.defineProperty(fn, "name", { value });
      } catch (e2) {
      }
      Object.defineProperty(fn, "adapterName", { value });
    }
  });
  const adapters = {
    getAdapter: (adapters2) => {
      adapters2 = utils.isArray(adapters2) ? adapters2 : [adapters2];
      const { length: length2 } = adapters2;
      let nameOrAdapter;
      let adapter;
      for (let i = 0; i < length2; i++) {
        nameOrAdapter = adapters2[i];
        if (adapter = utils.isString(nameOrAdapter) ? knownAdapters[nameOrAdapter.toLowerCase()] : nameOrAdapter) {
          break;
        }
      }
      if (!adapter) {
        if (adapter === false) {
          throw new AxiosError(
            `Adapter ${nameOrAdapter} is not supported by the environment`,
            "ERR_NOT_SUPPORT"
          );
        }
        throw new Error(
          utils.hasOwnProp(knownAdapters, nameOrAdapter) ? `Adapter '${nameOrAdapter}' is not available in the build` : `Unknown adapter '${nameOrAdapter}'`
        );
      }
      if (!utils.isFunction(adapter)) {
        throw new TypeError("adapter is not a function");
      }
      return adapter;
    },
    adapters: knownAdapters
  };
  function throwIfCancellationRequested(config) {
    if (config.cancelToken) {
      config.cancelToken.throwIfRequested();
    }
    if (config.signal && config.signal.aborted) {
      throw new CanceledError(null, config);
    }
  }
  function dispatchRequest(config) {
    throwIfCancellationRequested(config);
    config.headers = AxiosHeaders$1.from(config.headers);
    config.data = transformData.call(
      config,
      config.transformRequest
    );
    if (["post", "put", "patch"].indexOf(config.method) !== -1) {
      config.headers.setContentType("application/x-www-form-urlencoded", false);
    }
    const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
    return adapter(config).then(function onAdapterResolution(response) {
      throwIfCancellationRequested(config);
      response.data = transformData.call(
        config,
        config.transformResponse,
        response
      );
      response.headers = AxiosHeaders$1.from(response.headers);
      return response;
    }, function onAdapterRejection(reason) {
      if (!isCancel(reason)) {
        throwIfCancellationRequested(config);
        if (reason && reason.response) {
          reason.response.data = transformData.call(
            config,
            config.transformResponse,
            reason.response
          );
          reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
        }
      }
      return Promise.reject(reason);
    });
  }
  const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? thing.toJSON() : thing;
  function mergeConfig(config1, config2) {
    config2 = config2 || {};
    const config = {};
    function getMergedValue(target, source, caseless) {
      if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
        return utils.merge.call({ caseless }, target, source);
      } else if (utils.isPlainObject(source)) {
        return utils.merge({}, source);
      } else if (utils.isArray(source)) {
        return source.slice();
      }
      return source;
    }
    function mergeDeepProperties(a, b2, caseless) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(a, b2, caseless);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a, caseless);
      }
    }
    function valueFromConfig2(a, b2) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      }
    }
    function defaultToConfig2(a, b2) {
      if (!utils.isUndefined(b2)) {
        return getMergedValue(void 0, b2);
      } else if (!utils.isUndefined(a)) {
        return getMergedValue(void 0, a);
      }
    }
    function mergeDirectKeys(a, b2, prop) {
      if (prop in config2) {
        return getMergedValue(a, b2);
      } else if (prop in config1) {
        return getMergedValue(void 0, a);
      }
    }
    const mergeMap = {
      url: valueFromConfig2,
      method: valueFromConfig2,
      data: valueFromConfig2,
      baseURL: defaultToConfig2,
      transformRequest: defaultToConfig2,
      transformResponse: defaultToConfig2,
      paramsSerializer: defaultToConfig2,
      timeout: defaultToConfig2,
      timeoutMessage: defaultToConfig2,
      withCredentials: defaultToConfig2,
      adapter: defaultToConfig2,
      responseType: defaultToConfig2,
      xsrfCookieName: defaultToConfig2,
      xsrfHeaderName: defaultToConfig2,
      onUploadProgress: defaultToConfig2,
      onDownloadProgress: defaultToConfig2,
      decompress: defaultToConfig2,
      maxContentLength: defaultToConfig2,
      maxBodyLength: defaultToConfig2,
      beforeRedirect: defaultToConfig2,
      transport: defaultToConfig2,
      httpAgent: defaultToConfig2,
      httpsAgent: defaultToConfig2,
      cancelToken: defaultToConfig2,
      socketPath: defaultToConfig2,
      responseEncoding: defaultToConfig2,
      validateStatus: mergeDirectKeys,
      headers: (a, b2) => mergeDeepProperties(headersToObject(a), headersToObject(b2), true)
    };
    utils.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
      const merge2 = mergeMap[prop] || mergeDeepProperties;
      const configValue = merge2(config1[prop], config2[prop], prop);
      utils.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
    });
    return config;
  }
  const VERSION = "1.4.0";
  const validators$1 = {};
  ["object", "boolean", "number", "function", "string", "symbol"].forEach((type4, i) => {
    validators$1[type4] = function validator2(thing) {
      return typeof thing === type4 || "a" + (i < 1 ? "n " : " ") + type4;
    };
  });
  const deprecatedWarnings = {};
  validators$1.transitional = function transitional(validator2, version2, message) {
    function formatMessage(opt, desc) {
      return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
    }
    return (value, opt, opts) => {
      if (validator2 === false) {
        throw new AxiosError(
          formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
          AxiosError.ERR_DEPRECATED
        );
      }
      if (version2 && !deprecatedWarnings[opt]) {
        deprecatedWarnings[opt] = true;
        console.warn(
          formatMessage(
            opt,
            " has been deprecated since v" + version2 + " and will be removed in the near future"
          )
        );
      }
      return validator2 ? validator2(value, opt, opts) : true;
    };
  };
  function assertOptions(options, schema, allowUnknown) {
    if (typeof options !== "object") {
      throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
    }
    const keys2 = Object.keys(options);
    let i = keys2.length;
    while (i-- > 0) {
      const opt = keys2[i];
      const validator2 = schema[opt];
      if (validator2) {
        const value = options[opt];
        const result = value === void 0 || validator2(value, opt, options);
        if (result !== true) {
          throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
        }
        continue;
      }
      if (allowUnknown !== true) {
        throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
      }
    }
  }
  const validator = {
    assertOptions,
    validators: validators$1
  };
  const validators = validator.validators;
  class Axios {
    constructor(instanceConfig) {
      this.defaults = instanceConfig;
      this.interceptors = {
        request: new InterceptorManager$1(),
        response: new InterceptorManager$1()
      };
    }
    /**
     * Dispatch a request
     *
     * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
     * @param {?Object} config
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    request(configOrUrl, config) {
      if (typeof configOrUrl === "string") {
        config = config || {};
        config.url = configOrUrl;
      } else {
        config = configOrUrl || {};
      }
      config = mergeConfig(this.defaults, config);
      const { transitional: transitional2, paramsSerializer, headers } = config;
      if (transitional2 !== void 0) {
        validator.assertOptions(transitional2, {
          silentJSONParsing: validators.transitional(validators.boolean),
          forcedJSONParsing: validators.transitional(validators.boolean),
          clarifyTimeoutError: validators.transitional(validators.boolean)
        }, false);
      }
      if (paramsSerializer != null) {
        if (utils.isFunction(paramsSerializer)) {
          config.paramsSerializer = {
            serialize: paramsSerializer
          };
        } else {
          validator.assertOptions(paramsSerializer, {
            encode: validators.function,
            serialize: validators.function
          }, true);
        }
      }
      config.method = (config.method || this.defaults.method || "get").toLowerCase();
      let contextHeaders;
      contextHeaders = headers && utils.merge(
        headers.common,
        headers[config.method]
      );
      contextHeaders && utils.forEach(
        ["delete", "get", "head", "post", "put", "patch", "common"],
        (method4) => {
          delete headers[method4];
        }
      );
      config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
      const requestInterceptorChain = [];
      let synchronousRequestInterceptors = true;
      this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
        if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
          return;
        }
        synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
        requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
      });
      const responseInterceptorChain = [];
      this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
        responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
      });
      let promise;
      let i = 0;
      let len;
      if (!synchronousRequestInterceptors) {
        const chain = [dispatchRequest.bind(this), void 0];
        chain.unshift.apply(chain, requestInterceptorChain);
        chain.push.apply(chain, responseInterceptorChain);
        len = chain.length;
        promise = Promise.resolve(config);
        while (i < len) {
          promise = promise.then(chain[i++], chain[i++]);
        }
        return promise;
      }
      len = requestInterceptorChain.length;
      let newConfig = config;
      i = 0;
      while (i < len) {
        const onFulfilled = requestInterceptorChain[i++];
        const onRejected = requestInterceptorChain[i++];
        try {
          newConfig = onFulfilled(newConfig);
        } catch (error) {
          onRejected.call(this, error);
          break;
        }
      }
      try {
        promise = dispatchRequest.call(this, newConfig);
      } catch (error) {
        return Promise.reject(error);
      }
      i = 0;
      len = responseInterceptorChain.length;
      while (i < len) {
        promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
      }
      return promise;
    }
    getUri(config) {
      config = mergeConfig(this.defaults, config);
      const fullPath = buildFullPath(config.baseURL, config.url);
      return buildURL(fullPath, config.params, config.paramsSerializer);
    }
  }
  utils.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method4) {
    Axios.prototype[method4] = function(url2, config) {
      return this.request(mergeConfig(config || {}, {
        method: method4,
        url: url2,
        data: (config || {}).data
      }));
    };
  });
  utils.forEach(["post", "put", "patch"], function forEachMethodWithData2(method4) {
    function generateHTTPMethod(isForm) {
      return function httpMethod(url2, data, config) {
        return this.request(mergeConfig(config || {}, {
          method: method4,
          headers: isForm ? {
            "Content-Type": "multipart/form-data"
          } : {},
          url: url2,
          data
        }));
      };
    }
    Axios.prototype[method4] = generateHTTPMethod();
    Axios.prototype[method4 + "Form"] = generateHTTPMethod(true);
  });
  const Axios$1 = Axios;
  class CancelToken {
    constructor(executor) {
      if (typeof executor !== "function") {
        throw new TypeError("executor must be a function.");
      }
      let resolvePromise;
      this.promise = new Promise(function promiseExecutor(resolve) {
        resolvePromise = resolve;
      });
      const token2 = this;
      this.promise.then((cancel) => {
        if (!token2._listeners)
          return;
        let i = token2._listeners.length;
        while (i-- > 0) {
          token2._listeners[i](cancel);
        }
        token2._listeners = null;
      });
      this.promise.then = (onfulfilled) => {
        let _resolve;
        const promise = new Promise((resolve) => {
          token2.subscribe(resolve);
          _resolve = resolve;
        }).then(onfulfilled);
        promise.cancel = function reject() {
          token2.unsubscribe(_resolve);
        };
        return promise;
      };
      executor(function cancel(message, config, request) {
        if (token2.reason) {
          return;
        }
        token2.reason = new CanceledError(message, config, request);
        resolvePromise(token2.reason);
      });
    }
    /**
     * Throws a `CanceledError` if cancellation has been requested.
     */
    throwIfRequested() {
      if (this.reason) {
        throw this.reason;
      }
    }
    /**
     * Subscribe to the cancel signal
     */
    subscribe(listener) {
      if (this.reason) {
        listener(this.reason);
        return;
      }
      if (this._listeners) {
        this._listeners.push(listener);
      } else {
        this._listeners = [listener];
      }
    }
    /**
     * Unsubscribe from the cancel signal
     */
    unsubscribe(listener) {
      if (!this._listeners) {
        return;
      }
      const index2 = this._listeners.indexOf(listener);
      if (index2 !== -1) {
        this._listeners.splice(index2, 1);
      }
    }
    /**
     * Returns an object that contains a new `CancelToken` and a function that, when called,
     * cancels the `CancelToken`.
     */
    static source() {
      let cancel;
      const token2 = new CancelToken(function executor(c2) {
        cancel = c2;
      });
      return {
        token: token2,
        cancel
      };
    }
  }
  const CancelToken$1 = CancelToken;
  function spread(callback) {
    return function wrap(arr) {
      return callback.apply(null, arr);
    };
  }
  function isAxiosError(payload) {
    return utils.isObject(payload) && payload.isAxiosError === true;
  }
  const HttpStatusCode = {
    Continue: 100,
    SwitchingProtocols: 101,
    Processing: 102,
    EarlyHints: 103,
    Ok: 200,
    Created: 201,
    Accepted: 202,
    NonAuthoritativeInformation: 203,
    NoContent: 204,
    ResetContent: 205,
    PartialContent: 206,
    MultiStatus: 207,
    AlreadyReported: 208,
    ImUsed: 226,
    MultipleChoices: 300,
    MovedPermanently: 301,
    Found: 302,
    SeeOther: 303,
    NotModified: 304,
    UseProxy: 305,
    Unused: 306,
    TemporaryRedirect: 307,
    PermanentRedirect: 308,
    BadRequest: 400,
    Unauthorized: 401,
    PaymentRequired: 402,
    Forbidden: 403,
    NotFound: 404,
    MethodNotAllowed: 405,
    NotAcceptable: 406,
    ProxyAuthenticationRequired: 407,
    RequestTimeout: 408,
    Conflict: 409,
    Gone: 410,
    LengthRequired: 411,
    PreconditionFailed: 412,
    PayloadTooLarge: 413,
    UriTooLong: 414,
    UnsupportedMediaType: 415,
    RangeNotSatisfiable: 416,
    ExpectationFailed: 417,
    ImATeapot: 418,
    MisdirectedRequest: 421,
    UnprocessableEntity: 422,
    Locked: 423,
    FailedDependency: 424,
    TooEarly: 425,
    UpgradeRequired: 426,
    PreconditionRequired: 428,
    TooManyRequests: 429,
    RequestHeaderFieldsTooLarge: 431,
    UnavailableForLegalReasons: 451,
    InternalServerError: 500,
    NotImplemented: 501,
    BadGateway: 502,
    ServiceUnavailable: 503,
    GatewayTimeout: 504,
    HttpVersionNotSupported: 505,
    VariantAlsoNegotiates: 506,
    InsufficientStorage: 507,
    LoopDetected: 508,
    NotExtended: 510,
    NetworkAuthenticationRequired: 511
  };
  Object.entries(HttpStatusCode).forEach(([key, value]) => {
    HttpStatusCode[value] = key;
  });
  const HttpStatusCode$1 = HttpStatusCode;
  function createInstance(defaultConfig2) {
    const context = new Axios$1(defaultConfig2);
    const instance = bind$1(Axios$1.prototype.request, context);
    utils.extend(instance, Axios$1.prototype, context, { allOwnKeys: true });
    utils.extend(instance, context, null, { allOwnKeys: true });
    instance.create = function create(instanceConfig) {
      return createInstance(mergeConfig(defaultConfig2, instanceConfig));
    };
    return instance;
  }
  const axios = createInstance(defaults$1);
  axios.Axios = Axios$1;
  axios.CanceledError = CanceledError;
  axios.CancelToken = CancelToken$1;
  axios.isCancel = isCancel;
  axios.VERSION = VERSION;
  axios.toFormData = toFormData;
  axios.AxiosError = AxiosError;
  axios.Cancel = axios.CanceledError;
  axios.all = function all(promises) {
    return Promise.all(promises);
  };
  axios.spread = spread;
  axios.isAxiosError = isAxiosError;
  axios.mergeConfig = mergeConfig;
  axios.AxiosHeaders = AxiosHeaders$1;
  axios.formToJSON = (thing) => formDataToJSON(utils.isHTMLForm(thing) ? new FormData(thing) : thing);
  axios.HttpStatusCode = HttpStatusCode$1;
  axios.default = axios;
  const axios$1 = axios;
  var lodash = { exports: {} };
  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */
  lodash.exports;
  (function(module, exports) {
    (function() {
      var undefined$1;
      var VERSION2 = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "['’]", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "À": "A",
        "Á": "A",
        "Â": "A",
        "Ã": "A",
        "Ä": "A",
        "Å": "A",
        "à": "a",
        "á": "a",
        "â": "a",
        "ã": "a",
        "ä": "a",
        "å": "a",
        "Ç": "C",
        "ç": "c",
        "Ð": "D",
        "ð": "d",
        "È": "E",
        "É": "E",
        "Ê": "E",
        "Ë": "E",
        "è": "e",
        "é": "e",
        "ê": "e",
        "ë": "e",
        "Ì": "I",
        "Í": "I",
        "Î": "I",
        "Ï": "I",
        "ì": "i",
        "í": "i",
        "î": "i",
        "ï": "i",
        "Ñ": "N",
        "ñ": "n",
        "Ò": "O",
        "Ó": "O",
        "Ô": "O",
        "Õ": "O",
        "Ö": "O",
        "Ø": "O",
        "ò": "o",
        "ó": "o",
        "ô": "o",
        "õ": "o",
        "ö": "o",
        "ø": "o",
        "Ù": "U",
        "Ú": "U",
        "Û": "U",
        "Ü": "U",
        "ù": "u",
        "ú": "u",
        "û": "u",
        "ü": "u",
        "Ý": "Y",
        "ý": "y",
        "ÿ": "y",
        "Æ": "Ae",
        "æ": "ae",
        "Þ": "Th",
        "þ": "th",
        "ß": "ss",
        // Latin Extended-A block.
        "Ā": "A",
        "Ă": "A",
        "Ą": "A",
        "ā": "a",
        "ă": "a",
        "ą": "a",
        "Ć": "C",
        "Ĉ": "C",
        "Ċ": "C",
        "Č": "C",
        "ć": "c",
        "ĉ": "c",
        "ċ": "c",
        "č": "c",
        "Ď": "D",
        "Đ": "D",
        "ď": "d",
        "đ": "d",
        "Ē": "E",
        "Ĕ": "E",
        "Ė": "E",
        "Ę": "E",
        "Ě": "E",
        "ē": "e",
        "ĕ": "e",
        "ė": "e",
        "ę": "e",
        "ě": "e",
        "Ĝ": "G",
        "Ğ": "G",
        "Ġ": "G",
        "Ģ": "G",
        "ĝ": "g",
        "ğ": "g",
        "ġ": "g",
        "ģ": "g",
        "Ĥ": "H",
        "Ħ": "H",
        "ĥ": "h",
        "ħ": "h",
        "Ĩ": "I",
        "Ī": "I",
        "Ĭ": "I",
        "Į": "I",
        "İ": "I",
        "ĩ": "i",
        "ī": "i",
        "ĭ": "i",
        "į": "i",
        "ı": "i",
        "Ĵ": "J",
        "ĵ": "j",
        "Ķ": "K",
        "ķ": "k",
        "ĸ": "k",
        "Ĺ": "L",
        "Ļ": "L",
        "Ľ": "L",
        "Ŀ": "L",
        "Ł": "L",
        "ĺ": "l",
        "ļ": "l",
        "ľ": "l",
        "ŀ": "l",
        "ł": "l",
        "Ń": "N",
        "Ņ": "N",
        "Ň": "N",
        "Ŋ": "N",
        "ń": "n",
        "ņ": "n",
        "ň": "n",
        "ŋ": "n",
        "Ō": "O",
        "Ŏ": "O",
        "Ő": "O",
        "ō": "o",
        "ŏ": "o",
        "ő": "o",
        "Ŕ": "R",
        "Ŗ": "R",
        "Ř": "R",
        "ŕ": "r",
        "ŗ": "r",
        "ř": "r",
        "Ś": "S",
        "Ŝ": "S",
        "Ş": "S",
        "Š": "S",
        "ś": "s",
        "ŝ": "s",
        "ş": "s",
        "š": "s",
        "Ţ": "T",
        "Ť": "T",
        "Ŧ": "T",
        "ţ": "t",
        "ť": "t",
        "ŧ": "t",
        "Ũ": "U",
        "Ū": "U",
        "Ŭ": "U",
        "Ů": "U",
        "Ű": "U",
        "Ų": "U",
        "ũ": "u",
        "ū": "u",
        "ŭ": "u",
        "ů": "u",
        "ű": "u",
        "ų": "u",
        "Ŵ": "W",
        "ŵ": "w",
        "Ŷ": "Y",
        "ŷ": "y",
        "Ÿ": "Y",
        "Ź": "Z",
        "Ż": "Z",
        "Ž": "Z",
        "ź": "z",
        "ż": "z",
        "ž": "z",
        "Ĳ": "IJ",
        "ĳ": "ij",
        "Œ": "Oe",
        "œ": "oe",
        "ŉ": "'n",
        "ſ": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = exports && !exports.nodeType && exports;
      var freeModule = freeExports && true && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types2 = freeModule && freeModule.require && freeModule.require("util").types;
          if (types2) {
            return types2;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e2) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array5, setter, iteratee, accumulator) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        while (++index2 < length2) {
          var value = array5[index2];
          setter(accumulator, value, iteratee(value), array5);
        }
        return accumulator;
      }
      function arrayEach(array5, iteratee) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        while (++index2 < length2) {
          if (iteratee(array5[index2], index2, array5) === false) {
            break;
          }
        }
        return array5;
      }
      function arrayEachRight(array5, iteratee) {
        var length2 = array5 == null ? 0 : array5.length;
        while (length2--) {
          if (iteratee(array5[length2], length2, array5) === false) {
            break;
          }
        }
        return array5;
      }
      function arrayEvery(array5, predicate) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        while (++index2 < length2) {
          if (!predicate(array5[index2], index2, array5)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array5, predicate) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array5[index2];
          if (predicate(value, index2, array5)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array5, value) {
        var length2 = array5 == null ? 0 : array5.length;
        return !!length2 && baseIndexOf(array5, value, 0) > -1;
      }
      function arrayIncludesWith(array5, value, comparator) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        while (++index2 < length2) {
          if (comparator(value, array5[index2])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array5, iteratee) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length, result = Array(length2);
        while (++index2 < length2) {
          result[index2] = iteratee(array5[index2], index2, array5);
        }
        return result;
      }
      function arrayPush(array5, values) {
        var index2 = -1, length2 = values.length, offset2 = array5.length;
        while (++index2 < length2) {
          array5[offset2 + index2] = values[index2];
        }
        return array5;
      }
      function arrayReduce(array5, iteratee, accumulator, initAccum) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        if (initAccum && length2) {
          accumulator = array5[++index2];
        }
        while (++index2 < length2) {
          accumulator = iteratee(accumulator, array5[index2], index2, array5);
        }
        return accumulator;
      }
      function arrayReduceRight(array5, iteratee, accumulator, initAccum) {
        var length2 = array5 == null ? 0 : array5.length;
        if (initAccum && length2) {
          accumulator = array5[--length2];
        }
        while (length2--) {
          accumulator = iteratee(accumulator, array5[length2], length2, array5);
        }
        return accumulator;
      }
      function arraySome(array5, predicate) {
        var index2 = -1, length2 = array5 == null ? 0 : array5.length;
        while (++index2 < length2) {
          if (predicate(array5[index2], index2, array5)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string3) {
        return string3.split("");
      }
      function asciiWords(string3) {
        return string3.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array5, predicate, fromIndex, fromRight) {
        var length2 = array5.length, index2 = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index2-- : ++index2 < length2) {
          if (predicate(array5[index2], index2, array5)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIndexOf(array5, value, fromIndex) {
        return value === value ? strictIndexOf(array5, value, fromIndex) : baseFindIndex(array5, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array5, value, fromIndex, comparator) {
        var index2 = fromIndex - 1, length2 = array5.length;
        while (++index2 < length2) {
          if (comparator(array5[index2], value)) {
            return index2;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array5, iteratee) {
        var length2 = array5 == null ? 0 : array5.length;
        return length2 ? baseSum(array5, iteratee) / length2 : NAN;
      }
      function baseProperty(key) {
        return function(object5) {
          return object5 == null ? undefined$1 : object5[key];
        };
      }
      function basePropertyOf(object5) {
        return function(key) {
          return object5 == null ? undefined$1 : object5[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index2, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index2, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array5, comparer2) {
        var length2 = array5.length;
        array5.sort(comparer2);
        while (length2--) {
          array5[length2] = array5[length2].value;
        }
        return array5;
      }
      function baseSum(array5, iteratee) {
        var result, index2 = -1, length2 = array5.length;
        while (++index2 < length2) {
          var current = iteratee(array5[index2]);
          if (current !== undefined$1) {
            result = result === undefined$1 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n2, iteratee) {
        var index2 = -1, result = Array(n2);
        while (++index2 < n2) {
          result[index2] = iteratee(index2);
        }
        return result;
      }
      function baseToPairs(object5, props) {
        return arrayMap(props, function(key) {
          return [key, object5[key]];
        });
      }
      function baseTrim(string3) {
        return string3 ? string3.slice(0, trimmedEndIndex(string3) + 1).replace(reTrimStart, "") : string3;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object5, props) {
        return arrayMap(props, function(key) {
          return object5[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index2 = -1, length2 = strSymbols.length;
        while (++index2 < length2 && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index2 = strSymbols.length;
        while (index2-- && baseIndexOf(chrSymbols, strSymbols[index2], 0) > -1) {
        }
        return index2;
      }
      function countHolders(array5, placeholder) {
        var length2 = array5.length, result = 0;
        while (length2--) {
          if (array5[length2] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue2(object5, key) {
        return object5 == null ? undefined$1 : object5[key];
      }
      function hasUnicode(string3) {
        return reHasUnicode.test(string3);
      }
      function hasUnicodeWord(string3) {
        return reHasUnicodeWord.test(string3);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map2) {
        var index2 = -1, result = Array(map2.size);
        map2.forEach(function(value, key) {
          result[++index2] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array5, placeholder) {
        var index2 = -1, length2 = array5.length, resIndex = 0, result = [];
        while (++index2 < length2) {
          var value = array5[index2];
          if (value === placeholder || value === PLACEHOLDER) {
            array5[index2] = PLACEHOLDER;
            result[resIndex++] = index2;
          }
        }
        return result;
      }
      function setToArray(set5) {
        var index2 = -1, result = Array(set5.size);
        set5.forEach(function(value) {
          result[++index2] = value;
        });
        return result;
      }
      function setToPairs(set5) {
        var index2 = -1, result = Array(set5.size);
        set5.forEach(function(value) {
          result[++index2] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array5, value, fromIndex) {
        var index2 = fromIndex - 1, length2 = array5.length;
        while (++index2 < length2) {
          if (array5[index2] === value) {
            return index2;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array5, value, fromIndex) {
        var index2 = fromIndex + 1;
        while (index2--) {
          if (array5[index2] === value) {
            return index2;
          }
        }
        return index2;
      }
      function stringSize(string3) {
        return hasUnicode(string3) ? unicodeSize(string3) : asciiSize(string3);
      }
      function stringToArray(string3) {
        return hasUnicode(string3) ? unicodeToArray(string3) : asciiToArray(string3);
      }
      function trimmedEndIndex(string3) {
        var index2 = string3.length;
        while (index2-- && reWhitespace.test(string3.charAt(index2))) {
        }
        return index2;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string3) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string3)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string3) {
        return string3.match(reUnicode) || [];
      }
      function unicodeWords(string3) {
        return string3.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _2.defaults(root.Object(), context, _2.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty2 = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty2).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined$1, Symbol2 = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined$1, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice2 = arrayProto.splice, spreadableSymbol = Symbol2 ? Symbol2.isConcatSpreadable : undefined$1, symIterator = Symbol2 ? Symbol2.iterator : undefined$1, symToStringTag = Symbol2 ? Symbol2.toStringTag : undefined$1;
        var defineProperty3 = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e2) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined$1, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol2 ? Symbol2.prototype : undefined$1, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1, symbolToString = symbolProto ? symbolProto.toString : undefined$1;
        function lodash2(value) {
          if (isObjectLike(value) && !isArray2(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty2.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = function() {
          function object5() {
          }
          return function(proto) {
            if (!isObject2(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object5.prototype = proto;
            var result2 = new object5();
            object5.prototype = undefined$1;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined$1;
        }
        lodash2.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash2
          }
        };
        lodash2.prototype = baseLodash.prototype;
        lodash2.prototype.constructor = lodash2;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array5 = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray2(array5), isRight = dir < 0, arrLength = isArr ? array5.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length2 = end - start, index2 = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length2, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length2 && takeCount == length2) {
            return baseWrapperValue(array5, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length2-- && resIndex < takeCount) {
              index2 += dir;
              var iterIndex = -1, value = array5[index2];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type4 = data.type, computed3 = iteratee2(value);
                if (type4 == LAZY_MAP_FLAG) {
                  value = computed3;
                } else if (!computed3) {
                  if (type4 == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined$1 : result2;
          }
          return hasOwnProperty2.call(data, key) ? data[key] : undefined$1;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined$1 : hasOwnProperty2.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined$1 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index2 == lastIndex) {
            data.pop();
          } else {
            splice2.call(data, index2, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          return index2 < 0 ? undefined$1 : data[index2][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index2 = assocIndexOf(data, key);
          if (index2 < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index2][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index2 = -1, length2 = entries == null ? 0 : entries.length;
          this.clear();
          while (++index2 < length2) {
            var entry = entries[index2];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index2 = -1, length2 = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index2 < length2) {
            this.add(values2[index2]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray2(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer2(value), isType = !isArr && !isArg && !isBuff && isTypedArray2(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length2 = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty2.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length2)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array5) {
          var length2 = array5.length;
          return length2 ? array5[baseRandom(0, length2 - 1)] : undefined$1;
        }
        function arraySampleSize(array5, n2) {
          return shuffleSelf(copyArray(array5), baseClamp(n2, 0, array5.length));
        }
        function arrayShuffle(array5) {
          return shuffleSelf(copyArray(array5));
        }
        function assignMergeValue(object5, key, value) {
          if (value !== undefined$1 && !eq2(object5[key], value) || value === undefined$1 && !(key in object5)) {
            baseAssignValue(object5, key, value);
          }
        }
        function assignValue(object5, key, value) {
          var objValue = object5[key];
          if (!(hasOwnProperty2.call(object5, key) && eq2(objValue, value)) || value === undefined$1 && !(key in object5)) {
            baseAssignValue(object5, key, value);
          }
        }
        function assocIndexOf(array5, key) {
          var length2 = array5.length;
          while (length2--) {
            if (eq2(array5[length2][0], key)) {
              return length2;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object5, source) {
          return object5 && copyObject(source, keys2(source), object5);
        }
        function baseAssignIn(object5, source) {
          return object5 && copyObject(source, keysIn(source), object5);
        }
        function baseAssignValue(object5, key, value) {
          if (key == "__proto__" && defineProperty3) {
            defineProperty3(object5, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object5[key] = value;
          }
        }
        function baseAt(object5, paths) {
          var index2 = -1, length2 = paths.length, result2 = Array2(length2), skip = object5 == null;
          while (++index2 < length2) {
            result2[index2] = skip ? undefined$1 : get4(object5, paths[index2]);
          }
          return result2;
        }
        function baseClamp(number4, lower, upper) {
          if (number4 === number4) {
            if (upper !== undefined$1) {
              number4 = number4 <= upper ? number4 : upper;
            }
            if (lower !== undefined$1) {
              number4 = number4 >= lower ? number4 : lower;
            }
          }
          return number4;
        }
        function baseClone(value, bitmask, customizer, key, object5, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object5 ? customizer(value, key, object5, stack) : customizer(value);
          }
          if (result2 !== undefined$1) {
            return result2;
          }
          if (!isObject2(value)) {
            return value;
          }
          var isArr = isArray2(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer2(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object5) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object5 ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys2;
          var props = isArr ? undefined$1 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys2(source);
          return function(object5) {
            return baseConformsTo(object5, source, props);
          };
        }
        function baseConformsTo(object5, source, props) {
          var length2 = props.length;
          if (object5 == null) {
            return !length2;
          }
          object5 = Object2(object5);
          while (length2--) {
            var key = props[length2], predicate = source[key], value = object5[key];
            if (value === undefined$1 && !(key in object5) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined$1, args);
          }, wait);
        }
        function baseDifference(array5, values2, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, isCommon = true, length2 = array5.length, result2 = [], valuesLength = values2.length;
          if (!length2) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index2 < length2) {
              var value = array5[index2], computed3 = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed3 === computed3) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed3) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed3, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index2, collection2) {
            result2 = !!predicate(value, index2, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array5, iteratee2, comparator) {
          var index2 = -1, length2 = array5.length;
          while (++index2 < length2) {
            var value = array5[index2], current = iteratee2(value);
            if (current != null && (computed3 === undefined$1 ? current === current && !isSymbol(current) : comparator(current, computed3))) {
              var computed3 = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array5, value, start, end) {
          var length2 = array5.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end === undefined$1 || end > length2 ? length2 : toInteger(end);
          if (end < 0) {
            end += length2;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array5[start++] = value;
          }
          return array5;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index2, collection2) {
            if (predicate(value, index2, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array5, depth, predicate, isStrict, result2) {
          var index2 = -1, length2 = array5.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index2 < length2) {
            var value = array5[index2];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object5, iteratee2) {
          return object5 && baseFor(object5, iteratee2, keys2);
        }
        function baseForOwnRight(object5, iteratee2) {
          return object5 && baseForRight(object5, iteratee2, keys2);
        }
        function baseFunctions(object5, props) {
          return arrayFilter(props, function(key) {
            return isFunction2(object5[key]);
          });
        }
        function baseGet(object5, path2) {
          path2 = castPath(path2, object5);
          var index2 = 0, length2 = path2.length;
          while (object5 != null && index2 < length2) {
            object5 = object5[toKey(path2[index2++])];
          }
          return index2 && index2 == length2 ? object5 : undefined$1;
        }
        function baseGetAllKeys(object5, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object5);
          return isArray2(object5) ? result2 : arrayPush(result2, symbolsFunc(object5));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined$1 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object5, key) {
          return object5 != null && hasOwnProperty2.call(object5, key);
        }
        function baseHasIn(object5, key) {
          return object5 != null && key in Object2(object5);
        }
        function baseInRange(number4, start, end) {
          return number4 >= nativeMin(start, end) && number4 < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length2 = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array5 = arrays[othIndex];
            if (othIndex && iteratee2) {
              array5 = arrayMap(array5, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array5.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length2 >= 120 && array5.length >= 120) ? new SetCache(othIndex && array5) : undefined$1;
          }
          array5 = arrays[0];
          var index2 = -1, seen = caches[0];
          outer:
            while (++index2 < length2 && result2.length < maxLength) {
              var value = array5[index2], computed3 = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed3) : includes2(result2, computed3, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed3) : includes2(arrays[othIndex], computed3, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed3);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object5, setter, iteratee2, accumulator) {
          baseForOwn(object5, function(value, key, object6) {
            setter(accumulator, iteratee2(value), key, object6);
          });
          return accumulator;
        }
        function baseInvoke(object5, path2, args) {
          path2 = castPath(path2, object5);
          object5 = parent(object5, path2);
          var func = object5 == null ? object5 : object5[toKey(last(path2))];
          return func == null ? undefined$1 : apply(func, object5, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object5, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray2(object5), othIsArr = isArray2(other), objTag = objIsArr ? arrayTag : getTag(object5), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer2(object5)) {
            if (!isBuffer2(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray2(object5) ? equalArrays(object5, other, bitmask, customizer, equalFunc, stack) : equalByTag(object5, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty2.call(object5, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty2.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object5.value() : object5, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object5, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object5, source, matchData, customizer) {
          var index2 = matchData.length, length2 = index2, noCustomizer = !customizer;
          if (object5 == null) {
            return !length2;
          }
          object5 = Object2(object5);
          while (index2--) {
            var data = matchData[index2];
            if (noCustomizer && data[2] ? data[1] !== object5[data[0]] : !(data[0] in object5)) {
              return false;
            }
          }
          while (++index2 < length2) {
            data = matchData[index2];
            var key = data[0], objValue = object5[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined$1 && !(key in object5)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object5, source, stack);
              }
              if (!(result2 === undefined$1 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject2(value) || isMasked(value)) {
            return false;
          }
          var pattern4 = isFunction2(value) ? reIsNative : reIsHostCtor;
          return pattern4.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray2(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object5) {
          if (!isPrototype(object5)) {
            return nativeKeys(object5);
          }
          var result2 = [];
          for (var key in Object2(object5)) {
            if (hasOwnProperty2.call(object5, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object5) {
          if (!isObject2(object5)) {
            return nativeKeysIn(object5);
          }
          var isProto = isPrototype(object5), result2 = [];
          for (var key in object5) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty2.call(object5, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index2 = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index2] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object5) {
            return object5 === source || baseIsMatch(object5, source, matchData);
          };
        }
        function baseMatchesProperty(path2, srcValue) {
          if (isKey(path2) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path2), srcValue);
          }
          return function(object5) {
            var objValue = get4(object5, path2);
            return objValue === undefined$1 && objValue === srcValue ? hasIn(object5, path2) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object5, source, srcIndex, customizer, stack) {
          if (object5 === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject2(srcValue)) {
              baseMergeDeep(object5, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object5, key), srcValue, key + "", object5, source, stack) : undefined$1;
              if (newValue === undefined$1) {
                newValue = srcValue;
              }
              assignMergeValue(object5, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object5, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object5, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object5, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object5, source, stack) : undefined$1;
          var isCommon = newValue === undefined$1;
          if (isCommon) {
            var isArr = isArray2(srcValue), isBuff = !isArr && isBuffer2(srcValue), isTyped = !isArr && !isBuff && isTypedArray2(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray2(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject2(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject2(objValue) || isFunction2(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object5, key, newValue);
        }
        function baseNth(array5, n2) {
          var length2 = array5.length;
          if (!length2) {
            return;
          }
          n2 += n2 < 0 ? length2 : 0;
          return isIndex(n2, length2) ? array5[n2] : undefined$1;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray2(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index2 = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index2, "value": value };
          });
          return baseSortBy(result2, function(object5, other) {
            return compareMultiple(object5, other, orders);
          });
        }
        function basePick(object5, paths) {
          return basePickBy(object5, paths, function(value, path2) {
            return hasIn(object5, path2);
          });
        }
        function basePickBy(object5, paths, predicate) {
          var index2 = -1, length2 = paths.length, result2 = {};
          while (++index2 < length2) {
            var path2 = paths[index2], value = baseGet(object5, path2);
            if (predicate(value, path2)) {
              baseSet(result2, castPath(path2, object5), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path2) {
          return function(object5) {
            return baseGet(object5, path2);
          };
        }
        function basePullAll(array5, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index2 = -1, length2 = values2.length, seen = array5;
          if (array5 === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array5, baseUnary(iteratee2));
          }
          while (++index2 < length2) {
            var fromIndex = 0, value = values2[index2], computed3 = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed3, fromIndex, comparator)) > -1) {
              if (seen !== array5) {
                splice2.call(seen, fromIndex, 1);
              }
              splice2.call(array5, fromIndex, 1);
            }
          }
          return array5;
        }
        function basePullAt(array5, indexes) {
          var length2 = array5 ? indexes.length : 0, lastIndex = length2 - 1;
          while (length2--) {
            var index2 = indexes[length2];
            if (length2 == lastIndex || index2 !== previous) {
              var previous = index2;
              if (isIndex(index2)) {
                splice2.call(array5, index2, 1);
              } else {
                baseUnset(array5, index2);
              }
            }
          }
          return array5;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index2 = -1, length2 = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length2);
          while (length2--) {
            result2[fromRight ? length2 : ++index2] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string3, n2) {
          var result2 = "";
          if (!string3 || n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n2 % 2) {
              result2 += string3;
            }
            n2 = nativeFloor(n2 / 2);
            if (n2) {
              string3 += string3;
            }
          } while (n2);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n2) {
          var array5 = values(collection);
          return shuffleSelf(array5, baseClamp(n2, 0, array5.length));
        }
        function baseSet(object5, path2, value, customizer) {
          if (!isObject2(object5)) {
            return object5;
          }
          path2 = castPath(path2, object5);
          var index2 = -1, length2 = path2.length, lastIndex = length2 - 1, nested = object5;
          while (nested != null && ++index2 < length2) {
            var key = toKey(path2[index2]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object5;
            }
            if (index2 != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
              if (newValue === undefined$1) {
                newValue = isObject2(objValue) ? objValue : isIndex(path2[index2 + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object5;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty3 ? identity : function(func, string3) {
          return defineProperty3(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant2(string3),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array5, start, end) {
          var index2 = -1, length2 = array5.length;
          if (start < 0) {
            start = -start > length2 ? 0 : length2 + start;
          }
          end = end > length2 ? length2 : end;
          if (end < 0) {
            end += length2;
          }
          length2 = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length2);
          while (++index2 < length2) {
            result2[index2] = array5[index2 + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index2, collection2) {
            result2 = predicate(value, index2, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array5, value, retHighest) {
          var low = 0, high = array5 == null ? low : array5.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed3 = array5[mid];
              if (computed3 !== null && !isSymbol(computed3) && (retHighest ? computed3 <= value : computed3 < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array5, value, identity, retHighest);
        }
        function baseSortedIndexBy(array5, value, iteratee2, retHighest) {
          var low = 0, high = array5 == null ? 0 : array5.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined$1;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed3 = iteratee2(array5[mid]), othIsDefined = computed3 !== undefined$1, othIsNull = computed3 === null, othIsReflexive = computed3 === computed3, othIsSymbol = isSymbol(computed3);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed3 <= value : computed3 < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array5, iteratee2) {
          var index2 = -1, length2 = array5.length, resIndex = 0, result2 = [];
          while (++index2 < length2) {
            var value = array5[index2], computed3 = iteratee2 ? iteratee2(value) : value;
            if (!index2 || !eq2(computed3, seen)) {
              var seen = computed3;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray2(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array5, iteratee2, comparator) {
          var index2 = -1, includes2 = arrayIncludes, length2 = array5.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length2 >= LARGE_ARRAY_SIZE) {
            var set6 = iteratee2 ? null : createSet(array5);
            if (set6) {
              return setToArray(set6);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index2 < length2) {
              var value = array5[index2], computed3 = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed3 === computed3) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed3) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed3);
                }
                result2.push(value);
              } else if (!includes2(seen, computed3, comparator)) {
                if (seen !== result2) {
                  seen.push(computed3);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object5, path2) {
          path2 = castPath(path2, object5);
          object5 = parent(object5, path2);
          return object5 == null || delete object5[toKey(last(path2))];
        }
        function baseUpdate(object5, path2, updater, customizer) {
          return baseSet(object5, path2, updater(baseGet(object5, path2)), customizer);
        }
        function baseWhile(array5, predicate, isDrop, fromRight) {
          var length2 = array5.length, index2 = fromRight ? length2 : -1;
          while ((fromRight ? index2-- : ++index2 < length2) && predicate(array5[index2], index2, array5)) {
          }
          return isDrop ? baseSlice(array5, fromRight ? 0 : index2, fromRight ? index2 + 1 : length2) : baseSlice(array5, fromRight ? index2 + 1 : 0, fromRight ? length2 : index2);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action2) {
            return action2.func.apply(action2.thisArg, arrayPush([result3], action2.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length2 = arrays.length;
          if (length2 < 2) {
            return length2 ? baseUniq(arrays[0]) : [];
          }
          var index2 = -1, result2 = Array2(length2);
          while (++index2 < length2) {
            var array5 = arrays[index2], othIndex = -1;
            while (++othIndex < length2) {
              if (othIndex != index2) {
                result2[index2] = baseDifference(result2[index2] || array5, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index2 = -1, length2 = props.length, valsLength = values2.length, result2 = {};
          while (++index2 < length2) {
            var value = index2 < valsLength ? values2[index2] : undefined$1;
            assignFunc(result2, props[index2], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object5) {
          if (isArray2(value)) {
            return value;
          }
          return isKey(value, object5) ? [value] : stringToPath(toString3(value));
        }
        var castRest = baseRest;
        function castSlice(array5, start, end) {
          var length2 = array5.length;
          end = end === undefined$1 ? length2 : end;
          return !start && end >= length2 ? array5 : baseSlice(array5, start, end);
        }
        var clearTimeout2 = ctxClearTimeout || function(id2) {
          return root.clearTimeout(id2);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length2 = buffer.length, result2 = allocUnsafe ? allocUnsafe(length2) : new buffer.constructor(length2);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp4) {
          var result2 = new regexp4.constructor(regexp4.source, reFlags.exec(regexp4));
          result2.lastIndex = regexp4.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined$1, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined$1, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object5, other, orders) {
          var index2 = -1, objCriteria = object5.criteria, othCriteria = other.criteria, length2 = objCriteria.length, ordersLength = orders.length;
          while (++index2 < length2) {
            var result2 = compareAscending(objCriteria[index2], othCriteria[index2]);
            if (result2) {
              if (index2 >= ordersLength) {
                return result2;
              }
              var order = orders[index2];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object5.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset2 = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset2 + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset2 + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array5) {
          var index2 = -1, length2 = source.length;
          array5 || (array5 = Array2(length2));
          while (++index2 < length2) {
            array5[index2] = source[index2];
          }
          return array5;
        }
        function copyObject(source, props, object5, customizer) {
          var isNew = !object5;
          object5 || (object5 = {});
          var index2 = -1, length2 = props.length;
          while (++index2 < length2) {
            var key = props[index2];
            var newValue = customizer ? customizer(object5[key], source[key], key, object5, source) : undefined$1;
            if (newValue === undefined$1) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object5, key, newValue);
            } else {
              assignValue(object5, key, newValue);
            }
          }
          return object5;
        }
        function copySymbols(source, object5) {
          return copyObject(source, getSymbols(source), object5);
        }
        function copySymbolsIn(source, object5) {
          return copyObject(source, getSymbolsIn(source), object5);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray2(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object5, sources) {
            var index2 = -1, length2 = sources.length, customizer = length2 > 1 ? sources[length2 - 1] : undefined$1, guard = length2 > 2 ? sources[2] : undefined$1;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length2--, customizer) : undefined$1;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length2 < 3 ? undefined$1 : customizer;
              length2 = 1;
            }
            object5 = Object2(object5);
            while (++index2 < length2) {
              var source = sources[index2];
              if (source) {
                assigner(object5, source, index2, customizer);
              }
            }
            return object5;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length2 = collection.length, index2 = fromRight ? length2 : -1, iterable = Object2(collection);
            while (fromRight ? index2-- : ++index2 < length2) {
              if (iteratee2(iterable[index2], index2, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object5, iteratee2, keysFunc) {
            var index2 = -1, iterable = Object2(object5), props = keysFunc(object5), length2 = props.length;
            while (length2--) {
              var key = props[fromRight ? length2 : ++index2];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object5;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper2;
        }
        function createCaseFirst(methodName) {
          return function(string3) {
            string3 = toString3(string3);
            var strSymbols = hasUnicode(string3) ? stringToArray(string3) : undefined$1;
            var chr = strSymbols ? strSymbols[0] : string3.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string3.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string3) {
            return arrayReduce(words(deburr(string3).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject2(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index2 = length2, placeholder = getHolder(wrapper2);
            while (index2--) {
              args[index2] = arguments[index2];
            }
            var holders = length2 < 3 && args[0] !== placeholder && args[length2 - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length2 -= holders.length;
            if (length2 < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                undefined$1,
                args,
                holders,
                undefined$1,
                undefined$1,
                arity - length2
              );
            }
            var fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper2;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys2(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index2 = findIndexFunc(collection, predicate, fromIndex);
            return index2 > -1 ? iterable[iteratee2 ? collection[index2] : index2] : undefined$1;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length2 = funcs.length, index2 = length2, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index2--) {
              var func = funcs[index2];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper2 && getFuncName(func) == "wrapper") {
                var wrapper2 = new LodashWrapper([], true);
              }
            }
            index2 = wrapper2 ? index2 : length2;
            while (++index2 < length2) {
              func = funcs[index2];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined$1;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper2 = wrapper2[getFuncName(data[0])].apply(wrapper2, data[3]);
              } else {
                wrapper2 = func.length == 1 && isLaziable(func) ? wrapper2[funcName]() : wrapper2.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper2 && args.length == 1 && isArray2(value)) {
                return wrapper2.plant(value).value();
              }
              var index3 = 0, result2 = length2 ? funcs[index3].apply(this, args) : value;
              while (++index3 < length2) {
                result2 = funcs[index3].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined$1 : createCtor(func);
          function wrapper2() {
            var length2 = arguments.length, args = Array2(length2), index2 = length2;
            while (index2--) {
              args[index2] = arguments[index2];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper2), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length2 -= holdersCount;
            if (isCurried && length2 < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper2.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length2
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length2 = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length2 > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length2) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper2) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper2;
        }
        function createInverter(setter, toIteratee) {
          return function(object5, iteratee2) {
            return baseInverter(object5, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined$1 && other === undefined$1) {
              return defaultValue;
            }
            if (value !== undefined$1) {
              result2 = value;
            }
            if (other !== undefined$1) {
              if (result2 === undefined$1) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length2, chars) {
          chars = chars === undefined$1 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length2) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length2 / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length2).join("") : result2.slice(0, length2);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper2() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper2 ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper2;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined$1;
            }
            start = toFinite(start);
            if (end === undefined$1) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined$1 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined$1, newHoldersRight = isCurry ? undefined$1 : holders, newPartials = isCurry ? partials : undefined$1, newPartialsRight = isCurry ? undefined$1 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined$1, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number4, precision) {
            number4 = toNumber(number4);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number4)) {
              var pair = (toString3(number4) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString3(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number4);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop3 : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object5) {
            var tag = getTag(object5);
            if (tag == mapTag) {
              return mapToArray(object5);
            }
            if (tag == setTag) {
              return setToPairs(object5);
            }
            return baseToPairs(object5, keysFunc(object5));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length2 = partials ? partials.length : 0;
          if (!length2) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined$1;
          }
          ary2 = ary2 === undefined$1 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined$1 ? arity : toInteger(arity);
          length2 -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined$1;
          }
          var data = isBindKey ? undefined$1 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined$1 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length2, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined$1, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object5) {
          if (objValue === undefined$1 || eq2(objValue, objectProto[key]) && !hasOwnProperty2.call(object5, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object5, source, stack) {
          if (isObject2(objValue) && isObject2(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject2(value) ? undefined$1 : value;
        }
        function equalArrays(array5, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array5.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array5);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array5;
          }
          var index2 = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined$1;
          stack.set(array5, other);
          stack.set(other, array5);
          while (++index2 < arrLength) {
            var arrValue = array5[index2], othValue = other[index2];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index2, other, array5, stack) : customizer(arrValue, othValue, index2, array5, other, stack);
            }
            if (compared !== undefined$1) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array5);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object5, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object5.byteLength != other.byteLength || object5.byteOffset != other.byteOffset) {
                return false;
              }
              object5 = object5.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object5.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object5), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq2(+object5, +other);
            case errorTag:
              return object5.name == other.name && object5.message == other.message;
            case regexpTag:
            case stringTag:
              return object5 == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object5.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object5);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object5, other);
              var result2 = equalArrays(convert(object5), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object5);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object5) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object5, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object5), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index2 = objLength;
          while (index2--) {
            var key = objProps[index2];
            if (!(isPartial ? key in other : hasOwnProperty2.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object5);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object5;
          }
          var result2 = true;
          stack.set(object5, other);
          stack.set(other, object5);
          var skipCtor = isPartial;
          while (++index2 < objLength) {
            key = objProps[index2];
            var objValue = object5[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object5, stack) : customizer(objValue, othValue, key, object5, other, stack);
            }
            if (!(compared === undefined$1 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object5.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object5 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object5);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined$1, flatten), func + "");
        }
        function getAllKeys(object5) {
          return baseGetAllKeys(object5, keys2, getSymbols);
        }
        function getAllKeysIn(object5) {
          return baseGetAllKeys(object5, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop3 : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array5 = realNames[result2], length2 = hasOwnProperty2.call(realNames, result2) ? array5.length : 0;
          while (length2--) {
            var data = array5[length2], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object5 = hasOwnProperty2.call(lodash2, "placeholder") ? lodash2 : func;
          return object5.placeholder;
        }
        function getIteratee() {
          var result2 = lodash2.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map3, key) {
          var data = map3.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object5) {
          var result2 = keys2(object5), length2 = result2.length;
          while (length2--) {
            var key = result2[length2], value = object5[key];
            result2[length2] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object5, key) {
          var value = getValue2(object5, key);
          return baseIsNative(value) ? value : undefined$1;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty2.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined$1;
            var unmasked = true;
          } catch (e2) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object5) {
          if (object5 == null) {
            return [];
          }
          object5 = Object2(object5);
          return arrayFilter(nativeGetSymbols(object5), function(symbol) {
            return propertyIsEnumerable.call(object5, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object5) {
          var result2 = [];
          while (object5) {
            arrayPush(result2, getSymbols(object5));
            object5 = getPrototype(object5);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined$1, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index2 = -1, length2 = transforms.length;
          while (++index2 < length2) {
            var data = transforms[index2], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match2 = source.match(reWrapDetails);
          return match2 ? match2[1].split(reSplitDetails) : [];
        }
        function hasPath(object5, path2, hasFunc) {
          path2 = castPath(path2, object5);
          var index2 = -1, length2 = path2.length, result2 = false;
          while (++index2 < length2) {
            var key = toKey(path2[index2]);
            if (!(result2 = object5 != null && hasFunc(object5, key))) {
              break;
            }
            object5 = object5[key];
          }
          if (result2 || ++index2 != length2) {
            return result2;
          }
          length2 = object5 == null ? 0 : object5.length;
          return !!length2 && isLength(length2) && isIndex(key, length2) && (isArray2(object5) || isArguments(object5));
        }
        function initCloneArray(array5) {
          var length2 = array5.length, result2 = new array5.constructor(length2);
          if (length2 && typeof array5[0] == "string" && hasOwnProperty2.call(array5, "index")) {
            result2.index = array5.index;
            result2.input = array5.input;
          }
          return result2;
        }
        function initCloneObject(object5) {
          return typeof object5.constructor == "function" && !isPrototype(object5) ? baseCreate(getPrototype(object5)) : {};
        }
        function initCloneByTag(object5, tag, isDeep) {
          var Ctor = object5.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object5);
            case boolTag:
            case dateTag:
              return new Ctor(+object5);
            case dataViewTag:
              return cloneDataView(object5, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object5, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object5);
            case regexpTag:
              return cloneRegExp(object5);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object5);
          }
        }
        function insertWrapDetails(source, details) {
          var length2 = details.length;
          if (!length2) {
            return source;
          }
          var lastIndex = length2 - 1;
          details[lastIndex] = (length2 > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length2 > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray2(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length2) {
          var type4 = typeof value;
          length2 = length2 == null ? MAX_SAFE_INTEGER : length2;
          return !!length2 && (type4 == "number" || type4 != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length2);
        }
        function isIterateeCall(value, index2, object5) {
          if (!isObject2(object5)) {
            return false;
          }
          var type4 = typeof index2;
          if (type4 == "number" ? isArrayLike(object5) && isIndex(index2, object5.length) : type4 == "string" && index2 in object5) {
            return eq2(object5[index2], value);
          }
          return false;
        }
        function isKey(value, object5) {
          if (isArray2(value)) {
            return false;
          }
          var type4 = typeof value;
          if (type4 == "number" || type4 == "symbol" || type4 == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object5 != null && value in Object2(object5);
        }
        function isKeyable(value) {
          var type4 = typeof value;
          return type4 == "string" || type4 == "number" || type4 == "symbol" || type4 == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash2[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction2 : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject2(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object5) {
            if (object5 == null) {
              return false;
            }
            return object5[key] === srcValue && (srcValue !== undefined$1 || key in Object2(object5));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object5) {
          var result2 = [];
          if (object5 != null) {
            for (var key in Object2(object5)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined$1 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index2 = -1, length2 = nativeMax(args.length - start, 0), array5 = Array2(length2);
            while (++index2 < length2) {
              array5[index2] = args[start + index2];
            }
            index2 = -1;
            var otherArgs = Array2(start + 1);
            while (++index2 < start) {
              otherArgs[index2] = args[index2];
            }
            otherArgs[start] = transform2(array5);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object5, path2) {
          return path2.length < 2 ? object5 : baseGet(object5, baseSlice(path2, 0, -1));
        }
        function reorder(array5, indexes) {
          var arrLength = array5.length, length2 = nativeMin(indexes.length, arrLength), oldArray = copyArray(array5);
          while (length2--) {
            var index2 = indexes[length2];
            array5[length2] = isIndex(index2, arrLength) ? oldArray[index2] : undefined$1;
          }
          return array5;
        }
        function safeGet(object5, key) {
          if (key === "constructor" && typeof object5[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object5[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper2, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper2, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined$1, arguments);
          };
        }
        function shuffleSelf(array5, size2) {
          var index2 = -1, length2 = array5.length, lastIndex = length2 - 1;
          size2 = size2 === undefined$1 ? length2 : size2;
          while (++index2 < size2) {
            var rand = baseRandom(index2, lastIndex), value = array5[rand];
            array5[rand] = array5[index2];
            array5[index2] = value;
          }
          array5.length = size2;
          return array5;
        }
        var stringToPath = memoizeCapped(function(string3) {
          var result2 = [];
          if (string3.charCodeAt(0) === 46) {
            result2.push("");
          }
          string3.replace(rePropName, function(match2, number4, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number4 || match2);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e2) {
            }
            try {
              return func + "";
            } catch (e2) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper2) {
          if (wrapper2 instanceof LazyWrapper) {
            return wrapper2.clone();
          }
          var result2 = new LodashWrapper(wrapper2.__wrapped__, wrapper2.__chain__);
          result2.__actions__ = copyArray(wrapper2.__actions__);
          result2.__index__ = wrapper2.__index__;
          result2.__values__ = wrapper2.__values__;
          return result2;
        }
        function chunk(array5, size2, guard) {
          if (guard ? isIterateeCall(array5, size2, guard) : size2 === undefined$1) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2 || size2 < 1) {
            return [];
          }
          var index2 = 0, resIndex = 0, result2 = Array2(nativeCeil(length2 / size2));
          while (index2 < length2) {
            result2[resIndex++] = baseSlice(array5, index2, index2 += size2);
          }
          return result2;
        }
        function compact(array5) {
          var index2 = -1, length2 = array5 == null ? 0 : array5.length, resIndex = 0, result2 = [];
          while (++index2 < length2) {
            var value = array5[index2];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length2 = arguments.length;
          if (!length2) {
            return [];
          }
          var args = Array2(length2 - 1), array5 = arguments[0], index2 = length2;
          while (index2--) {
            args[index2 - 1] = arguments[index2];
          }
          return arrayPush(isArray2(array5) ? copyArray(array5) : [array5], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array5, values2) {
          return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array5, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array5, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined$1;
          }
          return isArrayLikeObject(array5) ? baseDifference(array5, baseFlatten(values2, 1, isArrayLikeObject, true), undefined$1, comparator) : [];
        });
        function drop(array5, n2, guard) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array5, n2 < 0 ? 0 : n2, length2);
        }
        function dropRight(array5, n2, guard) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length2 - n2;
          return baseSlice(array5, 0, n2 < 0 ? 0 : n2);
        }
        function dropRightWhile(array5, predicate) {
          return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array5, predicate) {
          return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), true) : [];
        }
        function fill(array5, value, start, end) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array5, value, start)) {
            start = 0;
            end = length2;
          }
          return baseFill(array5, value, start, end);
        }
        function findIndex(array5, predicate, fromIndex) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length2 + index2, 0);
          }
          return baseFindIndex(array5, getIteratee(predicate, 3), index2);
        }
        function findLastIndex(array5, predicate, fromIndex) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return -1;
          }
          var index2 = length2 - 1;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = fromIndex < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
          }
          return baseFindIndex(array5, getIteratee(predicate, 3), index2, true);
        }
        function flatten(array5) {
          var length2 = array5 == null ? 0 : array5.length;
          return length2 ? baseFlatten(array5, 1) : [];
        }
        function flattenDeep(array5) {
          var length2 = array5 == null ? 0 : array5.length;
          return length2 ? baseFlatten(array5, INFINITY) : [];
        }
        function flattenDepth(array5, depth) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(array5, depth);
        }
        function fromPairs(pairs) {
          var index2 = -1, length2 = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index2 < length2) {
            var pair = pairs[index2];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array5) {
          return array5 && array5.length ? array5[0] : undefined$1;
        }
        function indexOf(array5, value, fromIndex) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return -1;
          }
          var index2 = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index2 < 0) {
            index2 = nativeMax(length2 + index2, 0);
          }
          return baseIndexOf(array5, value, index2);
        }
        function initial(array5) {
          var length2 = array5 == null ? 0 : array5.length;
          return length2 ? baseSlice(array5, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined$1;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined$1, comparator) : [];
        });
        function join(array5, separator) {
          return array5 == null ? "" : nativeJoin.call(array5, separator);
        }
        function last(array5) {
          var length2 = array5 == null ? 0 : array5.length;
          return length2 ? array5[length2 - 1] : undefined$1;
        }
        function lastIndexOf(array5, value, fromIndex) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return -1;
          }
          var index2 = length2;
          if (fromIndex !== undefined$1) {
            index2 = toInteger(fromIndex);
            index2 = index2 < 0 ? nativeMax(length2 + index2, 0) : nativeMin(index2, length2 - 1);
          }
          return value === value ? strictLastIndexOf(array5, value, index2) : baseFindIndex(array5, baseIsNaN, index2, true);
        }
        function nth(array5, n2) {
          return array5 && array5.length ? baseNth(array5, toInteger(n2)) : undefined$1;
        }
        var pull = baseRest(pullAll);
        function pullAll(array5, values2) {
          return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2) : array5;
        }
        function pullAllBy(array5, values2, iteratee2) {
          return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2, getIteratee(iteratee2, 2)) : array5;
        }
        function pullAllWith(array5, values2, comparator) {
          return array5 && array5.length && values2 && values2.length ? basePullAll(array5, values2, undefined$1, comparator) : array5;
        }
        var pullAt = flatRest(function(array5, indexes) {
          var length2 = array5 == null ? 0 : array5.length, result2 = baseAt(array5, indexes);
          basePullAt(array5, arrayMap(indexes, function(index2) {
            return isIndex(index2, length2) ? +index2 : index2;
          }).sort(compareAscending));
          return result2;
        });
        function remove2(array5, predicate) {
          var result2 = [];
          if (!(array5 && array5.length)) {
            return result2;
          }
          var index2 = -1, indexes = [], length2 = array5.length;
          predicate = getIteratee(predicate, 3);
          while (++index2 < length2) {
            var value = array5[index2];
            if (predicate(value, index2, array5)) {
              result2.push(value);
              indexes.push(index2);
            }
          }
          basePullAt(array5, indexes);
          return result2;
        }
        function reverse2(array5) {
          return array5 == null ? array5 : nativeReverse.call(array5);
        }
        function slice2(array5, start, end) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array5, start, end)) {
            start = 0;
            end = length2;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined$1 ? length2 : toInteger(end);
          }
          return baseSlice(array5, start, end);
        }
        function sortedIndex(array5, value) {
          return baseSortedIndex(array5, value);
        }
        function sortedIndexBy(array5, value, iteratee2) {
          return baseSortedIndexBy(array5, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array5, value) {
          var length2 = array5 == null ? 0 : array5.length;
          if (length2) {
            var index2 = baseSortedIndex(array5, value);
            if (index2 < length2 && eq2(array5[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedLastIndex(array5, value) {
          return baseSortedIndex(array5, value, true);
        }
        function sortedLastIndexBy(array5, value, iteratee2) {
          return baseSortedIndexBy(array5, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array5, value) {
          var length2 = array5 == null ? 0 : array5.length;
          if (length2) {
            var index2 = baseSortedIndex(array5, value, true) - 1;
            if (eq2(array5[index2], value)) {
              return index2;
            }
          }
          return -1;
        }
        function sortedUniq(array5) {
          return array5 && array5.length ? baseSortedUniq(array5) : [];
        }
        function sortedUniqBy(array5, iteratee2) {
          return array5 && array5.length ? baseSortedUniq(array5, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array5) {
          var length2 = array5 == null ? 0 : array5.length;
          return length2 ? baseSlice(array5, 1, length2) : [];
        }
        function take(array5, n2, guard) {
          if (!(array5 && array5.length)) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          return baseSlice(array5, 0, n2 < 0 ? 0 : n2);
        }
        function takeRight(array5, n2, guard) {
          var length2 = array5 == null ? 0 : array5.length;
          if (!length2) {
            return [];
          }
          n2 = guard || n2 === undefined$1 ? 1 : toInteger(n2);
          n2 = length2 - n2;
          return baseSlice(array5, n2 < 0 ? 0 : n2, length2);
        }
        function takeRightWhile(array5, predicate) {
          return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array5, predicate) {
          return array5 && array5.length ? baseWhile(array5, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
        });
        function uniq(array5) {
          return array5 && array5.length ? baseUniq(array5) : [];
        }
        function uniqBy(array5, iteratee2) {
          return array5 && array5.length ? baseUniq(array5, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array5, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return array5 && array5.length ? baseUniq(array5, undefined$1, comparator) : [];
        }
        function unzip(array5) {
          if (!(array5 && array5.length)) {
            return [];
          }
          var length2 = 0;
          array5 = arrayFilter(array5, function(group) {
            if (isArrayLikeObject(group)) {
              length2 = nativeMax(group.length, length2);
              return true;
            }
          });
          return baseTimes(length2, function(index2) {
            return arrayMap(array5, baseProperty(index2));
          });
        }
        function unzipWith(array5, iteratee2) {
          if (!(array5 && array5.length)) {
            return [];
          }
          var result2 = unzip(array5);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined$1, group);
          });
        }
        var without = baseRest(function(array5, values2) {
          return isArrayLikeObject(array5) ? baseDifference(array5, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined$1;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined$1;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length2 = arrays.length, iteratee2 = length2 > 1 ? arrays[length2 - 1] : undefined$1;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined$1;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash2(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length2 = paths.length, start = length2 ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object5) {
            return baseAt(object5, paths);
          };
          if (length2 > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length2 ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined$1
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array5) {
            if (length2 && !array5.length) {
              array5.push(undefined$1);
            }
            return array5;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined$1) {
            this.__values__ = toArray2(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined$1 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined$1;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse2],
              "thisArg": undefined$1
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse2);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray2(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter2(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map2(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined$1 ? 1 : toInteger(depth);
          return baseFlatten(map2(collection, iteratee2), depth);
        }
        function forEach2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray2(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty2.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length2 = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length2 + fromIndex, 0);
          }
          return isString2(collection) ? fromIndex <= length2 && collection.indexOf(value, fromIndex) > -1 : !!length2 && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path2, args) {
          var index2 = -1, isFunc = typeof path2 == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index2] = isFunc ? apply(path2, value, args) : baseInvoke(value, path2, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map2(collection, iteratee2) {
          var func = isArray2(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray2(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined$1 : orders;
          if (!isArray2(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray2(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray2(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray2(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n2, guard) {
          if (guard ? isIterateeCall(collection, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          var func = isArray2(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n2);
        }
        function shuffle(collection) {
          var func = isArray2(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString2(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray2(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined$1;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length2 = iteratees.length;
          if (length2 > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length2 > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n2, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n2, guard) {
          n2 = guard ? undefined$1 : n2;
          n2 = func && n2 == null ? func.length : n2;
          return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n2);
        }
        function before(n2, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n2 = toInteger(n2);
          return function() {
            if (--n2 > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n2 <= 1) {
              func = undefined$1;
            }
            return result2;
          };
        }
        var bind3 = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind3));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object5, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object5, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined$1 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce2(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject2(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined$1;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined$1 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined$1;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined$1;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined$1) {
              clearTimeout2(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined$1;
          }
          function flush() {
            return timerId === undefined$1 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined$1) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout2(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined$1) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once2(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray2(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index2 = -1, length2 = nativeMin(args.length, funcsLength);
            while (++index2 < length2) {
              args[index2] = transforms[index2].call(this, args[index2]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined$1 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread2(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array5 = args[start], otherArgs = castSlice(args, 0, start);
            if (array5) {
              arrayPush(otherArgs, array5);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle2(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject2(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce2(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper2) {
          return partial(castFunction(wrapper2), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray2(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object5, source) {
          return source == null || baseConformsTo(object5, source, keys2(source));
        }
        function eq2(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty2.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray2 = Array2.isArray;
        var isArrayBuffer2 = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction2(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean2(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer2 = nativeIsBuffer || stubFalse;
        var isDate2 = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject2(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray2(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer2(value) || isTypedArray2(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty2.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual2(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          var result2 = customizer ? customizer(value, other) : undefined$1;
          return result2 === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject2(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction2(value) {
          if (!isObject2(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject2(value) {
          var type4 = typeof value;
          return value != null && (type4 == "object" || type4 == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object5, source) {
          return object5 === source || baseIsMatch(object5, source, getMatchData(source));
        }
        function isMatchWith(object5, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return baseIsMatch(object5, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber2(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber2(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject2(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp2 = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString2(value) {
          return typeof value == "string" || !isArray2(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray2 = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined2(value) {
          return value === undefined$1;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray2(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString2(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject2(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject2(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString3(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign2 = createAssigner(function(object5, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys2(source), object5);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty2.call(source, key)) {
              assignValue(object5, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object5, source) {
          copyObject(source, keysIn(source), object5);
        });
        var assignInWith = createAssigner(function(object5, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object5, customizer);
        });
        var assignWith = createAssigner(function(object5, source, srcIndex, customizer) {
          copyObject(source, keys2(source), object5, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype2, properties) {
          var result2 = baseCreate(prototype2);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults2 = baseRest(function(object5, sources) {
          object5 = Object2(object5);
          var index2 = -1;
          var length2 = sources.length;
          var guard = length2 > 2 ? sources[2] : undefined$1;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length2 = 1;
          }
          while (++index2 < length2) {
            var source = sources[index2];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object5[key];
              if (value === undefined$1 || eq2(value, objectProto[key]) && !hasOwnProperty2.call(object5, key)) {
                object5[key] = source[key];
              }
            }
          }
          return object5;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined$1, customDefaultsMerge);
          return apply(mergeWith, undefined$1, args);
        });
        function findKey2(object5, predicate) {
          return baseFindKey(object5, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object5, predicate) {
          return baseFindKey(object5, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object5, iteratee2) {
          return object5 == null ? object5 : baseFor(object5, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object5, iteratee2) {
          return object5 == null ? object5 : baseForRight(object5, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object5, iteratee2) {
          return object5 && baseForOwn(object5, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object5, iteratee2) {
          return object5 && baseForOwnRight(object5, getIteratee(iteratee2, 3));
        }
        function functions(object5) {
          return object5 == null ? [] : baseFunctions(object5, keys2(object5));
        }
        function functionsIn(object5) {
          return object5 == null ? [] : baseFunctions(object5, keysIn(object5));
        }
        function get4(object5, path2, defaultValue) {
          var result2 = object5 == null ? undefined$1 : baseGet(object5, path2);
          return result2 === undefined$1 ? defaultValue : result2;
        }
        function has2(object5, path2) {
          return object5 != null && hasPath(object5, path2, baseHas);
        }
        function hasIn(object5, path2) {
          return object5 != null && hasPath(object5, path2, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant2(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty2.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys2(object5) {
          return isArrayLike(object5) ? arrayLikeKeys(object5) : baseKeys(object5);
        }
        function keysIn(object5) {
          return isArrayLike(object5) ? arrayLikeKeys(object5, true) : baseKeysIn(object5);
        }
        function mapKeys(object5, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object5, function(value, key, object6) {
            baseAssignValue(result2, iteratee2(value, key, object6), value);
          });
          return result2;
        }
        function mapValues(object5, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object5, function(value, key, object6) {
            baseAssignValue(result2, key, iteratee2(value, key, object6));
          });
          return result2;
        }
        var merge2 = createAssigner(function(object5, source, srcIndex) {
          baseMerge(object5, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object5, source, srcIndex, customizer) {
          baseMerge(object5, source, srcIndex, customizer);
        });
        var omit2 = flatRest(function(object5, paths) {
          var result2 = {};
          if (object5 == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path2) {
            path2 = castPath(path2, object5);
            isDeep || (isDeep = path2.length > 1);
            return path2;
          });
          copyObject(object5, getAllKeysIn(object5), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length2 = paths.length;
          while (length2--) {
            baseUnset(result2, paths[length2]);
          }
          return result2;
        });
        function omitBy(object5, predicate) {
          return pickBy(object5, negate(getIteratee(predicate)));
        }
        var pick2 = flatRest(function(object5, paths) {
          return object5 == null ? {} : basePick(object5, paths);
        });
        function pickBy(object5, predicate) {
          if (object5 == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object5), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object5, props, function(value, path2) {
            return predicate(value, path2[0]);
          });
        }
        function result(object5, path2, defaultValue) {
          path2 = castPath(path2, object5);
          var index2 = -1, length2 = path2.length;
          if (!length2) {
            length2 = 1;
            object5 = undefined$1;
          }
          while (++index2 < length2) {
            var value = object5 == null ? undefined$1 : object5[toKey(path2[index2])];
            if (value === undefined$1) {
              index2 = length2;
              value = defaultValue;
            }
            object5 = isFunction2(value) ? value.call(object5) : value;
          }
          return object5;
        }
        function set5(object5, path2, value) {
          return object5 == null ? object5 : baseSet(object5, path2, value);
        }
        function setWith(object5, path2, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object5 == null ? object5 : baseSet(object5, path2, value, customizer);
        }
        var toPairs = createToPairs(keys2);
        var toPairsIn = createToPairs(keysIn);
        function transform(object5, iteratee2, accumulator) {
          var isArr = isArray2(object5), isArrLike = isArr || isBuffer2(object5) || isTypedArray2(object5);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object5 && object5.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject2(object5)) {
              accumulator = isFunction2(Ctor) ? baseCreate(getPrototype(object5)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object5, function(value, index2, object6) {
            return iteratee2(accumulator, value, index2, object6);
          });
          return accumulator;
        }
        function unset(object5, path2) {
          return object5 == null ? true : baseUnset(object5, path2);
        }
        function update(object5, path2, updater) {
          return object5 == null ? object5 : baseUpdate(object5, path2, castFunction(updater));
        }
        function updateWith(object5, path2, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined$1;
          return object5 == null ? object5 : baseUpdate(object5, path2, castFunction(updater), customizer);
        }
        function values(object5) {
          return object5 == null ? [] : baseValues(object5, keys2(object5));
        }
        function valuesIn(object5) {
          return object5 == null ? [] : baseValues(object5, keysIn(object5));
        }
        function clamp(number4, lower, upper) {
          if (upper === undefined$1) {
            upper = lower;
            lower = undefined$1;
          }
          if (upper !== undefined$1) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined$1) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number4), lower, upper);
        }
        function inRange(number4, start, end) {
          start = toFinite(start);
          if (end === undefined$1) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number4 = toNumber(number4);
          return baseInRange(number4, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined$1;
          }
          if (floating === undefined$1) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined$1;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined$1;
            }
          }
          if (lower === undefined$1 && upper === undefined$1) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined$1) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index2) {
          word = word.toLowerCase();
          return result2 + (index2 ? capitalize(word) : word);
        });
        function capitalize(string3) {
          return upperFirst(toString3(string3).toLowerCase());
        }
        function deburr(string3) {
          string3 = toString3(string3);
          return string3 && string3.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith2(string3, target, position2) {
          string3 = toString3(string3);
          target = baseToString(target);
          var length2 = string3.length;
          position2 = position2 === undefined$1 ? length2 : baseClamp(toInteger(position2), 0, length2);
          var end = position2;
          position2 -= target.length;
          return position2 >= 0 && string3.slice(position2, end) == target;
        }
        function escape(string3) {
          string3 = toString3(string3);
          return string3 && reHasUnescapedHtml.test(string3) ? string3.replace(reUnescapedHtml, escapeHtmlChar) : string3;
        }
        function escapeRegExp(string3) {
          string3 = toString3(string3);
          return string3 && reHasRegExpChar.test(string3) ? string3.replace(reRegExpChar, "\\$&") : string3;
        }
        var kebabCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string3, length2, chars) {
          string3 = toString3(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          if (!length2 || strLength >= length2) {
            return string3;
          }
          var mid = (length2 - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string3 + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string3, length2, chars) {
          string3 = toString3(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? string3 + createPadding(length2 - strLength, chars) : string3;
        }
        function padStart(string3, length2, chars) {
          string3 = toString3(string3);
          length2 = toInteger(length2);
          var strLength = length2 ? stringSize(string3) : 0;
          return length2 && strLength < length2 ? createPadding(length2 - strLength, chars) + string3 : string3;
        }
        function parseInt2(string3, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString3(string3).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string3, n2, guard) {
          if (guard ? isIterateeCall(string3, n2, guard) : n2 === undefined$1) {
            n2 = 1;
          } else {
            n2 = toInteger(n2);
          }
          return baseRepeat(toString3(string3), n2);
        }
        function replace3() {
          var args = arguments, string3 = toString3(args[0]);
          return args.length < 3 ? string3 : string3.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? "_" : "") + word.toLowerCase();
        });
        function split(string3, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string3, separator, limit)) {
            separator = limit = undefined$1;
          }
          limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string3 = toString3(string3);
          if (string3 && (typeof separator == "string" || separator != null && !isRegExp2(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string3)) {
              return castSlice(stringToArray(string3), 0, limit);
            }
          }
          return string3.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + upperFirst(word);
        });
        function startsWith(string3, target, position2) {
          string3 = toString3(string3);
          position2 = position2 == null ? 0 : baseClamp(toInteger(position2), 0, string3.length);
          target = baseToString(target);
          return string3.slice(position2, position2 + target.length) == target;
        }
        function template(string3, options, guard) {
          var settings = lodash2.templateSettings;
          if (guard && isIterateeCall(string3, options, guard)) {
            options = undefined$1;
          }
          string3 = toString3(string3);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys2(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index2 = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty2.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string3.replace(reDelimiters, function(match2, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset2) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string3.slice(index2, offset2).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index2 = offset2 + match2.length;
            return match2;
          });
          source += "';\n";
          var variable = hasOwnProperty2.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined$1, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString3(value).toLowerCase();
        }
        function toUpper(value) {
          return toString3(value).toUpperCase();
        }
        function trim2(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return baseTrim(string3);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return string3.slice(0, trimmedEndIndex(string3) + 1);
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string3, chars, guard) {
          string3 = toString3(string3);
          if (string3 && (guard || chars === undefined$1)) {
            return string3.replace(reTrimStart, "");
          }
          if (!string3 || !(chars = baseToString(chars))) {
            return string3;
          }
          var strSymbols = stringToArray(string3), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string3, options) {
          var length2 = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject2(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length2 = "length" in options ? toInteger(options.length) : length2;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string3 = toString3(string3);
          var strLength = string3.length;
          if (hasUnicode(string3)) {
            var strSymbols = stringToArray(string3);
            strLength = strSymbols.length;
          }
          if (length2 >= strLength) {
            return string3;
          }
          var end = length2 - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string3.slice(0, end);
          if (separator === undefined$1) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp2(separator)) {
            if (string3.slice(end).search(separator)) {
              var match2, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString3(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match2 = separator.exec(substring)) {
                var newEnd = match2.index;
              }
              result2 = result2.slice(0, newEnd === undefined$1 ? end : newEnd);
            }
          } else if (string3.indexOf(baseToString(separator), end) != end) {
            var index2 = result2.lastIndexOf(separator);
            if (index2 > -1) {
              result2 = result2.slice(0, index2);
            }
          }
          return result2 + omission;
        }
        function unescape2(string3) {
          string3 = toString3(string3);
          return string3 && reHasEscapedHtml.test(string3) ? string3.replace(reEscapedHtml, unescapeHtmlChar) : string3;
        }
        var upperCase = createCompounder(function(result2, word, index2) {
          return result2 + (index2 ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string3, pattern4, guard) {
          string3 = toString3(string3);
          pattern4 = guard ? undefined$1 : pattern4;
          if (pattern4 === undefined$1) {
            return hasUnicodeWord(string3) ? unicodeWords(string3) : asciiWords(string3);
          }
          return string3.match(pattern4) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined$1, args);
          } catch (e2) {
            return isError(e2) ? e2 : new Error2(e2);
          }
        });
        var bindAll = flatRest(function(object5, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object5, key, bind3(object5[key], object5));
          });
          return object5;
        });
        function cond(pairs) {
          var length2 = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length2 ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index2 = -1;
            while (++index2 < length2) {
              var pair = pairs[index2];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant2(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow3 = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path2, srcValue) {
          return baseMatchesProperty(path2, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method4 = baseRest(function(path2, args) {
          return function(object5) {
            return baseInvoke(object5, path2, args);
          };
        });
        var methodOf = baseRest(function(object5, args) {
          return function(path2) {
            return baseInvoke(object5, path2, args);
          };
        });
        function mixin(object5, source, options) {
          var props = keys2(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject2(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object5;
            object5 = this;
            methodNames = baseFunctions(source, keys2(source));
          }
          var chain2 = !(isObject2(options) && "chain" in options) || !!options.chain, isFunc = isFunction2(object5);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object5[methodName] = func;
            if (isFunc) {
              object5.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object5(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object5 });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object5, arrayPush([this.value()], arguments));
              };
            }
          });
          return object5;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop3() {
        }
        function nthArg(n2) {
          n2 = toInteger(n2);
          return baseRest(function(args) {
            return baseNth(args, n2);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path2) {
          return isKey(path2) ? baseProperty(toKey(path2)) : basePropertyDeep(path2);
        }
        function propertyOf(object5) {
          return function(path2) {
            return object5 == null ? undefined$1 : baseGet(object5, path2);
          };
        }
        var range3 = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n2, iteratee2) {
          n2 = toInteger(n2);
          if (n2 < 1 || n2 > MAX_SAFE_INTEGER) {
            return [];
          }
          var index2 = MAX_ARRAY_LENGTH, length2 = nativeMin(n2, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n2 -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length2, iteratee2);
          while (++index2 < n2) {
            iteratee2(index2);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray2(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString3(value)));
        }
        function uniqueId(prefix) {
          var id2 = ++idCounter;
          return toString3(prefix) + id2;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array5) {
          return array5 && array5.length ? baseExtremum(array5, identity, baseGt) : undefined$1;
        }
        function maxBy(array5, iteratee2) {
          return array5 && array5.length ? baseExtremum(array5, getIteratee(iteratee2, 2), baseGt) : undefined$1;
        }
        function mean(array5) {
          return baseMean(array5, identity);
        }
        function meanBy(array5, iteratee2) {
          return baseMean(array5, getIteratee(iteratee2, 2));
        }
        function min(array5) {
          return array5 && array5.length ? baseExtremum(array5, identity, baseLt) : undefined$1;
        }
        function minBy(array5, iteratee2) {
          return array5 && array5.length ? baseExtremum(array5, getIteratee(iteratee2, 2), baseLt) : undefined$1;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array5) {
          return array5 && array5.length ? baseSum(array5, identity) : 0;
        }
        function sumBy(array5, iteratee2) {
          return array5 && array5.length ? baseSum(array5, getIteratee(iteratee2, 2)) : 0;
        }
        lodash2.after = after;
        lodash2.ary = ary;
        lodash2.assign = assign2;
        lodash2.assignIn = assignIn;
        lodash2.assignInWith = assignInWith;
        lodash2.assignWith = assignWith;
        lodash2.at = at;
        lodash2.before = before;
        lodash2.bind = bind3;
        lodash2.bindAll = bindAll;
        lodash2.bindKey = bindKey;
        lodash2.castArray = castArray;
        lodash2.chain = chain;
        lodash2.chunk = chunk;
        lodash2.compact = compact;
        lodash2.concat = concat;
        lodash2.cond = cond;
        lodash2.conforms = conforms;
        lodash2.constant = constant2;
        lodash2.countBy = countBy;
        lodash2.create = create;
        lodash2.curry = curry;
        lodash2.curryRight = curryRight;
        lodash2.debounce = debounce2;
        lodash2.defaults = defaults2;
        lodash2.defaultsDeep = defaultsDeep;
        lodash2.defer = defer;
        lodash2.delay = delay;
        lodash2.difference = difference;
        lodash2.differenceBy = differenceBy;
        lodash2.differenceWith = differenceWith;
        lodash2.drop = drop;
        lodash2.dropRight = dropRight;
        lodash2.dropRightWhile = dropRightWhile;
        lodash2.dropWhile = dropWhile;
        lodash2.fill = fill;
        lodash2.filter = filter2;
        lodash2.flatMap = flatMap;
        lodash2.flatMapDeep = flatMapDeep;
        lodash2.flatMapDepth = flatMapDepth;
        lodash2.flatten = flatten;
        lodash2.flattenDeep = flattenDeep;
        lodash2.flattenDepth = flattenDepth;
        lodash2.flip = flip;
        lodash2.flow = flow3;
        lodash2.flowRight = flowRight;
        lodash2.fromPairs = fromPairs;
        lodash2.functions = functions;
        lodash2.functionsIn = functionsIn;
        lodash2.groupBy = groupBy;
        lodash2.initial = initial;
        lodash2.intersection = intersection;
        lodash2.intersectionBy = intersectionBy;
        lodash2.intersectionWith = intersectionWith;
        lodash2.invert = invert;
        lodash2.invertBy = invertBy;
        lodash2.invokeMap = invokeMap;
        lodash2.iteratee = iteratee;
        lodash2.keyBy = keyBy;
        lodash2.keys = keys2;
        lodash2.keysIn = keysIn;
        lodash2.map = map2;
        lodash2.mapKeys = mapKeys;
        lodash2.mapValues = mapValues;
        lodash2.matches = matches;
        lodash2.matchesProperty = matchesProperty;
        lodash2.memoize = memoize;
        lodash2.merge = merge2;
        lodash2.mergeWith = mergeWith;
        lodash2.method = method4;
        lodash2.methodOf = methodOf;
        lodash2.mixin = mixin;
        lodash2.negate = negate;
        lodash2.nthArg = nthArg;
        lodash2.omit = omit2;
        lodash2.omitBy = omitBy;
        lodash2.once = once2;
        lodash2.orderBy = orderBy;
        lodash2.over = over;
        lodash2.overArgs = overArgs;
        lodash2.overEvery = overEvery;
        lodash2.overSome = overSome;
        lodash2.partial = partial;
        lodash2.partialRight = partialRight;
        lodash2.partition = partition;
        lodash2.pick = pick2;
        lodash2.pickBy = pickBy;
        lodash2.property = property;
        lodash2.propertyOf = propertyOf;
        lodash2.pull = pull;
        lodash2.pullAll = pullAll;
        lodash2.pullAllBy = pullAllBy;
        lodash2.pullAllWith = pullAllWith;
        lodash2.pullAt = pullAt;
        lodash2.range = range3;
        lodash2.rangeRight = rangeRight;
        lodash2.rearg = rearg;
        lodash2.reject = reject;
        lodash2.remove = remove2;
        lodash2.rest = rest;
        lodash2.reverse = reverse2;
        lodash2.sampleSize = sampleSize;
        lodash2.set = set5;
        lodash2.setWith = setWith;
        lodash2.shuffle = shuffle;
        lodash2.slice = slice2;
        lodash2.sortBy = sortBy;
        lodash2.sortedUniq = sortedUniq;
        lodash2.sortedUniqBy = sortedUniqBy;
        lodash2.split = split;
        lodash2.spread = spread2;
        lodash2.tail = tail;
        lodash2.take = take;
        lodash2.takeRight = takeRight;
        lodash2.takeRightWhile = takeRightWhile;
        lodash2.takeWhile = takeWhile;
        lodash2.tap = tap;
        lodash2.throttle = throttle2;
        lodash2.thru = thru;
        lodash2.toArray = toArray2;
        lodash2.toPairs = toPairs;
        lodash2.toPairsIn = toPairsIn;
        lodash2.toPath = toPath;
        lodash2.toPlainObject = toPlainObject;
        lodash2.transform = transform;
        lodash2.unary = unary;
        lodash2.union = union;
        lodash2.unionBy = unionBy;
        lodash2.unionWith = unionWith;
        lodash2.uniq = uniq;
        lodash2.uniqBy = uniqBy;
        lodash2.uniqWith = uniqWith;
        lodash2.unset = unset;
        lodash2.unzip = unzip;
        lodash2.unzipWith = unzipWith;
        lodash2.update = update;
        lodash2.updateWith = updateWith;
        lodash2.values = values;
        lodash2.valuesIn = valuesIn;
        lodash2.without = without;
        lodash2.words = words;
        lodash2.wrap = wrap;
        lodash2.xor = xor;
        lodash2.xorBy = xorBy;
        lodash2.xorWith = xorWith;
        lodash2.zip = zip;
        lodash2.zipObject = zipObject;
        lodash2.zipObjectDeep = zipObjectDeep;
        lodash2.zipWith = zipWith;
        lodash2.entries = toPairs;
        lodash2.entriesIn = toPairsIn;
        lodash2.extend = assignIn;
        lodash2.extendWith = assignInWith;
        mixin(lodash2, lodash2);
        lodash2.add = add;
        lodash2.attempt = attempt;
        lodash2.camelCase = camelCase;
        lodash2.capitalize = capitalize;
        lodash2.ceil = ceil;
        lodash2.clamp = clamp;
        lodash2.clone = clone;
        lodash2.cloneDeep = cloneDeep;
        lodash2.cloneDeepWith = cloneDeepWith;
        lodash2.cloneWith = cloneWith;
        lodash2.conformsTo = conformsTo;
        lodash2.deburr = deburr;
        lodash2.defaultTo = defaultTo;
        lodash2.divide = divide;
        lodash2.endsWith = endsWith2;
        lodash2.eq = eq2;
        lodash2.escape = escape;
        lodash2.escapeRegExp = escapeRegExp;
        lodash2.every = every;
        lodash2.find = find;
        lodash2.findIndex = findIndex;
        lodash2.findKey = findKey2;
        lodash2.findLast = findLast;
        lodash2.findLastIndex = findLastIndex;
        lodash2.findLastKey = findLastKey;
        lodash2.floor = floor;
        lodash2.forEach = forEach2;
        lodash2.forEachRight = forEachRight;
        lodash2.forIn = forIn;
        lodash2.forInRight = forInRight;
        lodash2.forOwn = forOwn;
        lodash2.forOwnRight = forOwnRight;
        lodash2.get = get4;
        lodash2.gt = gt;
        lodash2.gte = gte;
        lodash2.has = has2;
        lodash2.hasIn = hasIn;
        lodash2.head = head;
        lodash2.identity = identity;
        lodash2.includes = includes;
        lodash2.indexOf = indexOf;
        lodash2.inRange = inRange;
        lodash2.invoke = invoke;
        lodash2.isArguments = isArguments;
        lodash2.isArray = isArray2;
        lodash2.isArrayBuffer = isArrayBuffer2;
        lodash2.isArrayLike = isArrayLike;
        lodash2.isArrayLikeObject = isArrayLikeObject;
        lodash2.isBoolean = isBoolean2;
        lodash2.isBuffer = isBuffer2;
        lodash2.isDate = isDate2;
        lodash2.isElement = isElement;
        lodash2.isEmpty = isEmpty;
        lodash2.isEqual = isEqual2;
        lodash2.isEqualWith = isEqualWith;
        lodash2.isError = isError;
        lodash2.isFinite = isFinite;
        lodash2.isFunction = isFunction2;
        lodash2.isInteger = isInteger;
        lodash2.isLength = isLength;
        lodash2.isMap = isMap;
        lodash2.isMatch = isMatch;
        lodash2.isMatchWith = isMatchWith;
        lodash2.isNaN = isNaN2;
        lodash2.isNative = isNative;
        lodash2.isNil = isNil;
        lodash2.isNull = isNull;
        lodash2.isNumber = isNumber2;
        lodash2.isObject = isObject2;
        lodash2.isObjectLike = isObjectLike;
        lodash2.isPlainObject = isPlainObject2;
        lodash2.isRegExp = isRegExp2;
        lodash2.isSafeInteger = isSafeInteger;
        lodash2.isSet = isSet;
        lodash2.isString = isString2;
        lodash2.isSymbol = isSymbol;
        lodash2.isTypedArray = isTypedArray2;
        lodash2.isUndefined = isUndefined2;
        lodash2.isWeakMap = isWeakMap;
        lodash2.isWeakSet = isWeakSet;
        lodash2.join = join;
        lodash2.kebabCase = kebabCase;
        lodash2.last = last;
        lodash2.lastIndexOf = lastIndexOf;
        lodash2.lowerCase = lowerCase;
        lodash2.lowerFirst = lowerFirst;
        lodash2.lt = lt;
        lodash2.lte = lte;
        lodash2.max = max;
        lodash2.maxBy = maxBy;
        lodash2.mean = mean;
        lodash2.meanBy = meanBy;
        lodash2.min = min;
        lodash2.minBy = minBy;
        lodash2.stubArray = stubArray;
        lodash2.stubFalse = stubFalse;
        lodash2.stubObject = stubObject;
        lodash2.stubString = stubString;
        lodash2.stubTrue = stubTrue;
        lodash2.multiply = multiply;
        lodash2.nth = nth;
        lodash2.noConflict = noConflict;
        lodash2.noop = noop3;
        lodash2.now = now;
        lodash2.pad = pad;
        lodash2.padEnd = padEnd;
        lodash2.padStart = padStart;
        lodash2.parseInt = parseInt2;
        lodash2.random = random;
        lodash2.reduce = reduce;
        lodash2.reduceRight = reduceRight;
        lodash2.repeat = repeat;
        lodash2.replace = replace3;
        lodash2.result = result;
        lodash2.round = round;
        lodash2.runInContext = runInContext2;
        lodash2.sample = sample;
        lodash2.size = size;
        lodash2.snakeCase = snakeCase;
        lodash2.some = some;
        lodash2.sortedIndex = sortedIndex;
        lodash2.sortedIndexBy = sortedIndexBy;
        lodash2.sortedIndexOf = sortedIndexOf;
        lodash2.sortedLastIndex = sortedLastIndex;
        lodash2.sortedLastIndexBy = sortedLastIndexBy;
        lodash2.sortedLastIndexOf = sortedLastIndexOf;
        lodash2.startCase = startCase;
        lodash2.startsWith = startsWith;
        lodash2.subtract = subtract;
        lodash2.sum = sum;
        lodash2.sumBy = sumBy;
        lodash2.template = template;
        lodash2.times = times;
        lodash2.toFinite = toFinite;
        lodash2.toInteger = toInteger;
        lodash2.toLength = toLength;
        lodash2.toLower = toLower;
        lodash2.toNumber = toNumber;
        lodash2.toSafeInteger = toSafeInteger;
        lodash2.toString = toString3;
        lodash2.toUpper = toUpper;
        lodash2.trim = trim2;
        lodash2.trimEnd = trimEnd;
        lodash2.trimStart = trimStart;
        lodash2.truncate = truncate;
        lodash2.unescape = unescape2;
        lodash2.uniqueId = uniqueId;
        lodash2.upperCase = upperCase;
        lodash2.upperFirst = upperFirst;
        lodash2.each = forEach2;
        lodash2.eachRight = forEachRight;
        lodash2.first = head;
        mixin(lodash2, function() {
          var source = {};
          baseForOwn(lodash2, function(func, methodName) {
            if (!hasOwnProperty2.call(lodash2.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash2.VERSION = VERSION2;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash2[methodName].placeholder = lodash2;
        });
        arrayEach(["drop", "take"], function(methodName, index2) {
          LazyWrapper.prototype[methodName] = function(n2) {
            n2 = n2 === undefined$1 ? 1 : nativeMax(toInteger(n2), 0);
            var result2 = this.__filtered__ && !index2 ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n2, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n2, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n2) {
            return this.reverse()[methodName](n2).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index2) {
          var type4 = index2 + 1, isFilter = type4 == LAZY_FILTER_FLAG || type4 == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type4
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index2) {
          var takeName = "take" + (index2 ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index2) {
          var dropName = "drop" + (index2 ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path2, args) {
          if (typeof path2 == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path2, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined$1) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash2[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash2.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray2(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash2, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined$1 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash2.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray2(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray2(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash2[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty2.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined$1
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash2.prototype.at = wrapperAt;
        lodash2.prototype.chain = wrapperChain;
        lodash2.prototype.commit = wrapperCommit;
        lodash2.prototype.next = wrapperNext;
        lodash2.prototype.plant = wrapperPlant;
        lodash2.prototype.reverse = wrapperReverse;
        lodash2.prototype.toJSON = lodash2.prototype.valueOf = lodash2.prototype.value = wrapperValue;
        lodash2.prototype.first = lodash2.prototype.head;
        if (symIterator) {
          lodash2.prototype[symIterator] = wrapperToIterator;
        }
        return lodash2;
      };
      var _2 = runInContext();
      if (freeModule) {
        (freeModule.exports = _2)._ = _2;
        freeExports._ = _2;
      } else {
        root._ = _2;
      }
    }).call(commonjsGlobal);
  })(lodash, lodash.exports);
  var lodashExports = lodash.exports;
  const _ = /* @__PURE__ */ getDefaultExportFromCjs(lodashExports);
  var extendStatics = function(d2, b2) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
      d3.__proto__ = b3;
    } || function(d3, b3) {
      for (var p2 in b3)
        if (Object.prototype.hasOwnProperty.call(b3, p2))
          d3[p2] = b3[p2];
    };
    return extendStatics(d2, b2);
  };
  function __extends(d2, b2) {
    if (typeof b2 !== "function" && b2 !== null)
      throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
    extendStatics(d2, b2);
    function __() {
      this.constructor = d2;
    }
    d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
  }
  var __assign = function() {
    __assign = Object.assign || function __assign2(t2) {
      for (var s, i = 1, n2 = arguments.length; i < n2; i++) {
        s = arguments[i];
        for (var p2 in s)
          if (Object.prototype.hasOwnProperty.call(s, p2))
            t2[p2] = s[p2];
      }
      return t2;
    };
    return __assign.apply(this, arguments);
  };
  typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e2 = new Error(message);
    return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
  };
  var lib = {};
  var sensorPool = {};
  var id = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var id2 = 1;
    var _default = function _default2() {
      return "".concat(id2++);
    };
    exports["default"] = _default;
  })(id);
  var sensors = {};
  var object4 = {};
  var debounce = {};
  (function(exports) {
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _default = function _default2(fn) {
      var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
      var timer = null;
      return function() {
        var _this = this;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        clearTimeout(timer);
        timer = setTimeout(function() {
          fn.apply(_this, args);
        }, delay);
      };
    };
    exports["default"] = _default;
  })(debounce);
  var constant = {};
  Object.defineProperty(constant, "__esModule", {
    value: true
  });
  constant.SensorTabIndex = constant.SensorClassName = constant.SizeSensorId = void 0;
  var SizeSensorId = "size-sensor-id";
  constant.SizeSensorId = SizeSensorId;
  var SensorClassName = "size-sensor-object";
  constant.SensorClassName = SensorClassName;
  var SensorTabIndex = "-1";
  constant.SensorTabIndex = SensorTabIndex;
  Object.defineProperty(object4, "__esModule", {
    value: true
  });
  object4.createSensor = void 0;
  var _debounce$1 = _interopRequireDefault$2(debounce);
  var _constant$1 = constant;
  function _interopRequireDefault$2(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var createSensor$2 = function createSensor(element) {
    var sensor = void 0;
    var listeners = [];
    var newSensor = function newSensor2() {
      if (getComputedStyle(element).position === "static") {
        element.style.position = "relative";
      }
      var obj = document.createElement("object");
      obj.onload = function() {
        obj.contentDocument.defaultView.addEventListener("resize", resizeListener);
        resizeListener();
      };
      obj.style.display = "block";
      obj.style.position = "absolute";
      obj.style.top = "0";
      obj.style.left = "0";
      obj.style.height = "100%";
      obj.style.width = "100%";
      obj.style.overflow = "hidden";
      obj.style.pointerEvents = "none";
      obj.style.zIndex = "-1";
      obj.style.opacity = "0";
      obj.setAttribute("class", _constant$1.SensorClassName);
      obj.setAttribute("tabindex", _constant$1.SensorTabIndex);
      obj.type = "text/html";
      element.appendChild(obj);
      obj.data = "about:blank";
      return obj;
    };
    var resizeListener = (0, _debounce$1["default"])(function() {
      listeners.forEach(function(listener) {
        listener(element);
      });
    });
    var bind3 = function bind4(cb) {
      if (!sensor) {
        sensor = newSensor();
      }
      if (listeners.indexOf(cb) === -1) {
        listeners.push(cb);
      }
    };
    var destroy = function destroy2() {
      if (sensor && sensor.parentNode) {
        if (sensor.contentDocument) {
          sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener);
        }
        sensor.parentNode.removeChild(sensor);
        sensor = void 0;
        listeners = [];
      }
    };
    var unbind = function unbind2(cb) {
      var idx = listeners.indexOf(cb);
      if (idx !== -1) {
        listeners.splice(idx, 1);
      }
      if (listeners.length === 0 && sensor) {
        destroy();
      }
    };
    return {
      element,
      bind: bind3,
      destroy,
      unbind
    };
  };
  object4.createSensor = createSensor$2;
  var resizeObserver = {};
  Object.defineProperty(resizeObserver, "__esModule", {
    value: true
  });
  resizeObserver.createSensor = void 0;
  var _debounce = _interopRequireDefault$1(debounce);
  function _interopRequireDefault$1(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var createSensor$1 = function createSensor2(element) {
    var sensor = void 0;
    var listeners = [];
    var resizeListener = (0, _debounce["default"])(function() {
      listeners.forEach(function(listener) {
        listener(element);
      });
    });
    var newSensor = function newSensor2() {
      var s = new ResizeObserver(resizeListener);
      s.observe(element);
      resizeListener();
      return s;
    };
    var bind3 = function bind4(cb) {
      if (!sensor) {
        sensor = newSensor();
      }
      if (listeners.indexOf(cb) === -1) {
        listeners.push(cb);
      }
    };
    var destroy = function destroy2() {
      sensor.disconnect();
      listeners = [];
      sensor = void 0;
    };
    var unbind = function unbind2(cb) {
      var idx = listeners.indexOf(cb);
      if (idx !== -1) {
        listeners.splice(idx, 1);
      }
      if (listeners.length === 0 && sensor) {
        destroy();
      }
    };
    return {
      element,
      bind: bind3,
      destroy,
      unbind
    };
  };
  resizeObserver.createSensor = createSensor$1;
  Object.defineProperty(sensors, "__esModule", {
    value: true
  });
  sensors.createSensor = void 0;
  var _object = object4;
  var _resizeObserver = resizeObserver;
  var createSensor3 = typeof ResizeObserver !== "undefined" ? _resizeObserver.createSensor : _object.createSensor;
  sensors.createSensor = createSensor3;
  Object.defineProperty(sensorPool, "__esModule", {
    value: true
  });
  sensorPool.removeSensor = sensorPool.getSensor = void 0;
  var _id = _interopRequireDefault(id);
  var _sensors = sensors;
  var _constant = constant;
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { "default": obj };
  }
  var Sensors = {};
  var getSensor = function getSensor2(element) {
    var sensorId = element.getAttribute(_constant.SizeSensorId);
    if (sensorId && Sensors[sensorId]) {
      return Sensors[sensorId];
    }
    var newId = (0, _id["default"])();
    element.setAttribute(_constant.SizeSensorId, newId);
    var sensor = (0, _sensors.createSensor)(element);
    Sensors[newId] = sensor;
    return sensor;
  };
  sensorPool.getSensor = getSensor;
  var removeSensor = function removeSensor2(sensor) {
    var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
    sensor.element.removeAttribute(_constant.SizeSensorId);
    sensor.destroy();
    if (sensorId && Sensors[sensorId]) {
      delete Sensors[sensorId];
    }
  };
  sensorPool.removeSensor = removeSensor;
  Object.defineProperty(lib, "__esModule", {
    value: true
  });
  lib.ver = clear_1 = lib.clear = bind_1 = lib.bind = void 0;
  var _sensorPool = sensorPool;
  var bind = function bind2(element, cb) {
    var sensor = (0, _sensorPool.getSensor)(element);
    sensor.bind(cb);
    return function() {
      sensor.unbind(cb);
    };
  };
  var bind_1 = lib.bind = bind;
  var clear2 = function clear3(element) {
    var sensor = (0, _sensorPool.getSensor)(element);
    (0, _sensorPool.removeSensor)(sensor);
  };
  var clear_1 = lib.clear = clear2;
  var ver = "1.0.1";
  lib.ver = ver;
  function pick(obj, keys2) {
    var r2 = {};
    keys2.forEach(function(key) {
      r2[key] = obj[key];
    });
    return r2;
  }
  function isFunction(v2) {
    return typeof v2 === "function";
  }
  function isString(v2) {
    return typeof v2 === "string";
  }
  var fastDeepEqual = function equal(a, b2) {
    if (a === b2)
      return true;
    if (a && b2 && typeof a == "object" && typeof b2 == "object") {
      if (a.constructor !== b2.constructor)
        return false;
      var length2, i, keys2;
      if (Array.isArray(a)) {
        length2 = a.length;
        if (length2 != b2.length)
          return false;
        for (i = length2; i-- !== 0; )
          if (!equal(a[i], b2[i]))
            return false;
        return true;
      }
      if (a.constructor === RegExp)
        return a.source === b2.source && a.flags === b2.flags;
      if (a.valueOf !== Object.prototype.valueOf)
        return a.valueOf() === b2.valueOf();
      if (a.toString !== Object.prototype.toString)
        return a.toString() === b2.toString();
      keys2 = Object.keys(a);
      length2 = keys2.length;
      if (length2 !== Object.keys(b2).length)
        return false;
      for (i = length2; i-- !== 0; )
        if (!Object.prototype.hasOwnProperty.call(b2, keys2[i]))
          return false;
      for (i = length2; i-- !== 0; ) {
        var key = keys2[i];
        if (!equal(a[key], b2[key]))
          return false;
      }
      return true;
    }
    return a !== a && b2 !== b2;
  };
  const isEqual = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqual);
  var EChartsReactCore = (
    /** @class */
    function(_super) {
      __extends(EChartsReactCore2, _super);
      function EChartsReactCore2(props) {
        var _this = _super.call(this, props) || this;
        _this.echarts = props.echarts;
        _this.ele = null;
        _this.isInitialResize = true;
        return _this;
      }
      EChartsReactCore2.prototype.componentDidMount = function() {
        this.renderNewEcharts();
      };
      EChartsReactCore2.prototype.componentDidUpdate = function(prevProps) {
        var shouldSetOption = this.props.shouldSetOption;
        if (isFunction(shouldSetOption) && !shouldSetOption(prevProps, this.props)) {
          return;
        }
        if (!isEqual(prevProps.theme, this.props.theme) || !isEqual(prevProps.opts, this.props.opts) || !isEqual(prevProps.onEvents, this.props.onEvents)) {
          this.dispose();
          this.renderNewEcharts();
          return;
        }
        var pickKeys = ["option", "notMerge", "lazyUpdate", "showLoading", "loadingOption"];
        if (!isEqual(pick(this.props, pickKeys), pick(prevProps, pickKeys))) {
          this.updateEChartsOption();
        }
        if (!isEqual(prevProps.style, this.props.style) || !isEqual(prevProps.className, this.props.className)) {
          this.resize();
        }
      };
      EChartsReactCore2.prototype.componentWillUnmount = function() {
        this.dispose();
      };
      EChartsReactCore2.prototype.getEchartsInstance = function() {
        return this.echarts.getInstanceByDom(this.ele) || this.echarts.init(this.ele, this.props.theme, this.props.opts);
      };
      EChartsReactCore2.prototype.dispose = function() {
        if (this.ele) {
          try {
            clear_1(this.ele);
          } catch (e2) {
            console.warn(e2);
          }
          this.echarts.dispose(this.ele);
        }
      };
      EChartsReactCore2.prototype.renderNewEcharts = function() {
        var _this = this;
        var _a2 = this.props, onEvents = _a2.onEvents, onChartReady = _a2.onChartReady;
        var echartsInstance = this.updateEChartsOption();
        this.bindEvents(echartsInstance, onEvents || {});
        if (isFunction(onChartReady))
          onChartReady(echartsInstance);
        if (this.ele) {
          bind_1(this.ele, function() {
            _this.resize();
          });
        }
      };
      EChartsReactCore2.prototype.bindEvents = function(instance, events) {
        function _bindEvent(eventName2, func) {
          if (isString(eventName2) && isFunction(func)) {
            instance.on(eventName2, function(param) {
              func(param, instance);
            });
          }
        }
        for (var eventName in events) {
          if (Object.prototype.hasOwnProperty.call(events, eventName)) {
            _bindEvent(eventName, events[eventName]);
          }
        }
      };
      EChartsReactCore2.prototype.updateEChartsOption = function() {
        var _a2 = this.props, option = _a2.option, _b = _a2.notMerge, notMerge = _b === void 0 ? false : _b, _c = _a2.lazyUpdate, lazyUpdate = _c === void 0 ? false : _c, showLoading = _a2.showLoading, _d = _a2.loadingOption, loadingOption = _d === void 0 ? null : _d;
        var echartInstance = this.getEchartsInstance();
        echartInstance.setOption(option, notMerge, lazyUpdate);
        if (showLoading)
          echartInstance.showLoading(loadingOption);
        else
          echartInstance.hideLoading();
        return echartInstance;
      };
      EChartsReactCore2.prototype.resize = function() {
        var echartsInstance = this.getEchartsInstance();
        if (!this.isInitialResize) {
          try {
            echartsInstance.resize();
          } catch (e2) {
            console.warn(e2);
          }
        }
        this.isInitialResize = false;
      };
      EChartsReactCore2.prototype.render = function() {
        var _this = this;
        var _a2 = this.props, style2 = _a2.style, _b = _a2.className, className = _b === void 0 ? "" : _b;
        var newStyle = __assign({ height: 300 }, style2);
        return React.createElement("div", { ref: function(e2) {
          _this.ele = e2;
        }, style: newStyle, className: "echarts-for-react " + className });
      };
      return EChartsReactCore2;
    }(React.PureComponent)
  );
  var EChartsReact = (
    /** @class */
    function(_super) {
      __extends(EChartsReact2, _super);
      function EChartsReact2(props) {
        var _this = _super.call(this, props) || this;
        _this.echarts = echarts__namespace;
        return _this;
      }
      return EChartsReact2;
    }(EChartsReactCore)
  );
  const upColor = red.primary;
  const downColor = green.primary;
  function splitData(rawData) {
    let categoryData = [];
    let values = [];
    let volumes = [];
    for (let i = 0; i < rawData.length; i++) {
      categoryData.push(rawData[i].splice(0, 1)[0]);
      values.push(rawData[i]);
      volumes.push([i, rawData[i][4], rawData[i][0] > rawData[i][1] ? 1 : -1]);
    }
    return {
      categoryData,
      values,
      volumes
    };
  }
  function calculateMA(dayCount, data) {
    var result = [];
    for (var i = 0, len = data.values.length; i < len; i++) {
      if (i < dayCount) {
        result.push("-");
        continue;
      }
      var sum = 0;
      for (var j = 0; j < dayCount; j++) {
        sum += data.values[i - j][1];
      }
      result.push(+(sum / dayCount).toFixed(3));
    }
    return result;
  }
  function createEchartsCandleOption(rawData) {
    var data = splitData(rawData);
    return {
      animation: false,
      legend: {
        bottom: 10,
        left: "center",
        data: ["ELO", "MA5", "MA10", "MA20", "MA30"]
      },
      tooltip: {
        trigger: "axis",
        axisPointer: {
          type: "cross"
        },
        borderWidth: 1,
        borderColor: "#ccc",
        padding: 10,
        textStyle: {
          color: "#000"
        },
        position: function(pos, params, el, elRect, size) {
          const obj = {
            top: 10
          };
          obj[["left", "right"][+(pos[0] < size.viewSize[0] / 2)]] = 30;
          return obj;
        }
        // extraCssText: 'width: 170px'
      },
      axisPointer: {
        link: [
          {
            xAxisIndex: "all"
          }
        ],
        label: {
          backgroundColor: "#777"
        }
      },
      toolbox: {
        feature: {
          dataZoom: {
            yAxisIndex: false
          },
          brush: {
            type: ["lineX", "clear"]
          }
        }
      },
      brush: {
        xAxisIndex: "all",
        brushLink: "all",
        outOfBrush: {
          colorAlpha: 0.1
        }
      },
      visualMap: {
        show: false,
        seriesIndex: 5,
        dimension: 2,
        pieces: [
          {
            value: 1,
            color: downColor
          },
          {
            value: -1,
            color: upColor
          }
        ]
      },
      grid: [
        {
          left: "10%",
          right: "8%",
          height: "50%"
        },
        {
          left: "10%",
          right: "8%",
          top: "63%",
          height: "16%"
        }
      ],
      xAxis: [
        {
          type: "category",
          data: data.categoryData,
          boundaryGap: false,
          axisLine: { onZero: false },
          splitLine: { show: false },
          min: "dataMin",
          max: "dataMax",
          axisPointer: {
            z: 100
          }
        },
        {
          type: "category",
          gridIndex: 1,
          data: data.categoryData,
          boundaryGap: false,
          axisLine: { onZero: false },
          axisTick: { show: false },
          splitLine: { show: false },
          axisLabel: { show: false },
          min: "dataMin",
          max: "dataMax"
        }
      ],
      yAxis: [
        {
          scale: true,
          splitArea: {
            show: true
          }
        },
        {
          scale: true,
          gridIndex: 1,
          splitNumber: 2,
          axisLabel: { show: false },
          axisLine: { show: false },
          axisTick: { show: false },
          splitLine: { show: false }
        }
      ],
      dataZoom: [
        {
          type: "inside",
          xAxisIndex: [0, 1],
          start: 0,
          end: 100
        },
        {
          show: true,
          xAxisIndex: [0, 1],
          type: "slider",
          top: "85%",
          start: 98,
          end: 100
        }
      ],
      series: [
        {
          name: "ELO",
          type: "candlestick",
          data: data.values,
          itemStyle: {
            color: upColor,
            color0: downColor,
            borderColor: void 0,
            borderColor0: void 0
          }
        },
        {
          name: "MA5",
          type: "line",
          data: calculateMA(5, data),
          smooth: true,
          lineStyle: {
            opacity: 0.5
          }
        },
        {
          name: "MA10",
          type: "line",
          data: calculateMA(10, data),
          smooth: true,
          lineStyle: {
            opacity: 0.5
          }
        },
        {
          name: "MA20",
          type: "line",
          data: calculateMA(20, data),
          smooth: true,
          lineStyle: {
            opacity: 0.5
          }
        },
        {
          name: "MA30",
          type: "line",
          data: calculateMA(30, data),
          smooth: true,
          lineStyle: {
            opacity: 0.5
          }
        },
        {
          name: "Volume",
          type: "bar",
          xAxisIndex: 1,
          yAxisIndex: 1,
          data: data.volumes
        }
      ]
    };
  }
  class EloHistoryItem {
    constructor(prop) {
      __publicField(this, "id", 0);
      __publicField(this, "matchId", 0);
      __publicField(this, "currentElo", 0);
      __publicField(this, "wonGame", false);
      __publicField(this, "team", 0);
      __publicField(this, "ranked", false);
      __publicField(this, "createdAt", "");
      __publicField(this, "type", "");
      _.extend(this, prop);
    }
    get date() {
      return _.first(this.createdAt.split("T"));
    }
  }
  class EchartsDataItem {
    constructor(prop) {
      __publicField(this, "date", "");
      __publicField(this, "open", 0);
      __publicField(this, "close", 0);
      __publicField(this, "lowest", 0);
      __publicField(this, "highest", 0);
      __publicField(this, "volume", 0);
      _.extend(this, prop);
    }
    toEchartsListData() {
      return [this.date, this.open, this.close, this.lowest, this.highest, this.volume];
    }
  }
  class AppState {
    constructor() {
      __publicField(this, "open", false);
      __publicField(this, "loading", false);
      __publicField(this, "eloHis", []);
      __publicField(this, "onCancel", () => {
        this.open = false;
        this.eloHis = [];
      });
      __publicField(this, "onOpen", () => {
        this.open = true;
        this.fetch();
      });
      makeAutoObservable(this);
    }
    async fetch() {
      this.loading = true;
      try {
        let pathname = window.location.pathname;
        console.log(pathname);
        let userId = _.last(pathname.split("/"));
        console.log(userId);
        const dataUrl = `https://www.elevenvr.club/accounts/${userId}/elo-history`;
        let response = await axios$1.get(dataUrl);
        console.log(response.data.data);
        let list = response.data.data;
        const eloHis = list.map((o) => {
          const attributes2 = o.attributes;
          return new EloHistoryItem({
            id: attributes2.id,
            currentElo: _.get(attributes2, "current-elo"),
            wonGame: _.get(attributes2, "won-game"),
            matchId: _.get(attributes2, "match-id"),
            createdAt: _.get(attributes2, "created-at"),
            team: attributes2.team,
            ranked: attributes2.ranked,
            type: o.type
          });
        });
        console.log(eloHis);
        this.eloHis = eloHis;
      } finally {
        this.loading = false;
      }
    }
    toEchartsData() {
      let originGroups = _.groupBy(this.eloHis, (it) => it.date);
      return _.map(originGroups, (group, key) => {
        var _a2, _b, _c, _d;
        return new EchartsDataItem({
          date: key,
          open: (_a2 = _.first(group)) == null ? void 0 : _a2.currentElo,
          close: (_b = _.last(group)) == null ? void 0 : _b.currentElo,
          lowest: (_c = _.minBy(group, (it) => it.currentElo)) == null ? void 0 : _c.currentElo,
          highest: (_d = _.maxBy(group, (it) => it.currentElo)) == null ? void 0 : _d.currentElo,
          volume: group.length
        });
      });
    }
    toEchartsListData() {
      return this.toEchartsData().map((it) => it.toEchartsListData());
    }
    getOption() {
      return createEchartsCandleOption(this.toEchartsListData());
    }
  }
  function AppFn() {
    const state = useLocalObservable(() => new AppState());
    return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(FloatButton$1, { icon: /* @__PURE__ */ jsxRuntimeExports.jsx(SlidersOutlined$1, {}), onClick: state.onOpen }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Modal$1,
        {
          title: "Candlestick - K线图",
          open: state.open,
          destroyOnClose: true,
          footer: false,
          onCancel: state.onCancel,
          width: document.body.clientWidth - 100,
          bodyStyle: {},
          children: state.loading ? /* @__PURE__ */ jsxRuntimeExports.jsx(Skeleton$1, { active: true }) : state.eloHis.length == 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx(Empty$1, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(EChartsReact, { option: state.getOption(), style: {
            height: document.body.clientHeight - 200
          } })
        }
      )
    ] });
  }
  const App = observer(AppFn);
  client.createRoot(
    (() => {
      const app = document.createElement("div");
      document.body.append(app);
      return app;
    })()
  ).render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(App, {}) })
  );

})(React, ReactDOM, echarts);
